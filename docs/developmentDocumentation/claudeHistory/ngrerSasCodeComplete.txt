file name: Optimization_SubModule_GTW.sas

/* 22OCT2019 - Former name of this code was "IDM_19JUL2017_NGRER"   */
/* 22OCT2019 - In an effort to reduce ERC-P shortages, multiplied the original
   ERC-P priority listed below by 1000 */ 

/**/
/*code added to manipulate darpl: BE SURE TO REMOVE THIS WHEN RUNNING A REAL RUN DEREK!
%let darpl_d = darpl = darpl;*/

/*the below macro will tell SAS to write to a
permanent LOG file rather than continuously printing
to the SAS applcation long.

Due to the number fo times the model iterates over
teh data the log in SAS will fill up and need
to be manually cleared. with this option enabled
this manual intervention is not needed and
the log is saved for further review.*/
options symbolgen MLOGIC MLOGICNEST mprint mlogic MPRINTNEST MAUTOSOURCE SYMBOLGEN SPOOL FULLSTIMER minoperator mindelimiter=',';
OPTIONS FORMCHAR="|----|+|---+=|-/\<>*";

%macro logging();

/*This is a optional toggle that an analyst
can enable or disable. If an analyst is investigating 
a single LIN group then the show log can
be turned on so that it prints to the
SAS log window.*/
	%if %eval(&show_log = 0) %then %do;

		option nospool;
/*This procedure prints the log into a permenant txt file.*/
		proc printto log = "&Data_Output_Path\&log_name..txt";
		run;
		quit;
	%end;
%mend;
%logging;


/*These are macro variables that are assigned and 
used to determine the years in the run, and the fill target
to aim for.*/

%let min_year = ;
%let first_year = ;

%let last_year = ;
%let fill_target = ;

%let run = /* _1*/;


/*The below priorities are used as weights in the objective function
which is seeking to minimize the total value of the equation.
ERC P shortages are more painful to the objective function than
all other types of shortages, ERC A are the second most, erc B and C
are negligable and also not considered due to the data cleaning.*/


%let p_pri = 10000000000;
/* %let p_pri = 10000000 */;
%let a_pri = 500;
%let b_pri = 100;
%let c_pri = 10;

/*Penalty for transfering inventory between Compos*/

/*This penalty will penalize the transfer of equipment from
one compo to another, which is meant to ensure that 
only excess is traded. This weight is intentionally
lower than the shortage penalties, and excess penalties in 
an effort to make sure that the inventory flows and is utilized 
properly.*/
%let trans_pen = 150;

/*Mod Inventory Excess Penalty*/
/*The below penalties are used to penalize having excess inventory where
having mod-5 excess is the most painful, mod 4 second most, mod 3 third most
and mod 2/1 are neglidgable.*/
%let mod_5_e_pen = 999;
%let mod_4_e_pen = 499;
%let mod_3_e_pen = 200;
%let mod_2_e_pen = 10;
%let mod_1_e_pen = 5;

/*Sub Assign Penalty*/
/*This is a small and inactive penalty for the use of substitutions.*/
%let sub_assign_pen = .01;



/*If we have determined a set of sub-rules to ignore the the
set will be printed to the log by this statement.*/
%put &sub_ignore_set;


/*the following SQL query will assign the first and last years
of the study timeframe macro variables.*/
/*proc sql noprint;*/
/*	select*/
/*		first_year, last_year into :first_year, :last_year*/
/*	from idm_i.study_timeframe;*/
/*quit;*/
%let first_year=&Y1;
%let last_year=&Y7;

%put &first_year;
%put &last_year;

%include "&code_path\generate_opt_model_inputs.sas";
/*the following SQL query will assign the fill target (generally 1.0 or 100%)
of the study timeframe macro variables.*/
proc sql noprint;
	select
		target_percentage into :fill_target
	from idm_i.fill_target;
quit;

%put &fill_target;

/*The following sql query will get the lowest year in the inputs data set and 
assign the min year macro variable.*/

%let min_year = &first_year;


/*The purpose of this module is to take the User defined subset of Sources to ignore and 
process the data into a Set format for the Optmodel Procedure to interpret.

A set is defined as a grouping of like values in the form:
{e1, e2, ... , eN} where each item (or ei) is unique*/

/*%include "&code_path\generate_opt_model_inputs.sas";*/


%include "&code_path\set_opt_model_run_params.sas";
%include "&code_path\make_sub_ignore_set.sas";
%include "&code_path\generate_clusters.sas";

%include "&code_path\model_optimization.sas";





file name: Optimization_SubModule_OSD.sas

/* 22OCT2019 - Former name of this code was "IDM_19JUL2017_NGRER"   */
/* 22OCT2019 - In an effort to reduce ERC-P shortages, multiplied the original
   ERC-P priority listed below by 1000 */ 

/**/
/*code added to manipulate darpl: BE SURE TO REMOVE THIS WHEN RUNNING A REAL RUN DEREK!
%let darpl_d = darpl = darpl;*/

/*the below macro will tell SAS to write to a
permanent LOG file rather than continuously printing
to the SAS applcation long.

Due to the number fo times the model iterates over
teh data the log in SAS will fill up and need
to be manually cleared. with this option enabled
this manual intervention is not needed and
the log is saved for further review.*/
options symbolgen MLOGIC MLOGICNEST mprint mlogic MPRINTNEST MAUTOSOURCE SYMBOLGEN SPOOL FULLSTIMER minoperator mindelimiter=',';
OPTIONS FORMCHAR="|----|+|---+=|-/\<>*";

%macro logging();

/*This is a optional toggle that an analyst
can enable or disable. If an analyst is investigating 
a single LIN group then the show log can
be turned on so that it prints to the
SAS log window.*/
	%if %eval(&show_log = 0) %then %do;

		option nospool;
/*This procedure prints the log into a permenant txt file.*/
		proc printto log = "&Data_Output_Path\&log_name..txt";
		run;
		quit;
	%end;
%mend;
%logging;


/*These are macro variables that are assigned and 
used to determine the years in the run, and the fill target
to aim for.*/

%let min_year = ;
%let first_year = ;

%let last_year = ;
%let fill_target = ;

%let run = /* _1*/;


/*The below priorities are used as weights in the objective function
which is seeking to minimize the total value of the equation.
ERC P shortages are more painful to the objective function than
all other types of shortages, ERC A are the second most, erc B and C
are negligable and also not considered due to the data cleaning.*/


%let p_pri = 10000000000;
/* %let p_pri = 10000000 */;
%let a_pri = 500;
%let b_pri = 100;
%let c_pri = 10;

/*Penalty for transfering inventory between Compos*/

/*This penalty will penalize the transfer of equipment from
one compo to another, which is meant to ensure that 
only excess is traded. This weight is intentionally
lower than the shortage penalties, and excess penalties in 
an effort to make sure that the inventory flows and is utilized 
properly.*/
%let trans_pen = 150;

/*Mod Inventory Excess Penalty*/
/*The below penalties are used to penalize having excess inventory where
having mod-5 excess is the most painful, mod 4 second most, mod 3 third most
and mod 2/1 are neglidgable.*/
%let mod_5_e_pen = 999;
%let mod_4_e_pen = 499;
%let mod_3_e_pen = 200;
%let mod_2_e_pen = 10;
%let mod_1_e_pen = 5;

/*Sub Assign Penalty*/
/*This is a small and inactive penalty for the use of substitutions.*/
%let sub_assign_pen = .01;



/*If we have determined a set of sub-rules to ignore the the
set will be printed to the log by this statement.*/
%put &sub_ignore_set;


/*the following SQL query will assign the first and last years
of the study timeframe macro variables.*/
/*proc sql noprint;*/
/*	select*/
/*		first_year, last_year into :first_year, :last_year*/
/*	from idm_i.study_timeframe;*/
/*quit;*/
%let first_year=&Y1;
%let last_year=&Y7;

%put &first_year;
%put &last_year;

%include "&code_path\generate_opt_model_inputs.sas";
/*the following SQL query will assign the fill target (generally 1.0 or 100%)
of the study timeframe macro variables.*/
proc sql noprint;
	select
		target_percentage into :fill_target
	from idm_i.fill_target;
quit;

%put &fill_target;

/*The following sql query will get the lowest year in the inputs data set and 
assign the min year macro variable.*/

%let min_year = &first_year;


/*The purpose of this module is to take the User defined subset of Sources to ignore and 
process the data into a Set format for the Optmodel Procedure to interpret.

A set is defined as a grouping of like values in the form:
{e1, e2, ... , eN} where each item (or ei) is unique*/

/*%include "&code_path\generate_opt_model_inputs.sas";*/


%include "&code_path\set_opt_model_run_params.sas";
%include "&code_path\make_sub_ignore_set.sas";
%include "&code_path\generate_clusters.sas";

%include "&code_path\model_optimization_nosubs.sas";






file name: set_opt_model_run_params.sas

/*the below data step creates the run-parameter data set that
can later be referenced when citing the run parameters considered.*/
data Run_Parameters;

	length
		run_name $ 25 run_level $ 25 log_name $ 50 code_path $ 200 input_path $ 200 output_path $ 200 base_code $ 50 max_date 8 
		inputs_regenerated $ 3 clusters_processed $ 3 single_component 8 log_shown $ 3 subs_allowed $ 3
		modern_subs_only $ 3 typcos_in_run $ 20 unit_inv_xfer_penalty 8 slack_provided $ 3 
		first_two_fixed $ 3 lmi_data_used $ 4 trans_var $ 15 p_pri 8 a_pri 8 mod_5_e_pen 8 mod_4_e_pen 8
		mod_3_e_pen 8 mod_2_e_pen 8 mod_1_e_pen 8 transfer_pen 8 first_year 8 last_year 8 fill_target 8 
		minimum_year 8;

	run_name = "&run_name";
	run_level = "&run_level";
	code_path = "&code_path";
	input_path = "&idm_input";
	output_path = "&idm_output";
	base_code = "&model_base";

	max_date = &max_date.;

	if &run_all_inputs. = 1 then inputs_regenerated = "Yes";
	else inputs_regenerated = "No";

	if &run_cluster. = 1 then clusters_processed = "Yes";
	else clusters_processed = "No";

	single_component = &single_component.;
	log_name = "&log_name";

	if &show_log. = 1 then log_shown = "Yes";
	else log_shown = "No";

	if &subs_allowed. = 1 then subs_allowed = "Yes";
	else subs_allowed = "No";

	if &modern_subs. = 1 then modern_subs_only = "Yes";
	else modern_subs_only = "No";

	typcos_in_run = "&t_filter";

	unit_inv_xfer_penalty = &unit_yearly_xfer_pen.;

	if &fix_flex. = 1 then slack_provided = "Yes";
	else slack_provided = "No";

	if &freeze_first_two. = 1 then first_two_fixed = "Yes";
	else first_two_fixed = "No";

	if &use_lmi. = 1 then lmi_data_used = "Yes";
	else lmi_data_used = "No";


	p_pri = &p_pri.;
	a_pri = &a_pri.;
	mod_5_e_pen  = &mod_5_e_pen.;
	mod_4_e_pen = &mod_4_e_pen.;
	mod_3_e_pen = &mod_3_e_pen.;
	mod_2_e_pen = &mod_2_e_pen.;
	mod_1_e_pen = &mod_1_e_pen.;
	transfer_pen = &trans_pen.;

	first_year =&first_year.;
	last_year = &last_year.;
	fill_target = &fill_target.;
	minimum_year = &min_year.;
	
	run_num = 1;

	trans_var = "Setting";

run;

/*This transpose step makes the wide table into a long table for easier viewing and citation.*/
proc transpose data = Run_Parameters out = run_parm_imploded;
	by run_num;
	id trans_var;
	var run_name  run_level  log_name code_path  input_path output_path base_code max_date  
		inputs_regenerated  clusters_processed single_component  log_shown  subs_allowed 
		modern_subs_only typcos_in_run  unit_inv_xfer_penalty  slack_provided  
		first_two_fixed  lmi_data_used trans_var  p_pri  a_pri  mod_5_e_pen  mod_4_e_pen 
		mod_3_e_pen  mod_2_e_pen  mod_1_e_pen  transfer_pen  first_year  last_year  fill_target  
		minimum_year ;
run;

/*this data step permanently writes the run parameter file to the output folder.*/
data idm_o.Run_Parameters;
	set run_parm_imploded;

	drop run_num;
	label _name_ = "All Parameters";
	rename _name_ = Parameter;
run;




file name: write_ngrer_reports.sas

options symbolgen MLOGIC MLOGICNEST mprint mlogic MPRINTNEST MAUTOSOURCE SYMBOLGEN SPOOL FULLSTIMER minoperator mindelimiter=',';
OPTIONS FORMCHAR="|----|+|---+=|-/\<>*";
options dlcreatedir;

/*%let OSD_PATH =		O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\OSD\12AUG2025__NOSUBS\OPT_Output;*/
/*%let GTW_PATH =		O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\GTW\13AUG2025__SUBS\OPT_Output;*/
/**/
/*libname OSD "&OSD_PATH";*/
/*libname GTW "&GTW_PATH";*/
/*%let current_cycle = FY21;*/
/*%let STUDY_PATH =			O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\&current_cycle.;*/
/*%let zdate=03SEP2021;*/
%let Deliverables_Path =	O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Deliverables\12AUG2025_NGRER_OPT_Deliverables;
libname Deliver "&Deliverables_Path";

/*%include "&code_path\NGRER_Summary_reports_v2.sas";*/

/*%let xdate = 11AUG2021;*/

%macro outdata2;


	options mcompilenote=ALL; *turns on compilation error notes;
	options mprint; *allows you to see the code within the macro;
	options mlogic; *displays macro execution messages;

	options mprint symbolgen noxwait noxsync;


	%let xlsfile=%STR(NGRER_Report_Template_v3.xlsb);
	%let FILEDIR=%STR(O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Excel Template);

    options mprint symbolgen noxwait noxsync;
/*	OPTIONS XWAIT NOXSYNC ;*/
/*	X  "'&SHEETDIR.&xlssheet.'";*/


	DATA _NULL_;
	  rc=SLEEP(5);
	RUN;

    filename cmds dde 'excel|system';
	x %unquote(%str(%'"&FILEDIR\%trim(&xlsfile.)"%'));

	DATA _NULL_;
	  rc=SLEEP(10);
	RUN;


	FILENAME SLIDE4 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide4_OSD!R24C3:R26C9" NOTAB; /*TA_EOH_mod_cht2*/
	FILENAME SLIDE5 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide5_GTW!R24C3:R26C9" NOTAB; /*TA_EOH_mod_cht2*/
	FILENAME SLIDE6 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide6_OSD!R2C2:R4C4" NOTAB; /*TA_EOH_sum_cht2*/
	FILENAME SLIDE7 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide7_OSD!R2C2:R4C4" NOTAB; /*TA_EOH_sum_cht3*/
	FILENAME SLIDE8 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide8_GTW!R2C2:R4C4" NOTAB; /*TA_EOH_sum_cht2*/
	FILENAME SLIDE9 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide9_GTW!R2C2:R4C4" NOTAB; /*TA_EOH_sum_cht3*/
	FILENAME SLIDE11h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide11_OSD!R1C2:R1C4" NOTAB; /*Y2 Y3 Y4*/
	FILENAME SLIDE11 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide11_OSD!R3C1:R40C6" NOTAB; /*ARNG_cap_OH*/
	FILENAME SLIDE12h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide12_OSD!R1C2:R1C4" NOTAB; /*Y2 Y3 Y4*/
	FILENAME SLIDE12 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide12_OSD!R3C1:R40C6" NOTAB; /*USAR_cap_OH*/
	FILENAME SLIDE14h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide14_GTW!R1C2:R1C4" NOTAB; /*Y2 Y3 Y4*/
	FILENAME SLIDE14 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide14_GTW!R3C1:R40C6" NOTAB; /*ARNG_cap_OH*/
	FILENAME SLIDE15h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide15_GTW!R1C2:R1C4" NOTAB; /*Y2 Y3 Y4*/
	FILENAME SLIDE15 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide15_GTW!R3C1:R40C6" NOTAB; /*USAR_cap_OH*/

	FILENAME SLIDE16h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide16!R1C2:R1C4" NOTAB; /*Y2 Y3 Y4*/
	FILENAME SLIDE16 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide16!R3C1:R40C4" NOTAB; /*ARNG_sht_fill*/
	FILENAME SLIDE17h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide17!R1C2:R1C4" NOTAB; /*Y2 Y3 Y4*/
	FILENAME SLIDE17 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide17!R3C1:R40C4" NOTAB; /*USAR_sht_fill*/

	FILENAME SLIDE18h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide18!R1C2:R1C3" NOTAB; /*Y2 Y3*/
	FILENAME SLIDE18 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide18!R3C1:R40C3" NOTAB; /*Summ_subbed1*/

	FILENAME SLIDE19 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide19!R2C1:R21C6" NOTAB; /*OSD Top_Lin_shortNG2*/
	FILENAME SLIDE20 DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Slide20!R2C1:R21C6" NOTAB; /*OSD Top_Lin_shortUS2*/

	FILENAME PARITY1h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]HIPPO!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY1a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]HIPPO!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY1b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]HIPPO!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY1c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]HIPPO!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	*FILENAME PARITY2h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]JBC-P!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	*FILENAME PARITY2a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]JBC-P!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	*FILENAME PARITY2b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]JBC-P!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	*FILENAME PARITY2c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]JBC-P!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARITY3h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Stryker!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY3a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Stryker!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY3b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Stryker!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY3c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Stryker!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARITY4h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Bradley!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY4a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Bradley!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY4b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Bradley!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY4c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Bradley!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARITY5h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Black Hawk!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY5a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Black Hawk!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY5b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Black Hawk!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY5c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Black Hawk!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARITY6h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Abrams!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY6a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Abrams!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY6b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Abrams!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY6c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Abrams!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARITY7h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Apache!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY7a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Apache!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY7b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Apache!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY7c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Apache!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARITY8h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]M-SHORAD!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY8a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]M-SHORAD!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY8b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]M-SHORAD!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY8c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]M-SHORAD!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARITY9h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]TWPS!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARITY9a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]TWPS!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARITY9b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]TWPS!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARITY9c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]TWPS!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	FILENAME PARIT10h DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Vision!R1C2:R1C3" NOTAB; /*&Y3 &Y7*/
	FILENAME PARIT10a DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Vision!R2C11:R4C29" NOTAB; /*gtw.&Curr_SYS._Parity_CAP*/
	FILENAME PARIT10b DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Vision!R5C11:R5C29" NOTAB; /*gtw.&Curr_SYS._ParityREQ*/
	FILENAME PARIT10c DDE "EXCEL|&FILEDIR.\[%trim(&xlsfile.)]Vision!R6C11:R6C29" NOTAB; /*gtw.&Curr_SYS._ParityEOH*/

	%let FILEh_lst = (PARITY1h /*PARITY2h*/ PARITY3h PARITY4h PARITY5h PARITY6h PARITY7h PARITY8h PARITY9h PARIT10h);
	%let FILEa_lst = (PARITY1a /*PARITY2a*/ PARITY3a PARITY4a PARITY5a PARITY6a PARITY7a PARITY8a PARITY9a PARIT10a);
	%let FILEb_lst = (PARITY1b /*PARITY2b*/ PARITY3b PARITY4b PARITY5b PARITY6b PARITY7b PARITY8b PARITY9b PARIT10b);
	%let FILEc_lst = (PARITY1c /*PARITY2c*/ PARITY3c PARITY4c PARITY5c PARITY6c PARITY7c PARITY8c PARITY9c PARIT10c);

	/*Writes Data for Slides #4  */
	DATA _NULL_; 
	 FILE SLIDE4 DSD dlm='09'x DROPOVER;
	 SET OSD.TA_EOH_mod_cht2 end=EOF;	 	
	 PUT curr_req_cost curr_oh_cost sub_OH_cost below_OH_cost tot_eoh_cost mod_short_cost short_cost;
	run;

	/*Writes Data for Slides #5  */
	DATA _NULL_; 
	 FILE SLIDE5 DSD dlm='09'x DROPOVER;
	 SET GTW.TA_EOH_mod_cht2 end=EOF;	 	
	 PUT curr_req_cost curr_oh_cost sub_OH_cost below_OH_cost tot_eoh_cost mod_short_cost short_cost;
	run;

	/*Writes Data for Slides #6*/
	DATA _NULL_; 
	 FILE SLIDE6 DSD dlm='09'x DROPOVER;
	 SET OSD.TA_EOH_sum_cht2 end=EOF;
	 PUT  curr_req_cost tot_eoh_cost short_cost;
	RUN;

	/*Writes Data for Slides #7*/
	DATA _NULL_; 
	 FILE SLIDE7 DSD dlm='09'x DROPOVER;
	 SET OSD.TA_EOH_sum_cht3 end=EOF;
	 PUT  req OH_cap short per_short;
	RUN;

	/*Writes Data for Slides #8*/
	DATA _NULL_; 
	 FILE SLIDE8 DSD dlm='09'x DROPOVER;
	 SET GTW.TA_EOH_sum_cht2 end=EOF;
	 PUT  curr_req_cost tot_eoh_cost short_cost;
	RUN;

	/*Writes Data for Slides #9*/
	DATA _NULL_; 
	 FILE SLIDE9 DSD dlm='09'x DROPOVER;
	 SET GTW.TA_EOH_sum_cht3 end=EOF;
	 PUT  req OH_cap short per_short;
	RUN;

	/*Writes Data for Slides #11*/
	DATA _NULL_; 
	 FILE SLIDE11h DSD dlm='09'x DROPOVER;
	 PUT "&Y3" '09'x "&Y4" '09'x "&Y5";
	RUN;

	DATA _NULL_; 
	 FILE SLIDE11 DSD dlm='09'x DROPOVER;
	 SET OSD.ARNG_cap_OH end=EOF;
	 PUT major_capability OH_&Y2 OH_&Y3 OH_&Y4 OH_&Y5 REQ_&Y5;
	RUN;

	/*Writes Data for Slides #12 */
	DATA _NULL_; 
	 FILE SLIDE12h DSD dlm='09'x DROPOVER;
	 PUT "&Y3" '09'x "&Y4" '09'x "&Y5";
	RUN;

	DATA _NULL_; 
	 FILE SLIDE12 DSD dlm='09'x DROPOVER;
	 SET OSD.USAR_cap_OH end=EOF;
	 PUT major_capability OH_&Y2 OH_&Y3 OH_&Y4 OH_&Y5 REQ_&Y5;
	run;

	/*Writes Data for Slides #14*/
	DATA _NULL_; 
	 FILE SLIDE14h DSD dlm='09'x DROPOVER;
	 PUT "&Y3" '09'x "&Y4" '09'x "&Y5";
	RUN;

	DATA _NULL_; 
	 FILE SLIDE14 DSD dlm='09'x DROPOVER;
	 SET GTW.ARNG_cap_OH end=EOF;
	 PUT major_capability OH_&Y2 OH_&Y3 OH_&Y4 OH_&Y5 REQ_&Y5;
	RUN;

	/*Writes Data for Slides #15 */
	DATA _NULL_; 
	 FILE SLIDE15h DSD dlm='09'x DROPOVER;
	 PUT "&Y3" '09'x "&Y4" '09'x "&Y5";
	RUN;

	DATA _NULL_; 
	 FILE SLIDE15 DSD dlm='09'x DROPOVER;
	 SET GTW.USAR_cap_OH end=EOF;
	 PUT major_capability OH_&Y2 OH_&Y3 OH_&Y4 OH_&Y5 REQ_&Y5;
	run;

	/*Writes Data for Slide #16 */
	DATA _NULL_; 
	 FILE SLIDE16h DSD dlm='09'x DROPOVER;
	 PUT "&Y3" '09'x "&Y4" '09'x "&Y5";
	RUN;

	DATA _NULL_; 
	 FILE SLIDE16 DSD dlm='09'x DROPOVER;
	 SET OSD.ARNG_sht_fill end=EOF;	 	
	 PUT major_capability EX_&Y3 EX_&Y4 EX_&Y5;
	run;

	/*Writes Data for Slide #17 */
	DATA _NULL_; 
	 FILE SLIDE17h DSD dlm='09'x DROPOVER;
	 PUT "&Y3" '09'x "&Y4" '09'x "&Y5";
	RUN;

	DATA _NULL_; 
	 FILE SLIDE17 DSD dlm='09'x DROPOVER;
	 SET GTW.USAR_sht_fill end=EOF;	 	
	 PUT major_capability EX_&Y3 EX_&Y4 EX_&Y5;
	run;

	/*Writes Data for Slide #18 */
	DATA _NULL_; 
	 FILE SLIDE18h DSD dlm='09'x DROPOVER;
	 PUT "&Y3" '09'x "&Y3";
	RUN;

	DATA _NULL_; 
	 FILE SLIDE18 DSD dlm='09'x DROPOVER;
	 SET GTW.Summ_subbed1 end=EOF;	 	
	 PUT major_capability ARNG USAR;
	run;


	/*Writes Data for Slide #19 */
	DATA _NULL_; 
	 FILE SLIDE19 DSD dlm='09'x DROPOVER;
	 SET OSD.Top_Lin_shortNG2 end=EOF;	 	
	 PUT lin nomenclature major_capability req shortage short_cost;
	run;

	/*Writes Data for Slide #20 */
	DATA _NULL_; 
	 FILE SLIDE20 DSD dlm='09'x DROPOVER;
	 SET OSD.Top_Lin_shortUS2 end=EOF;	 	
	 PUT lin nomenclature major_capability req shortage short_cost;
	run;

/*NOTE (ARIA)AUG 22: Changed j 1 to 8 to j 1 -7 (we have 7 systems. changed Y3 to Y2, parity timeframe is NGRER inital FY-1. example NGRER 24-28, PARITY 23-28*/
	%macro write_parity_tbl();
/*        %let PARITYSYS_lst = (HIPPO ABrams )*/
		%do j = 1 %to 9;
		  	%let Curr_SYS = %scan(&PARITYSYS_lst, &j);
			%put &&&Curr_SYS._lst;
			%let Curr_h = %scan(&FILEh_lst, &j);
			%let Curr_a = %scan(&FILEa_lst, &j); /**parity final cap**/
			%let Curr_b = %scan(&FILEb_lst, &j); /*** parity req ***/
			%let Curr_c = %scan(&FILEc_lst, &j); /*** parity eoh perc**/

			DATA _NULL_; 
			   FILE &Curr_h DSD dlm='09'x DROPOVER;
			   PUT "&Y2" '09'x "&Y7";
			RUN;

/*			DATA _NULL_; */
/*			   FILE &Curr_h DSD dlm='09'x DROPOVER;*/
/*			   PUT "&Y2" '09'x "&Y7";*/
/*			RUN;*/

			DATA _NULL_; 
			   FILE &Curr_a DSD dlm='09'x DROPOVER;
/*			   SET gtw.&Curr_SYS._Parity_CAP end=EOF;	 	*/
			   SET gtw.&Curr_SYS._Parity_Final end=EOF;	 	
			   PUT SysName AC&Y2 '09'x '09'x AC&Y7 '09'x '09'x ARNG&Y2 '09'x '09'x ARNG&Y7  '09'x '09'x USAR&Y2 '09'x '09'x USAR&Y7;
			run;

			DATA _NULL_; 
			   FILE &Curr_b DSD dlm='09'x DROPOVER;
			   SET gtw.&Curr_SYS._ParityREQ end=EOF;	 	
			   PUT SysName '09'x  AC&Y2 '09'x '09'x AC&Y7 '09'x '09'x ARNG&Y2 '09'x '09'x ARNG&Y7  '09'x '09'x USAR&Y2 '09'x '09'x USAR&Y7;
			run;

			DATA _NULL_; 
			   FILE &Curr_c DSD dlm='09'x DROPOVER;
			   SET gtw.&Curr_SYS._ParityEOH end=EOF;	 	
			   PUT SysName '09'x AC&Y2 '09'x '09'x AC&Y7 '09'x '09'x ARNG&Y2 '09'x '09'x ARNG&Y7  '09'x '09'x USAR&Y2 '09'x '09'x USAR&Y7;
			run;
		%end;
	%mend;
	%write_parity_tbl;

	DATA _NULL_;
		rc=SLEEP(5);
	RUN;

	FILENAME HH DDE 'EXCEL|SYSTEM';
	DATA _NULL_;
		FILE HH;
/*		PUT "[save.AS(""&Deliverables_Path.\&current_cycle._NGRER_Report_Tables_Charts_&xdate..xlsb"")]";*/
		PUT "[save.AS(""&Deliverables_Path.\&current_cycle._NGRER_Report_Tables_Charts_&xdate..xlsb"")]";
		*PUT '[RUN("AdjustVerticalAxis")]';
/*		PUT '[RUN("PasteCharts_Tables")]';*/

		PUT '[QUIT()]';
	RUN;

	FILENAME HH clear;

%mend;
%outdata2;


proc export 
  data=osd.taedp_erc1
  dbms=xlsx
  outfile="&Deliverables_Path.\&current_cycle._NGRER_Report_Tables_Charts_&xdate..xlsb"
  replace;
  sheet="OSD_Data";
run;

proc export 
  data=gtw.taedp_erc1
  dbms=xlsx
  outfile="&Deliverables_Path.\&current_cycle._NGRER_Report_Tables_Charts_&xdate..xlsb"
  replace;
  sheet="GTW_Data";
run;



file name: NGRER_Summary_reports.sas

OPTIONS CVPMULTIPLIER=3;
/*%let current_cycle = FY25;*/
%let STUDY_PATH =			O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25;
/*%let xdate = 12AUG2025;*/
/*%let xdate2 = 01SEP2021;*/

%let GTW_PATH =		O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\GTW\28AUG2025__SUBS\OPT_Output;
%let OSD_PATH =		O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\OSD\27AUG2025__NOSUBS\OPT_Output;


libname GTW "&GTW_PATH";
libname OSD "&OSD_PATH";

%let Data_Input_Path = 	O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\Input;
/*libname LMDB "&Data_Input_Path";*/
/*%let lmdb_month = AUG2021v4;*/


data _null_;
	if month(today()) < 10 then call symput('min_date',year(today()));
	else call symput('min_date',year(today()) +1);
run; 

%let current_fy = &min_date;
%let LastPOM_YR = %eval(&min_date + 6);
%let FirstPOM_YR = %eval(&min_date + 2);
%let Previous_YR=%eval(&min_date -1);

%put &FirstPOM_YR;
%put &LastPOM_YR;
%put &current_fy;

%LET Y1 = &current_fy;
%LET Y2 = %eval(&current_fy + 1);
%LET Y3 = %eval(&current_fy + 2);
%LET Y4 = %eval(&current_fy + 3);
%LET Y5 = %eval(&current_fy + 4);
%LET Y6 = %eval(&current_fy + 5);
%LET Y7 = %eval(&current_fy + 6);

%let HIPPO_lst = ('T32629');
*%let JBC_lst = ('C05036', 'C05037', 'C05054', 'C05055', 'C13866', 'C18278','C18378', 'C78851');
%let STRYKER_lst = ('A05037','C05052','E05010','J05009','M05032','M05033','A83852','C41314','F86821','J22626','J97621','M30567','M53369','M57720','N96543','R62673','J05041','C05121','M05070','E05025','A05073','M05069','Z06011','F05022','F05013');
%let Bradley_lst = ('P19727','F60564','C76335','F40307','F40375','F60530','F90796','J81750','P19795','M05073','M05072','F86571','A40164','P19727','A70576');
%let BlackHawk_lst = ('H32361', 'H32429', 'K32293', 'M33458', 'M85588', 'H05016');
%let Abrams_lst = ('A05071', 'T13305');
%let Apache_lst = ('H05006', 'H48918','Z06120');
%let M_SHORAD_lst = ('Z05827');
%let TWPS_lst = ('Z06014');
%let Vision_lst = ('E05036','N05013');
%let PARITY_lst = ("&HIPPO_lst.", "&STRYKER_lst.", "&Bradley_lst.", "&BlackHawk_lst.", "&Abrams_lst.", "&Apache_lst.", "&M_SHORAD_lst.", "&TWPS_lst.", "&Vision_lst.");
%let PARITYSYS_lst = (HIPPO STRYKER Bradley BlackHawk Abrams Apache M_SHORAD TWPS Vision);
%let PARITYSYS_lst2 = (HIPPO STRYKER Bradley BlackHawk Abrams Apache M_SHORAD TWPS Vision);
%let field_lst = (AC&Y2 AC&Y7 ARNG&Y2 ARNG&Y7 USAR&Y2 USAR&Y7); 


PROC IMPORT OUT= lmdb_month
    DATAFILE= "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\AE2S_LIN_DETAILS_2025-08-11.xlsx" 
    DBMS=xlsx REPLACE;
	Sheet= "AE2S_LIN_DETAILS";
    GETNAMES=YES;
    DATAROW=2; 
RUN;

/*** Go To War EOH Comparison *****/
/***************Slide 9 *********/
/*proc summary data=gtw.add_ml_to_inv nway missing;*/
/*where modeling_dates=&Y1 and compos ne '';*/
/*class compos;*/
/*var reqd onhand shortages;*/
/*output out=gtw.EOH_method (drop=_type_ _freq_)sum=;*/
/*run;*/

/*** Go To War EOH Comparison cost *****/


	data gtw.SYSMOD_List;
	   infile datalines; 
	   input SysName $;
	   datalines;                      
		(MOD3)
		(MOD4)
		(MOD5)
		;
	run;

	proc sql;
		create table OSD.TA_EOH_MOD as
		select distinct
			year,
			compo,
			lin,
			max(current_puc) as current_puc,
			sum(req) as req,
			sum(roh) as roh,
			sum(shortage) as short,
			0 as below_mod
		from OSD.taedp_erc1
		where year=&Y3 and compo ne '6' and req>0
		group by compo, lin;
	quit; 

proc sql;
		create table GTW.TA_EOH_MOD as
		select distinct
			year,
			compo,
			lin,
			max(current_puc) as current_puc,
			sum(req) as req,
			sum(roh) as roh,
			sum(total_subbed) as sub,
			sum(shortage) as short,
			0 as below_mod
		from gtw.taedp_erc1
		where year=&Y3 and compo ne '6' and req>0
		group by compo, lin;
	quit;


	data OSD.TA_EOH_mod_cht(drop=current_puc req sub roh short below_mod);
		format curr_req_cost curr_oh_cost sub_OH_cost below_OH_cost DOLLAR21.2;
		set OSD.TA_EOH_MOD;

		curr_req_cost=current_puc*req;
		curr_oh_cost=current_puc*roh;
		sub_OH_cost=current_puc*sub;
		below_OH_cost=current_puc*below_mod;
		mod_short_cost=curr_req_cost - curr_oh_cost;
		short_cost = mod_short_cost;
	run;

data GTW.TA_EOH_mod_cht(drop=current_puc req sub roh short below_mod);
		format curr_req_cost curr_oh_cost sub_OH_cost below_OH_cost DOLLAR21.2;
		 set GTW.TA_EOH_MOD;

		curr_req_cost=current_puc*req;
		curr_oh_cost=current_puc*roh;
		sub_OH_cost=current_puc*sub;
		below_OH_cost=current_puc*below_mod;
		mod_short_cost=curr_req_cost-curr_oh_cost;
		short_cost=curr_req_cost-curr_oh_cost-sub_OH_cost;
	run;

/***************Slide 4/5 *********/
	proc sql;
		create table OSD.TA_EOH_mod_cht2 as
		select distinct
			compo,
			sum(curr_req_cost) as curr_req_cost,
			sum(curr_oh_cost) as curr_oh_cost,
			0 as sub_OH_cost,
			0 as below_OH_cost,
			(calculated curr_oh_cost) as tot_eoh_cost, 
			sum(mod_short_cost) as mod_short_cost,
			sum(short_cost) as short_cost
			
		from OSD.TA_EOH_mod_cht
		
		group by compo
		order by compo;
	quit; 

	proc sql;
		create table GTW.TA_EOH_mod_cht2 as
		select distinct
			compo,
			sum(curr_req_cost) as curr_req_cost,
			sum(curr_oh_cost) as curr_oh_cost,
			sum(sub_OH_cost) as sub_OH_cost,
			sum(below_OH_cost) as below_OH_cost,
			(calculated curr_oh_cost + calculated sub_OH_cost) as tot_eoh_cost, 
			sum(mod_short_cost) as mod_short_cost,
			sum(short_cost) as short_cost
			
		from GTW.TA_EOH_mod_cht
		
		group by compo
		order by compo;
	quit; 

/***************Slides 6/8 *********/
data OSD.TA_EOH_sum_cht2(keep=compo curr_req_cost tot_eoh_cost short_cost per_short);
  FORMAT per_short PERCENT7.1;
  set OSD.TA_EOH_mod_cht2;
  per_short = short_cost / curr_req_cost;
run; 

data GTW.TA_EOH_sum_cht2(keep=compo curr_req_cost tot_eoh_cost short_cost per_short);
  FORMAT per_short PERCENT7.1;
  set GTW.TA_EOH_mod_cht2;
  per_short = short_cost / curr_req_cost;
run; 


/***************Slides 7/9 *********/
	proc sql;
		create table OSD.TA_EOH_MOD2 as
		select distinct
			compo,
			sum(req) as req,
			sum(roh) as roh,
			(calculated roh) as OH_Cap
		from OSD.TA_EOH_MOD
		where year=&Y3 and compo ne '6' and req>0
		group by compo;
	quit; 


	proc sql;
		create table GTW.TA_EOH_MOD2 as
		select distinct
			compo,
			sum(req) as req,
			sum(roh) as roh,
			sum(sub) as sub,
			(calculated roh + calculated sub) as OH_Cap
		from GTW.TA_EOH_MOD
		where year=&Y3 and compo ne '6' and req>0
		group by compo;
	quit; 

data OSD.TA_EOH_sum_cht3(keep=compo req OH_Cap short per_short);
  FORMAT per_short PERCENT7.1;
  set OSD.TA_EOH_MOD2;
  short = req - OH_Cap;
  per_short = short / req;
run; 

data GTW.TA_EOH_sum_cht3(keep=compo req OH_Cap short per_short);
  FORMAT per_short PERCENT7.1;
  set GTW.TA_EOH_MOD2;
  short = req - OH_Cap;
  per_short = short / req;
run; 

/***************Slide 11/14 *********/
/*Remember this is a FORECAST so the beginning of the Second POM Year is the SAME as the END of the FIRST POM Year ie.  BeginningFY22 = Ending FY21 */

proc summary data=OSD.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y2,&Y3,&Y4,&Y5) and compo_cat='ARNG';
class major_capability year;
var total_OH;
output out=OSD.ARNG_maj_cap (drop=_type_ _freq_)sum=;
run;

proc summary data=OSD.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y5) and compo_cat='ARNG';
class major_capability year;
var req;
output out=OSD.ARNG_maj_cap_req (drop=_type_ _freq_)sum=;
run;

proc transpose data = OSD.ARNG_maj_cap_req out = OSD.ARNG_maj_cap_req1(rename=(COL1=REQ_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var req;
run;

proc transpose data = OSD.ARNG_maj_cap out = OSD.ARNG_maj_cap1(rename=(COL1=OH_&Y2 COL2=OH_&Y3 COL3=OH_&Y4 COL4=OH_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var total_OH;
run;

data OSD.ARNG_cap_OH;
  merge OSD.ARNG_maj_cap1 (in=a)
        OSD.ARNG_maj_cap_req1 (in=b);
		by major_capability;
run;
        


/*Remember this is a FORECAST so the beginning of the Second POM Year is the SAME as the END of the FIRST POM Year ie.  BeginningFY22 = Ending FY21 */

proc summary data=GTW.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y2,&Y3,&Y4,&Y5) and compo_cat='ARNG';
class major_capability year;
var total_OH;
output out=GTW.ARNG_maj_cap (drop=_type_ _freq_)sum=;
run;

proc summary data=GTW.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y5) and compo_cat='ARNG';
class major_capability year;
var req;
output out=GTW.ARNG_maj_cap_req (drop=_type_ _freq_)sum=;
run;

proc transpose data = GTW.ARNG_maj_cap_req out = GTW.ARNG_maj_cap_req1(rename=(COL1=REQ_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var req;
run;

proc transpose data = GTW.ARNG_maj_cap out = GTW.ARNG_maj_cap1(rename=(COL1=OH_&Y2 COL2=OH_&Y3 COL3=OH_&Y4 COL4=OH_&Y5) drop=_NAME_)/* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var total_OH;
run;

data GTW.ARNG_cap_OH;
  merge GTW.ARNG_maj_cap1 (in=a)
        GTW.ARNG_maj_cap_req1 (in=b);
		by major_capability;
run;
        


/***************Slide 12/15 *********/
/*Remember this is a FORECAST so the beginning of the Second POM Year is the SAME as the END of the FIRST POM Year ie.  BeginningFY22 = Ending FY21 */

proc summary data=OSD.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y2,&Y3,&Y4,&Y5) and compo_cat='USAR';
class major_capability year;
var total_OH;
output out=OSD.USAR_maj_cap (drop=_type_ _freq_)sum=;
run;


proc summary data=OSD.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y5) and compo_cat='USAR';
class major_capability year;
var req;
output out=OSD.USAR_maj_cap_req (drop=_type_ _freq_)sum=;
run;

proc transpose data = OSD.USAR_maj_cap_req out = OSD.USAR_maj_cap_req1(rename=(COL1=REQ_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var req;
run;

proc transpose data = OSD.USAR_maj_cap out = OSD.USAR_maj_cap1(rename=(COL1=OH_&Y2 COL2=OH_&Y3 COL3=OH_&Y4 COL4=OH_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var total_OH;
run;

data OSD.USAR_cap_OH;
  merge OSD.USAR_maj_cap1 (in=a)
        OSD.USAR_maj_cap_req1 (in=b);
		by major_capability;
run;



proc summary data=GTW.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y2,&Y3,&Y4,&Y5) and compo_cat='USAR';
class major_capability year;
var total_OH;
output out=GTW.USAR_maj_cap (drop=_type_ _freq_)sum=;
run;


proc summary data=GTW.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y5) and compo_cat='USAR';
class major_capability year;
var req;
output out=GTW.USAR_maj_cap_req (drop=_type_ _freq_)sum=;
run;

proc transpose data = GTW.USAR_maj_cap_req out = GTW.USAR_maj_cap_req1(rename=(COL1=REQ_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var req;
run;

proc transpose data = GTW.USAR_maj_cap out = GTW.USAR_maj_cap1(rename=(COL1=OH_&Y2 COL2=OH_&Y3 COL3=OH_&Y4 COL4=OH_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var total_OH;
run;

data GTW.USAR_cap_OH;
  merge GTW.USAR_maj_cap1 (in=a)
        GTW.USAR_maj_cap_req1 (in=b);
		by major_capability;
run;


/***************Slide 16  *********/
/***** Major capability Excess  *****/
proc summary data=OSD.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y3,&Y4,&Y5) and compo_cat='AC';
class major_capability year;
var excess;
output out=OSD.AC_MC_exc (drop=_type_ _freq_)sum=;
run;

proc summary data=OSD.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y3,&Y4,&Y5) and compo_cat='ARNG';
class major_capability year;
var shortage;
output out=OSD.ARNG_MC_sht (drop=_type_ _freq_)sum=;
run;

proc transpose data = OSD.AC_MC_exc out = OSD.AC_MC_exc1(rename=(COL1=EX_&Y3 COL2=EX_&Y4 COL3=EX_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var excess;
run;

proc transpose data = OSD.ARNG_MC_sht out = OSD.ARNG_MC_sht1(rename=(COL1=EX_&Y3 COL2=EX_&Y4 COL3=EX_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var shortage;
run;


proc sql;
   create table OSD.ARNG_sht_fill as
     select
	   a.major_capability,
	   MIN(a.EX_&Y3, b.EX_&Y3) as EX_&Y3,
	   MIN(a.EX_&Y4, b.EX_&Y4) as EX_&Y4,
	   MIN(a.EX_&Y5, b.EX_&Y5) as EX_&Y5
	from OSD.ARNG_MC_sht1 as a
	left join OSD.AC_MC_exc1 as b on a.major_capability=b.major_capability
	order by a.major_capability;
quit;


/***************Slide 17 *********/
/**** Major Capability Substitutes  *****/
proc summary data=GTW.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y3,&Y4,&Y5) and compo_cat='AC';
class major_capability year;
var excess;
output out=GTW.AC_MC_exc (drop=_type_ _freq_)sum=;
run;

proc transpose data = GTW.AC_MC_exc out = GTW.AC_MC_exc1(rename=(COL1=EX_&Y3 COL2=EX_&Y4 COL3=EX_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var excess;
run;


proc summary data=GTW.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y3,&Y4,&Y5) and compo_cat='USAR';
class major_capability year;
var shortage;
output out=GTW.USAR_MC_sht (drop=_type_ _freq_)sum=;
run;

proc transpose data = GTW.USAR_MC_sht out = GTW.USAR_MC_sht1(rename=(COL1=EX_&Y3 COL2=EX_&Y4 COL3=EX_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by major_capability;
/*	id value;*/
	var shortage;
run;

proc sql;
   create table GTW.USAR_sht_fill as
     select
	   a.major_capability,
	   MIN(a.EX_&Y3, b.EX_&Y3) as EX_&Y3,
	   MIN(a.EX_&Y4, b.EX_&Y4) as EX_&Y4,
	   MIN(a.EX_&Y5, b.EX_&Y5) as EX_&Y5
	from GTW.USAR_MC_sht1 as a
	left join GTW.AC_MC_exc1 as b on a.major_capability=b.major_capability
	order by a.major_capability;
quit;
/***************Slide 18 *********/
proc summary data=GTW.taedp_erc1 nway missing;
where major_capability ne  '' and year in (&Y3) and compo_cat in ('ARNG','USAR');
class major_capability compo_cat;
var total_subbed;
output out=GTW.Summ_subbed (drop=_type_ _freq_)sum=;
run;


proc transpose data = GTW.Summ_subbed out = GTW.Summ_subbed1/*(rename=(COL1=EX_&Y2 COL2=EX_&Y3 COL3=EX_&Y4) drop=_NAME_) /* _LABEL_=FY*/ (drop=_NAME_) ;
	by major_capability;
	id compo_cat;
	var total_subbed;
run;


*** Top 20 LIN Shortages ******;
proc sql;
	create table OSD.Top_Lin_short_NG as
	select distinct
		lin,
		nomenclature,
		major_capability,
		sum(req) as req,
		max(current_puc) as current_puc,
		sum(shortage) as shortage
		from OSD.taedp_erc1
	where year=&Y2 and compo_cat ='ARNG' and req>0 
	group by lin, nomenclature, major_capability;
quit; 

data OSD.Top_Lin_shortNG1(drop=current_puc);
format short_cost DOLLAR21.2;
ATTRIB lin nomenclature major_capability req shortage short_cost label=' ';
 set OSD.Top_Lin_short_NG;

short_cost=current_puc*shortage;
run;


/***************Slide 19 *********/*/;
proc sort data=OSD.Top_Lin_shortNG1 out=OSD.Top_Lin_shortNG2;  by descending short_cost; run;

data OSD.Top_Lin_shortNG2;
  set OSD.Top_Lin_shortNG2;
  IF _N_ LE 20;
run;


proc sql;
	create table OSD.Top_Lin_short_US as
	select distinct
		lin,
		nomenclature,
		major_capability,
		sum(req) as req,
		max(current_puc) as current_puc,
		sum(shortage) as shortage
		from OSD.taedp_erc1
	where year=&Y2 and compo_cat ='USAR' and req>0 
	group by lin, nomenclature, major_capability;
quit; 

data OSD.Top_Lin_shortUS1(drop=current_puc);
format short_cost DOLLAR21.2;
ATTRIB lin nomenclature major_capability req shortage short_cost label=' ';
 set OSD.Top_Lin_short_US;

short_cost=current_puc*shortage;
run;

/***************Slide 20 *********/*/;
proc sort data=OSD.Top_Lin_shortUS1 out=OSD.Top_Lin_shortUS2;  by descending short_cost; run;

data OSD.Top_Lin_shortUS2;
  set OSD.Top_Lin_shortUS2;
  IF _N_ LE 20;
run;


/******************** Add Top LIN Shortage for GTW  per Aria **************************************/
*** Top 20 LIN Shortages ******;
proc sql;
	create table GTW.Top_Lin_short_NG as
	select distinct
		lin,
		nomenclature,
		major_capability,
		sum(req) as req,
		max(current_puc) as current_puc,
		sum(shortage) as shortage
		from GTW.taedp_erc1
	where year=&Y2 and compo_cat ='ARNG' and req>0 
	group by lin, nomenclature, major_capability;
quit; 

data GTW.Top_Lin_shortNG1(drop=current_puc);
format short_cost DOLLAR21.2;
ATTRIB lin nomenclature major_capability req shortage short_cost label=' ';
 set GTW.Top_Lin_short_NG;

short_cost=current_puc*shortage;
run;


/***************Slide 21 *********/*/;
proc sort data=GTW.Top_Lin_shortNG1 out=GTW.Top_Lin_shortNG2;  by descending short_cost; run;

data GTW.Top_Lin_shortNG2;
  set GTW.Top_Lin_shortNG2;
  IF _N_ LE 20;
run;


proc sql;
	create table GTW.Top_Lin_short_US as
	select distinct
		lin,
		nomenclature,
		major_capability,
		sum(req) as req,
		max(current_puc) as current_puc,
		sum(shortage) as shortage
		from GTW.taedp_erc1
	where year=&Y2 and compo_cat ='USAR' and req>0 
	group by lin, nomenclature, major_capability;
quit; 

data GTW.Top_Lin_shortUS1(drop=current_puc);
format short_cost DOLLAR21.2;
ATTRIB lin nomenclature major_capability req shortage short_cost label=' ';
 set GTW.Top_Lin_short_US;

short_cost=current_puc*shortage;
run;

/***************Slide 22 *********/*/;
proc sort data=GTW.Top_Lin_shortUS1 out=GTW.Top_Lin_shortUS2;  by descending short_cost; run;

data GTW.Top_Lin_shortUS2;
  set GTW.Top_Lin_shortUS2;
  IF _N_ LE 20;
run;



/*proc summary data=OSD.taedp_fix nway missing;*/
/*where major_capability ne  '' and year in (&FirstPOM_YR) and compo_cat='ARNG';*/
/*class lin nomenclature major_capability;*/
/*var req shortage;*/
/*output out=OSD.ARNG_MC_top_sht (drop=_type_ _freq_)sum=;*/
/*run;*/
*/;

%macro create_parity_tbls();

	PROC IMPORT OUT= gtw.LIN_SysName
	    DATAFILE= "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\LIN_SysName.xlsx" 
	    DBMS=xlsx REPLACE;
		Sheet= "Sheet1";
	    GETNAMES=YES;
	    DATAROW=2; 
	RUN;


	%do j = 1 %to 9;
	  	%let Curr_SYS = %upcase(%scan(&PARITYSYS_lst, &j));
		%put &&&Curr_SYS._lst;

		proc summary data=GTW.taedp_erc1 nway missing;
		where LIN in &&&Curr_SYS._lst and year in (&Y2,&Y7) and compo_cat in ('AC', 'ARNG','USAR');
		class LIN NOMENCLATURE COMPO_CAT year;
		var REQ;
		output out=GTW.&Curr_SYS._REQ (drop=_type_ _freq_)sum=;
		run;

		proc transpose data = GTW.&Curr_SYS._REQ out = GTW.&Curr_SYS._REQxtab (drop=_NAME_) ;
			by LIN NOMENCLATURE;
			id COMPO_CAT year;
			var REQ;
		run;

		proc summary data=GTW.taedp_erc1 nway missing;
		where LIN in &&&Curr_SYS._lst and year in (&Y2,&Y7) and compo_cat in ('AC', 'ARNG','USAR') and ERC NE 'X';
		class LIN NOMENCLATURE COMPO_CAT year;
		var ROH;
		output out=GTW.&Curr_SYS._ROH (drop=_type_ _freq_)sum=;
		run;

		proc transpose data = GTW.&Curr_SYS._ROH out = GTW.&Curr_SYS._ROHxtab (drop=_NAME_) ;
			by LIN NOMENCLATURE;
			id COMPO_CAT year;
			var ROH;
		run;

		proc summary data=GTW.subbed nway missing;
		where SUBLINS in &&&Curr_SYS._lst and modeling_dates in (&Y2,&Y7) AND compos in ('1','2','3');
		class SUBLINS COMPOS modeling_dates;
		var SUB_ASSIGN;
		output out=GTW.&Curr_SYS._SUB(drop=_type_ _freq_)sum=;
		run;

		data GTW.&Curr_SYS._SUB2;
		  LENGTH COMPO_CAT $4.;
		  set GTW.&Curr_SYS._SUB;
		  IF COMPOS = '1' THEN COMPO_CAT = 'AC';
		  ELSE IF COMPOS = '2' THEN COMPO_CAT = 'ARNG';
		  ELSE IF COMPOS = '3' THEN COMPO_CAT = 'USAR';
		  ELSE COMPO_CAT = '';
		  drop COMPOS;
		run;

		proc transpose data = GTW.&Curr_SYS._SUB2 out = GTW.&Curr_SYS._SUBxtab (drop=_NAME_) ;
			by SUBLINS;
			id COMPO_CAT modeling_dates;
			var SUB_ASSIGN;
		run;

		data GTW.&Curr_SYS._SUBxtab;
		  set GTW.&Curr_SYS._SUBxtab;
		  rename SUBLINS=LIN;
		run;


		proc sql;
		  create table gtw.&Curr_SYS._ParityA as
		    select distinct
			 A.LIN,
			 A.NOMENCLATURE,
			 0 AS AC&Y2, 
			 0 AS AC&Y7, 
			 0 AS ARNG&Y2, 
			 0 AS ARNG&Y7, 
			 0 AS USAR&Y2, 
			 0 AS USAR&Y7
		    from GTW.Taedp_erc1 as A 
			WHERE LIN in &&&Curr_SYS._lst;
		quit; 

		%macro field_exists(library, dataset, field);
			proc sql noprint;
			     select count(*) into :exists from dictionary.columns
			         where upcase(libname)="&library" and upcase(memname)="&dataset"
			         and upcase(name)="&field";
			quit;

/*			%put &field in &dataset:  &exists;*/
			
			data &library..&dataset;
				set &library..&dataset;
				%if not &exists %then &field = 0;;
			run;
		%mend;

		%do k = 1 %to 10;
		  	%let Curr_field = %scan(&field_lst, &k);
			%field_exists(GTW, &Curr_SYS._ROHXTAB, &Curr_field); 
			%field_exists(GTW, &Curr_SYS._SUBXTAB, &Curr_field);
			%field_exists(GTW, &Curr_SYS._REQXTAB, &Curr_field);
		%end; 

		proc sql;
		  create table gtw.&Curr_SYS._ParityB as 
		    select
			 A.LIN,
			 A.NOMENCLATURE,
			 SUM(A.AC&Y2., B.AC&Y2., C.AC&Y2.) AS AC&Y2., 
			 SUM(A.AC&Y7., B.AC&Y7., C.AC&Y7.) AS AC&Y7., 
			 SUM(A.ARNG&Y2., B.ARNG&Y2., C.ARNG&Y2.) AS ARNG&Y2., 
			 SUM(A.ARNG&Y7., B.ARNG&Y7., C.ARNG&Y7.) AS ARNG&Y7.,
			 SUM(A.USAR&Y2., B.USAR&Y2., C.USAR&Y2.) AS USAR&Y2., 
			 SUM(A.USAR&Y7., B.USAR&Y7., C.USAR&Y7.) AS USAR&Y7.
		    from gtw.&Curr_SYS._ParityA as A 
			left join GTW.&Curr_SYS._ROHxtab as b on a.LIN=b.LIN
			left join GTW.&Curr_SYS._SUBxtab as c on a.LIN=c.LIN;
		quit; 

		proc sql;
		  create table gtw.&Curr_SYS._REQXTABML as 
		    select
			 A.*,
			 B.MOD_LEVEL,
			 C.SysName
		    from gtw.&Curr_SYS._REQXTAB as A 
			left join lmdb_month as b on a.LIN=b.LIN
			left join gtw.LIN_SysName as c on a.LIN=c.LIN;
		quit; 

		proc sql;
		  create table gtw.&Curr_SYS._ParityC as 
		    select
			 A.*,
			 B.MOD_LEVEL,
			 C.SysName
		    from gtw.&Curr_SYS._ParityB as A 
			left join lmdb_month as b on a.LIN=b.LIN
			left join gtw.LIN_SysName as c on a.LIN=c.LIN
			order by B.MOD_LEVEL, C.SysName;
		quit; 

		proc sql;
		  create table gtw.&Curr_SYS._ParityD as 
		    select
			 A.SysName,
			 SUM(A.AC&Y2.) AS AC&Y2., 
			 SUM(A.AC&Y7.) AS AC&Y7., 
			 SUM(A.ARNG&Y2.) AS ARNG&Y2., 
			 SUM(A.ARNG&Y7.) AS ARNG&Y7.,
			 SUM(A.USAR&Y2.) AS USAR&Y2., 
			 SUM(A.USAR&Y7.) AS USAR&Y7.
		    from gtw.&Curr_SYS._ParityC as A 
			group by A.SysName
			order by A.SysName;
		quit; 

/*		data gtw.&Curr_SYS._ParityD;*/
/*			set gtw.&Curr_SYS._ParityD;*/
/*			SysName = catt("&Curr_SYS."," (MOD",MOD_LEVEL,")");*/
/*		run;*/

		data gtw.&Curr_SYS._Parity_Final;
		    retain SysName;
			set gtw.&Curr_SYS._ParityD;
/*			drop MOD_LEVEL;*/
		run;

/*		%let SysName3 = &Curr_SYS. (MOD 3);*/
/*		%let SysName4 = &Curr_SYS. (MOD 4);*/
/*		%let SysName5 = &Curr_SYS. (MOD 5);*/


		data gtw.&Curr_SYS._List;
			set gtw.SYSMOD_List;
			SysName = &Curr_SYS || " " || SysName;
		run;


		proc sql;
		  create table gtw.&Curr_SYS._REQXTABML2 as 
		    select
			 A.SysName,
			 SUM(A.AC&Y2.) AS AC&Y2., 
			 SUM(A.AC&Y7.) AS AC&Y7., 
			 SUM(A.ARNG&Y2.) AS ARNG&Y2., 
			 SUM(A.ARNG&Y7.) AS ARNG&Y7.,
			 SUM(A.USAR&Y2.) AS USAR&Y2., 
			 SUM(A.USAR&Y7.) AS USAR&Y7.
		    from gtw.&Curr_SYS._REQXTABML as A 
			group by A.SysName
			order by A.SysName;
		quit; 

/*		data gtw.&Curr_SYS._REQXTABML2;*/
/*			set gtw.&Curr_SYS._REQXTABML2;*/
/*			SysName = catt("&Curr_SYS."," (MOD",MOD_LEVEL,")");*/
/*		run;*/

		data gtw.&Curr_SYS._REQ_Final;
		    retain SysName;
			set gtw.&Curr_SYS._REQXTABML2;
/*			drop MOD_LEVEL;*/
		run;

		proc sql;
		  create table gtw.&Curr_SYS._Parity_CAP as 
		    select
			 A.SysName,
			 MIN(A.AC&Y2., B.AC&Y2.) AS AC&Y2., 
			 MIN(A.AC&Y7., B.AC&Y7.) AS AC&Y7., 
			 MIN(A.ARNG&Y2., B.ARNG&Y2.) AS ARNG&Y2., 
			 MIN(A.ARNG&Y7., B.ARNG&Y7.) AS ARNG&Y7.,
			 MIN(A.USAR&Y2., B.USAR&Y2.) AS USAR&Y2., 
			 MIN(A.USAR&Y7., B.USAR&Y7.) AS USAR&Y7.
		    from gtw.&Curr_SYS._Parity_Final as A
			left join gtw.&Curr_SYS._REQ_Final as B on A.SysName = B.SysName
			group by A.SysName
			order by A.SysName;
		quit; 

/*		proc sql;*/
/*		  create table gtw.&Curr_SYS._Parity_CAP2 as */
/*		    select*/
/*			 B.SysName,*/
/*			 A.SysName as CAPSys,*/
/*			 A.**/
/*		    from gtw.&Curr_SYS._Parity_CAP as A*/
/*			full outer join gtw.&Curr_SYS._List as B on A.SysName = B.SysName*/
/*			group by A.SysName*/
/*			order by A.SysName;*/
/*		quit; */



	    proc sql;
		  create table gtw.&Curr_SYS._ParityTOT as 
		    select
			 "OH" As SysName,
			 SUM(A.AC&Y2.) AS AC&Y2., 
			 SUM(A.AC&Y7.) AS AC&Y7., 
			 SUM(A.ARNG&Y2.) AS ARNG&Y2., 
			 SUM(A.ARNG&Y7.) AS ARNG&Y7.,
			 SUM(A.USAR&Y2.) AS USAR&Y2., 
			 SUM(A.USAR&Y7.) AS USAR&Y7.
/*		    from gtw.&Curr_SYS._Parity_CAP as A;*/
		    from gtw.&Curr_SYS._Parity_Final as A;
		quit; 

		proc sql;
		  create table gtw.&Curr_SYS._ParityREQ as 
		    select
			 "Requirement" As SysName,
			 SUM(A.AC&Y2.) AS AC&Y2., 
			 SUM(A.AC&Y7.) AS AC&Y7., 
			 SUM(A.ARNG&Y2.) AS ARNG&Y2., 
			 SUM(A.ARNG&Y7.) AS ARNG&Y7.,
			 SUM(A.USAR&Y2.) AS USAR&Y2., 
			 SUM(A.USAR&Y7.) AS USAR&Y7.
		    from gtw.&Curr_SYS._REQ_Final as A;
		quit; 

		proc sql;
		  create table gtw.&Curr_SYS._ParityCAP as 
		    select
			 "Capped" As SysName,
			 MIN(A.AC&Y2., B.AC&Y2.) AS AC&Y2., 
			 MIN(A.AC&Y7., B.AC&Y7.) AS AC&Y7., 
			 MIN(A.ARNG&Y2., B.ARNG&Y2.) AS ARNG&Y2., 
			 MIN(A.ARNG&Y7., B.ARNG&Y7.) AS ARNG&Y7.,
			 MIN(A.USAR&Y2., B.USAR&Y2.) AS USAR&Y2., 
			 MIN(A.USAR&Y7., B.USAR&Y7.) AS USAR&Y7.
		    from gtw.&Curr_SYS._ParityTOT as A
			left join gtw.&Curr_SYS._ParityREQ as B on A.SysName NE B.SysName;
		quit; 


		proc sql;
		  create table gtw.&Curr_SYS._ParityEOH as 
		    select
			 "EOH" As SysName,
			 (A.AC&Y2./B.AC&Y2.) AS AC&Y2., 
			 (A.AC&Y7./B.AC&Y7.) AS AC&Y7., 
			 (A.ARNG&Y2./B.ARNG&Y2.) AS ARNG&Y2., 
			 (A.ARNG&Y7./B.ARNG&Y7.) AS ARNG&Y7.,
			 (A.USAR&Y2./B.USAR&Y2.) AS USAR&Y2., 
			 (A.USAR&Y7./B.USAR&Y7.) AS USAR&Y7.
		    from gtw.&Curr_SYS._ParityCAP as A
			left join gtw.&Curr_SYS._ParityREQ as B on A.SysName NE B.SysName;
		quit; 


	%end;
%mend;
%create_parity_tbls;


file name: NGRER_Optimization_main_OSD.sas

**************************************************************************************************************************
***************************************NGRER RECODE 3/19/2024*************************************************************
**************************************************************************************************************************
;
options symbolgen MLOGIC MLOGICNEST mprint mlogic MPRINTNEST MAUTOSOURCE SYMBOLGEN SPOOL FULLSTIMER minoperator mindelimiter=',';
OPTIONS FORMCHAR="|----|+|---+=|-/\<>*";
options dlcreatedir;


data _null_;
	call symputx("xdate", put(today(),date9.));
	call symputx("i_start_time", put(time(),time12.2));
/*	i_start_time = time();*/
run;

%put &xdate;
%put &i_start_time;
%let current_cycle = FY25;
%let prior_cycle = FY24;

%let SUBVER = ;
%let subs_allowed = ;

%let SSO_update = 0;	/* This should be set to 0 until the SSO has update parity lins procurements and requirements*/


%let USE_SUB = 0;	/* This should be set to 1 to use Army regulation substitutions.  However, if set to 0 no substitution will be counted towards On Hands*/
/*parameter that enable subs 
1 -> Subs are Allowed
0 -> Subs are NOT Allowed*/
    %let SUBVER = _NOSUBS;
	%let subs_allowed = 0;

/*  %let xdate=19SEP2022;*/

%put &SUBVER;
*%let SAS_DATA_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\CODE;
*%let DATA_Output_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Output;
*%let DATA_Input_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input;

%let CODE_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\CODE;
%let DATA_Output_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Output;
%let DATA_Input_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input;
%let ASRA_Reports_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Output\&xdate._NGRER_OPT_Reports&SUBVER;

%let Deliverables_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Output\&xdate._NGRER_OPT_Deliverables&SUBVER.;

%let SAS_DATA_PATH = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._&SUBVER;

%let DARPL_PATH =  O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input;

%let version = ;

data _null_;
	if month(today()) < 10 then call symput('min_date',year(today()));
	else call symput('min_date',year(today()) +1);
run; 

%let current_fy = &min_date;

%let LastPOM_YR = %eval(&min_date + 6);
%let FirstPOM_YR = %eval(&min_date + 2);
%let Previous_YR=%eval(&min_date -1);

%put &FirstPOM_YR;
%put &LastPOM_YR;
%put &current_fy;

%LET Y1 = &current_fy;
%LET Y2 = %eval(&current_fy + 1);
%LET Y3 = %eval(&current_fy + 2);
%LET Y4 = %eval(&current_fy + 3);
%LET Y5 = %eval(&current_fy + 4);
%LET Y6 = %eval(&current_fy + 5);
%LET Y7 = %eval(&current_fy + 6);
%LET sht_Y1 = %substr(&Y1,3,2);
%put &sht_Y1;
%LET sht_Y7 = %substr(&Y7,3,2);
%put &sht_Y7;

%let date_range =(&Y1 &Y2 &Y3 &Y4 &Y5 &Y6 &Y7);
%let date_list = (&Y1 &Y2 &Y3 &Y4 &Y5 &Y6 &Y7);
%let date_range2 =(&Y1 &Y2 &Y3);
%let date_range3 =(&Y4 &Y5 &Y6 &Y7);

Libname compo "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._StudyData"; 
Libname DARPL "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._DARPL_SUBS"; 
libname PARP "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._PARP";
libname Results "&Data_Output_Path";
libname Data "&ASRA_Reports_Path";
libname Outputs "&Data_Output_Path";
libname LMDB "&Data_Input_Path";
libname Deliver "&Deliverables_Path";

%let varlist = S_OH E_OH REQ ASSIGN SHORT EXCESS EOH Shortage_Cost Excess_Cost;
%let varnum = %eval(%sysfunc(countw(&varlist%str( ))));
%put &varnum;
%let liblist = PARP DARPL;
%let libnum = %eval(%sysfunc(countw(&liblist%str( ))));
%put &libnum;

%let ResultsFile = &xdate._ASRA_DARPL_Report.xlsx;
%let FM_date = 202508;
/*%let FinMgmtFile = AE2S_CURRENT_POSITION_&FM_date..csv;*/
%let FinMgmtFile = AE2S_CURRENT_POSITION_2025-08-11;

%let date_fmt = yymmdd10.;

/*%let folder = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\ASRA\Bucket_Pour\Q2FY21\Model Output Results;*/
%let run_control=&xdate._Linked_Excel_Input_to_PPT_Shell_Q2FY21_SUBS.xlsx;

/* These macro variables define the sets of inventory that are considered unserviceable or obsolete. */
%let unserviceable = ('H', 'P', 'S'/*, 'U'*/) /*based on Condition Code*/;
%let obsolete = ('S','O') /*based on LCC Code*/;

/*SACS FILE DATA PARAMETERS*/
%let sacs_h_index = cla_header_roll02-may-25.txt;
%let sacs_e_index = cla_eqpdet_roll02-may-25.txt;
%let delimter = '09'x;

/*SACS FILE DATA PARAMETERS*/
%let DARPL_NEW24 = &DATA_Input_Path.\CUI_20240401_FY25_DARPL_Update.xlsx; 
/*%let DARPL_NEW25 = &DATA_Input_Path.\DARPL FY2025 Update.xlsx; */


%LET USE_AUTH = 1;

/*DST Data and Procurement File DATA PARAMETERS*/

%let USE_DST = 1;	/* This should be set to 0 to use procurements in the Financial Management File.  However, set to 1 if it is requested to use LMI trensfers for two year before the POM*/
%let dst_file_name = LMI_DST_PSDs 8-7-25;
%let use_unitsum = 0; /* This should be set to 0 to use the sacs header file for matching typco data to units in the DST file must have latest unit_summary file to set to 1 */

/*Inventory LDAC DST Date  DATA PARAMETERS*/
%LET Use_csv = 0; /* This should be set to 0 when using the xlsx version of LDAC file drop;  CSV versions would be named DST&DATE_1.csv,,,etc. */ 
%LET LDAC_NAME=AE2S_LIN_DATA_G8_NIIN_File_;
%LET DSTDATE=20250811; /* Date of LDAC inventory file regardless of excel vs csv format  */

%let sb_date = SB_700_20_CHAPTERS_2025-08-11;

%let lmdb_month = Aug2025;
%let lmdb_file2 = LINS_ACTIVE_2025-08-11;

%let use_sso_scrub = 1;

/*Macro variables below are specific to the optimization module and parameters  */
%let std_time = ;
%let run_time = ;
%let run_level = D_UIC;
%let RUN_NAME = &xdate._&current_cycle._ASRA_optimization;
%let MAX_DATE = &LastPOM_YR;

libname IDM "&SAS_DATA_PATH";

%let idm_input = &SAS_DATA_PATH.\OPT_Input;
%let idm_output = C:\temp\OPT_Output;


%let model_base = Optimization_SubModule.sas;

/*Allows a user to identify a modified LIN cluster set*/
%let cluster_tag = ;

/*Allows a user to run the the input processing for the model
	1 = Run ALL Inputs
	Any other value will not run the clusters*/
%let run_all_inputs = 1;

/*If the Run All Inputs toggle is turned on
this will allow a user to run the cluster code if necessary
	1 = Run Clusters
	Any other value will not run the clusters*/
%let run_cluster = 1;

/*Allows a user to run the model if ready 
	1 = Run Model
	Any other value will not run the model
The Single Component parameter will also let a user run 
	an individual component to troubleshoot any 
	annomaly in the run. If this number is above
	0 then the model will process only that
	component.*/
%let run_model = 0;
%let single_component = 0;

%let NGRER_RUN_TOGGLE = 0;
/*First year when Intercomponent transfers are permitted*/
%let CASC_YEAR = &FirstPOM_YR;
/*Allows for the use of DST Data when this is set to 1*/
%let USE_DST = 1;

%let log_name = &xdate._&current_cycle._ASRA_STD_100_Percent_v3;

/*Added a parameter to allow a user to show the Log while the data runs rather than
outputting it to a text file. This is generally run in unison with 
running a single component to troubleshoot*/
%let show_log = 0;

/*parameter that ensures only subs where the sublin is as, or more modern, than the required lin are allowed
1 -> This is turned on always for NGRER
0 -> All subs are allowed unless otherwise specified should always be 0 for ASRA runs*/
%let modern_subs = 1;

%let lin_list = "ALL";
%let t_filter = ('1','2','3');

%let unit_yearly_xfer_pen = .01;

%let fix_flex = 1;

/*Adding in a parameter to freeze the first two years of the inventory*/
%let freeze_first_two = 1;

/*Adds a parameter that allows for the usage of LMI data - if the toggle is turned on to 1 then
it will be use and the equipfor data will be ignored, otherwise it wont be used and the equipfor data 
won't be used*/
%let use_lmi = 1;
libname idm_i "&idm_input";

libname idm_o "&idm_output";


data idm_i.i_start_time;

	call symputx("start_time", put(time(),time8.0));
	obs = 1;
	i_start_time = time();
run;
%put &start_time;

/*DARPL : THIS IS USED IN THE FORMATTING.SAS FOR THE FDA_UIC FILE*/

PROC IMPORT OUT= lmdb.lmdb_&lmdb_month
    DATAFILE= "&DATA_Input_Path.\&lmdb_file2" 
    DBMS=xlsx REPLACE;
	Sheet= "LINS_Active";
    GETNAMES=YES;
    DATAROW=2; 
RUN;

proc sort data=lmdb.lmdb_&lmdb_month out=results.Army_study_BOS(keep=Portfolio) nodupkey ;
  by Portfolio;
run;

proc sort data=lmdb.lmdb_&lmdb_month out=results.Army_study_LIN_BOS(keep=LIN Portfolio SSO_OFFICE_SYMBOL rename=SSO_OFFICE_SYMBOL=OFFICE_SYMBOL) nodupkey ;
  by LIN Portfolio SSO_OFFICE_SYMBOL;
run;

%LET NUM_STUDY_BOS = 0;

data Army_study_BOS;
set results.Army_study_BOS;
where Portfolio ne ' ' ; 
run; 

PROC SQL NOPRINT;	
	SELECT
		COUNT(Portfolio) INTO :NUM_STUDY_BOS
	FROM Army_study_BOS;

	select distinct cats("'", Portfolio , "'")
		into :Army_study_BOS separated by  ' ,' 
	FROM Army_study_BOS;
QUIT;

%put &Army_study_BOS;
%put &NUM_STUDY_BOS;

**************************Import DARPL Info *****************************************************************************;
%let new_darpl_yr =2025;
 
PROC IMPORT DATAFILE = "&DARPL_NEW24" OUT = Unit_Priority
	DBMS = XLSX REPLACE;
	GETNAMES = YES;
    DATAROW=2; 
RUN;
  

/****************************Import SACS Requirements*************************************************************/


%macro pull_SACS_files(inpath, sacs_h_index, sacs_e_index); 
/*Initialization of the current fY macro variable*/

%put &current_fy;

data equipment_details;
	length
		RUNID 6 UIC $ 6 EDATE 8 LIN $ 6 ERC $ 1 RMK1 $ 3 RMK2 $ 3 RQEQP 8 AUEQP 8 RQBOI 8 AUBOI 8 SORCE 5 MDUIC $ 2;

	infile "&DATA_Input_Path.\&sacs_e_index"
		firstobs= 2
		dlm = &delimter
		missover
		dsd;
	input
		RUNID  UIC $  EDATE  LIN $  ERC $  RMK1 $  RMK2 $  RQEQP  AUEQP  RQBOI  AUBOI  SORCE  MDUIC $;
run;

%LET NUM_STUDY_UICS = 0;

proc sql;
  create table STUDY_UICS AS
     select distinct 
	   UIC
	 from equipment_details
	 order by UIC;
quit;

PROC SQL NOPRINT;	
	SELECT
		COUNT(UIC) INTO :NUM_STUDY_UICS
	FROM STUDY_UICS;
QUIT;


/*This data statement reads in the UIC header file code mapping through the use of 
	that an infile statement that reads the .csv file. This file contains all of the SAMAS based data that is used
	to refere to a unit, its location, what MACOM it reports to, and many other fields. The code also
	comptues the type of units that are either ABCTs, HBCTs, IBCTs, SBCTs, or CABs; what
	theater the unit is in; and corrects the station codes to enable the joing to the earlier station
	code mapping. */
data compo.uic_header_details;

length
		RUNID 8 UIC $ 6 EDATEI 8 TPSN $ 5 MACOM $ 2 ACTCO $ 1 ADCCO $ 1 MDEP $ 4 
		COMPO $ 1 UNTDS $ 21 CARSS $ 2 TYPCO $ 1 UNMBR $ 4 FPA $ 1 DAMPL $ 5 SRC $ 9 ALO $ 3 
		SRCPARA $ 2 ASGMT $ 2 LOCCO $ 3 AMSCO $ 8 BRNCH $ 2 CCNUM $ 6 DOCNO $ 11 DPMNT $ 1 ELSEQ $ 2 
		FORCO $ 1 MBCMD $ 1 MBLOC $ 1 MBPRD $ 1 MBSTA 8 MTOEC $ 6 NTREF $ 1 PHASE $ 1 ROBCO $ 4 ROC $ 3 
		STACO $ 5 TDATE 8 ULCCC $ 3 UTC $ 5 COP_BDE_TYPE $ 4 THEATER $ 10;

			infile "&DATA_Input_Path.\&sacs_h_index"
		firstobs= 2
		dlm = &delimter
		missover
		dsd;

	input
		RUNID  UIC $  EDATEI  TPSN $  MACOM $  ACTCO $  ADCCO $  MDEP $  
		COMPO $  UNTDS $  CARSS $  TYPCO $  UNMBR $  FPA $  DAMPL $  SRC $  ALO $  
		SRCPARA $  ASGMT $  LOCCO $  AMSCO $  BRNCH $  CCNUM $  DOCNO $  DPMNT $  ELSEQ $  
		FORCO $  MBCMD $  MBLOC $  MBPRD $  MBSTA  MTOEC $  NTREF $  PHASE $  ROBCO $  ROC $  
		STACO $  TDATE  ULCCC $  UTC $ COP_BDE_TYPE $ THEATER $;

 run;
/*The SQL statement below handles any duplicate UIC-EDATE pairings and brings in the data we will
need in the follow on SQL joins*/
proc sql;
	create table core_uic_header_data as
	select distinct
		b.UIC,
		b.edatei as EDATE,
		B.SRC,
		b.COMPO,
		b.TYPCO,
		b.TDATE,
/*		b.TPSN,*/
/*		b.MACOM,*/
		b.DAMPL,
/*		b.BRNCH,*/
/*		b.STACO,*/
/*		b.COP_BDE_TYPE,*/
/*		b.THEATER,*/
/*		b.ASGMT,*/
		B.UNTDS
	from compo.uic_header_details as b;
quit;


/*The sql statement below performs a left join from the LIN equipment and 
	brings in fields that traditionally appear on the FDA_UIC_OUT file.
	The reassignment of DAMPL to DARPL is to remain consistent with the format of the
	data but we should be aware as analyst that this is the DAMPL and not the DARPL.
	The DARPL is a classifed data element and does not belong on this unclassified file*/

proc sql;
	create table equipment_join_header as
	select
		a.*,
		b.COMPO,
		b.TYPCO,
		b.TDATE,
/*		b.TPSN,*/
/*		b.MACOM,*/
		b.DAMPL as DARPL,
/*		b.BRNCH,*/
/*		b.STACO,*/
/*		b.COP_BDE_TYPE,*/
/*		b.THEATER,*/
/*		b.ASGMT,*/
		B.SRC,
		B.UNTDS
	from equipment_details as a left join core_uic_header_data as b
		on a.edate = b.edate and a.uic = b.uic;

/*  where lin in (&SUBSET_lins);*/
  
quit;


proc sql;
	create table study_lins as
	  select distinct
	  	LIN
	  from equipment_join_header
	  order by lin;
quit;

%LET NUM_STUDY_LINS = 0;

data STUDY_LINS;
set STUDY_LINS;
where lin ne ' ' ; 
run; 

PROC SQL NOPRINT;	
	SELECT
		COUNT(LIN) INTO :NUM_STUDY_LINS
	FROM STUDY_LINS;

	select distinct cats("'", lin , "'")
		into :STUDY_LINS separated by  ' ,' 
	FROM STUDY_LINS;
QUIT;

%put &study_lins;


/*Filters out UICS without requirements.  UIC without requirement and and large inventory were not observed to fill Army shortages over time in reality */
proc sql;
	create table equipment_join_header2 as
	select
		a.*
	from equipment_join_header as a /*inner join STUDY_UICS as b
	on a.uic = b.uic*/;
quit;


/*Filters out LINS without procurements.  LINs with no procurements will not change regards to OH, shortages or EOH   */
proc sql;
	create table equipment_join_header3 as
	select
		a.*
	from equipment_join_header2 as a /*inner join STUDY_LINS as b
	on a.lin = b.lin*/;
quit;

%mend pull_SACS_files;

%pull_SACS_files(&Data_Input_Path, &sacs_h_index, &sacs_e_index);


*************************Import Procurement Info**************************************************************************;

PROC IMPORT OUT= fdiis_lqa
    DATAFILE= "&DATA_Input_Path.\&FinMgmtFile" 
    DBMS=xlsx REPLACE;
	Sheet= "AE2S_CURRENT_POSITION";
    GETNAMES=YES;
    DATAROW=2; 
RUN;

************************Import Inventory Info****************************************************************************;
%macro import_inventory;
	  %macro load_xls_inventory(j);
		PROC IMPORT OUT= DST_DATA_&j
		    DATAFILE= "&DATA_Input_Path.\&LDAC_NAME.&DSTDATE..xlsx" 
		    DBMS=xlsx REPLACE;
			Sheet= "Sheet &j";
		    GETNAMES=YES;
		    DATAROW=2; 
		RUN;
	  %mend load_xls_inventory;
	  
	  	%do j = 1 %to 3;
		   %load_xls_inventory(&j);
		%end;
	
	PROC SQL;
		CREATE TABLE compo.Initial_inventory AS 
			SELECT * FROM DST_DATA_1
			 OUTER UNION CORR 
			SELECT * FROM DST_DATA_2
			 OUTER UNION CORR 
			SELECT * FROM DST_DATA_3
			;
	Quit;
%mend import_inventory;

%import_inventory;

****************************Import SB 700 File*************************************************************************;
/*PROC IMPORT OUT= SB_700_20*/
/*    DATAFILE= "&DATA_Input_Path.\&sb_date" */
/*    DBMS=CSV REPLACE;*/
/*	Sheet= "SB_700_20_CHAPTERS";*/
/*    GETNAMES=YES;*/
/*    DATAROW=2; */
/*RUN;*/
PROC IMPORT DATAFILE = "&DATA_Input_Path.\SB_700_20_CHAPTERS_2025-08-11.xlsx" OUT = SB_700_20
    DBMS=XLSX REPLACE;
	GETNAMES = YES;
    DATAROW=2; 
RUN;
****************************Import DST Info****************************************************************************;
proc import out = dst_data
			datafile = "&DATA_Input_Path.\LMI_DST_PSDs 8-7-25.xlsx"
    DBMS=XLSX REPLACE;
    GETNAMES=YES;
    DATAROW=2; 
run;

***************************Import Substitution Rules info****************************************************************;
proc import out = sb_700_20_appxH
			datafile = "&DATA_Input_Path.\SB_700_20_APPENDIX_H_2025-08-11.xlsx"
    DBMS=XLSX REPLACE;
    GETNAMES=YES;
    DATAROW=2; 
run;


/*data sb_700_20_appxH;*/
/*	length*/
/*		lin $ 6*/
/*		lin_name $ 255*/
/*		sublin $ 6*/
/*		sub_name $ 255;*/
/*		*/
/*	infile "&DATA_Input_Path.\SB_700_20_APPENDIX_H.csv"*/
/*		firstobs = 2*/
/*		missover*/
/*		dlm = ','*/
/*		dsd;*/
/*	input*/
/*		lin $ lin_name $ sublin $ sub_name $;*/
/*run;*/

****************************DARPL Priority File for UIC Priority from first POM year though 5th POM year*****************;



data Unit_Priority2 (keep=DARPL_RANK UIC COMPO rename=(DARPL_RANK=PRIORITY));
  set Unit_Priority;
  
RUN;

data Unit_Priority_temp;
  set Unit_Priority2;
  do FY=2025 to 2031;
  output;
  end;
run;

proc sort data=Unit_Priority_temp out=Unit_Priority; by FY PRIORITY; run;


/*data Unit_Priority2 (keep=FY DARPL_RANK UIC COMPO rename=DARPL_RANK=PRIORITY);*/
/*  set Unit_Priority2;*/
/*  */
/*RUN;*/

/*%LET MAX_DARPL_YR = 0;*/
/**/
/*PROC SQL NOPRINT;	*/
/*	SELECT*/
/*		MAX(FY) INTO :MAX_DARPL_YR*/
/*	FROM Unit_Priority2;*/
/*quit; */
/**/
/*%put &MAX_DARPL_YR;*/
/**/
/*%macro insert_darpl_years;*/
/*	data darpl_base;*/
/*		set Unit_Priority2;*/
/*		if FY = &MAX_DARPL_YR;*/
/*	run; */
/*	%do i=0 %to %eval(&MAX_DARPL_YR - &current_fy);*/
/*	   %let curr_yr = %eval(&current_fy + &i);*/
/*	   %if &curr_yr = &new_darpl_yr %then %do;*/
/*	   %end;*/
/*	   %else %do;*/
/*			data darpl_addFY&curr_yr;*/
/*				set Unit_Priority;*/
/*				IF FY = &curr_yr;*/
/*			run;*/
/**/
/*			proc append base=darpl_base data=darpl_addFY&curr_yr;*/
/*			run;*/
/*		%end;*/
/*	%end;*/
/*%mend insert_darpl_years;*/
/**/
/*%macro add_darpl_years;*/
/*	data darpl_lastyr;*/
/*		set darpl_base;*/
/*		if FY = &MAX_DARPL_YR;*/
/*	run; */
/*	%do i=1 %to %eval(&LastPOM_YR - &MAX_DARPL_YR);*/
/*	   %let new_yr = %eval(&MAX_DARPL_YR + &i);*/
/*		data darpl_addFY&new_yr;*/
/*			set darpl_lastyr;*/
/*			FY = &new_yr;*/
/*		run;*/
/**/
/*		proc append base=darpl_base data=darpl_addFY&new_yr;*/
/*		run;*/
/*	%end;*/
/*%mend add_darpl_years;*/
/**/
/**/
/*%macro run_darpl_years;*/
/*	%insert_darpl_years;*/
/*	%if &MAX_DARPL_YR LT &LastPOM_YR %then %do;*/
/*		%add_darpl_years;*/
/*	%end;*/
/*%mend run_darpl_years;*/
/**/
/*%run_darpl_years;*/
/**/

data DARPL_PRIORITY1;
  set unit_priority;
run;

proc sql;  
	insert into DARPL_PRIORITY1 
	   	set 	FY=2025,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2025,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2025,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2025,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set 	FY=2026,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2026,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2026,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2026,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set 	FY=2027,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2027,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2027,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2027,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set	FY=2028,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2028,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2028,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2028,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
        	set FY=2029,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2029,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2029,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2029,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2030,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set FY=2031,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2031,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2031,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2031,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6;
		
quit;  

data compo.DARPL_PRIORITY1;
  set DARPL_PRIORITY1;
run;
**************************************************************************************************************************
**************************************AUTHORATATIVE INPUT FILES FOR COMPO Split MODELS ***********************************
*************************************AUTHORATATIVE SOURCES ARE Inventory (latest ARCOP Pull)******************************
*************************************LMI DST Extract from AESIP (Provides projected transfers*****************************
*******************************************from Inventory pull until the first POM year***********************************
****************************Latest POM LQA file (Programmed LIN procurement quanities by YEAR by ROOT/BOS/APE*************
**************************************************************************************************************************/;

****************************SACS Equipment Detail (Unit REQS) and Unit Details files (UIC Compo Acto)********************;

%macro create_out_years(inset, num_years);


/*Initialization of a counter variable that will be used
to terminate the do-while loop once it exceeds the number 
of years specified by the input variable num_years*/
	%let i = 0;

	/*Entrance into teh Do-While loop*/
	%do %while  (%eval(&i) <= %eval(&num_years));

	/* assignment of the fiscal year we are processing based on 
	the global macro variabel initialized in the first data
	statement and the number of iterations that we've gone though the loop*/
	%let processing_fy = %eval(&current_fy + &i);

	/* data step to creat the requirement file in the year that we are 
	processing. Once this macro terminates there a data set labeled with 
	each fiscal year processed*/
	data FY_EQUIP_REQS_&processing_fy;
		set &inset;
		
		length FY $ 4;

		/*Per the guidance we are filtering on data where the EDATE >= September 30th, of the FY and where 
		the TDATE is <= October 1st of the FY. To compute this in the same format as the 
		EDATE and TDATE we multply the Fiscial year by 1000 and add 930 to it for the EDATE filter and
		add 1001 to the TDATE filter. For example if we are processing fiscal year 2019 the equations below 
		would result in:
			2019 * 10000 = 20190000  + 930 = 20190930
			and
			2019 * 10000 = 20190000 + 1001 = 20191001
		where this date is in the YYYYMMDD format*/
		if edate <= ((&current_fy. + &i.) * 10000 + 930) and tdate >= ((&current_fy. + &i.) * 10000 + 1001) then
			FY = &current_fy. + &i.;

		/* Filters out FYs that are unassigned and drills down to the fiscal year being processed*/
		if FY ne "";

		/*Declaration of derivative uic*/
		IF MDUIC NE '' THEN UIC = SUBSTRN(UIC,1,4) || MDUIC;

		IF SUBSTRN(MDUIC,1,1) = 'X' THEN COMPO = 1;
		ELSE IF SUBSTRN(MDUIC,1,1) = 'G' THEN COMPO = 2;
		ELSE IF SUBSTRN(MDUIC,1,1) = 'R' THEN COMPO = 3;

	run;

	/* If we are in the first iteration of the loop we'll create the base 
	data set we will append all of the upcoming data sets to.*/
	%if &i = 0 %then %do;
		data ALL_LIN_REQS;
			set FY_EQUIP_REQS_&processing_fy;
			if typco ne '3';
			if rqeqp > 0;
		run;
	%end;
	/* if we are not in the first iteration of the do-while loop then we will append the processed data
	to the primary table "ALL_LIN_REQS"*/
	%else %do;
		
		proc append base = compo.ALL_LIN_REQS data = FY_EQUIP_REQS_&processing_fy;
		run;
	%end;
	/*Now we'll update the counter variable and proceed to the next iteration of the do-while loop 
		or terminate when i is not less than or equal to the num_years specified*/
	%let i = &i +1;

	
	%end;
%mend;

/*here we call the macro and this will run it through the data set specified and the number
of years we want to produce*/
%create_out_years(equipment_join_header3, %eval(&LastPOM_YR - &current_fy));


/*This is a sql statement that produced the required and authorized values
by Fiscal year, Compo and LIN.*/
data compo.all_reqs(rename=(rqeqp=req aueqp=auth));
  LENGTH TYPCO_CAT $8;
	set compo.ALL_LIN_REQS;
	if typco ne '3';
	if rqeqp > 0;
	if erc in ("B","C") then erc = "A";
	if compo eq '6' THEN rqeqp = aueqp;  

  	if TYPCO='1' then TYPCO_CAT = "MTOE";
	else if TYPCO='2' then TYPCO_CAT = "AUG-TDA";
    else TYPCO_CAT = "TDA";

run;

proc sql; 
	create table compo.sacs_uic as 
		select distinct FY, Lin, uic, compo, typco, erc, sum (auth) as auth, sum (req) as req 
		from compo.all_reqs
		group by Lin, uic, compo, typco, erc, fy
		ORDER BY Lin, compo, typco, erc, uic, fy;
quit;


proc transpose data=compo.sacs_uic out=compo.sacs_uic_xtab
	prefix = FY
	delimiter = _;
	by LIN COMPO TYPCO ERC UIC;
	id FY;
	var REQ;
run;

proc sql;
   create table compo.uic_typco as
     select distinct 
	   uic,
	   typco
	 from compo.sacs_uic_xtab
	 order by uic;
quit;


data compo.uic_typco;
  set compo.uic_typco;
  LENGTH TYPCO_CAT $8;
  	if TYPCO='1' then TYPCO_CAT = "MTOE";
	else if TYPCO='2' then TYPCO_CAT = "AUG-TDA";
    else TYPCO_CAT = "TDA";
run;


proc sql; 
	create table compo.sacs_compo_erc as 
		select distinct FY, Lin, compo, erc, sum (req) as req 
		from compo.all_reqs
/*		where typco ne '3'*/
/*		where LIN in &lin_list.*/
		group by Lin, compo,erc, fy
		ORDER BY Lin, compo, erc, fy;
quit;


proc transpose data=compo.sacs_compo_erc out=compo.sacs_cmpo_erc_xtab
	prefix = FY
	delimiter = _;
	by LIN COMPO ERC;
	id FY;
	var REQ;
run;

/***** Added code to get distinct LINs from SACs to go in generate_opt_model_inputs.sas per 9/23/22 Aria and Trent *****/

proc sql;
	    create table reqd_lin as
		   select distinct
		      lin
		   from compo.all_reqs;
	quit;

****************************Latest POM LQA file (Programmed LIN procurement quanities by YEAR by ROOT/BOS/APE************;
data fdiis_lqa (drop=compo rename=compo3=compo);
set fdiis_lqa;
   IF BO EQ '1' AND AMOUNT GT 0 AND FY GT &Previous_YR AND Procurement_Type IN ("NEW", "RECAP") AND AMOUNT_TYPE EQ "Quantity" AND LIN_OUT ne "N/A";
   compo3=put(compo,1.);
run;

proc sql;
	create table _fdiis_lqa_prt1 as
	select distinct
		lin_out as LIN,
		COMPO,
		FY,
		sum(Amount) as Qty
	from fdiis_lqa
	group by lin_out, compo, FY
    order by lin_out, compo, FY
;
quit;


data compo._fdiis_lqa_prt1;
set _fdiis_lqa_prt1;
	if Qty = . then Qty = 0;
run;
*******************************************from Inventory pull until the first POM year**********************************;
proc sql; 
create table compo.inventory_filter as
  select 
    A.LIN_NSLIN AS LIN,
    a.Supply_Record as UIC,
	A.*
  from compo.Initial_inventory as a 
  group by A.LIN_NSLIN, A.COMPONENT_CODE
  order by A.LIN_NSLIN, A.COMPONENT_CODE;
quit;


**************************************************************************************************************************
*****Latest SB-700 Data (Used to determine Obsolete/Unserviceable Items by LIN/NIIN LCC and Condition Codes)**************
**************************************************************************************************************************/;

data SB_700_20;
  set SB_700_20;
  NIN = SUBSTRN(NSN,5,9);
run;

proc sql;
  create table sb_700_20_count as
    select distinct
	   LIN,
	   count(LIN) as count
	from SB_700_20
	group by LIN
	order by LIN;
quit;

proc sql; 
	create table  compo.Initial_inventory_pull as
		select distinct  
 			UIC, 
			LIN,
			NIIN_OR_MCN, 
			CONDITION_CODE,
			COMPONENT_CODE,
			sum(on_hand_qty) as qty 
		from compo.inventory_filter
		Group by uic, lin,  NIIN_OR_MCN, CONDITION_CODE, COMPONENT_CODE;
quit; 

data compo.INITIAL_INVENTORY_PULL(drop=COMPONENT_CODE);
	set  compo.INITIAL_INVENTORY_PULL; 
	if substrn(uic,5,1) in ('X','G','R') and substrn(uic,5,2) notin ('X1','X0','G1','G0','R1','R0') then uic = uic;
	else if substrn(uic,1,1) = "W" and substrn(uic,5,2) notin ('99','98') then uic = substrn(uic,1,4)||"AA";
	compo = put(COMPONENT_CODE,1.);
     /* Below removes non standard LINs & splits out depot inventory added 24JUN2021 -LBurdette*/
    IF LENGTHC(COMPRESS(SUBSTRN(LIN, 2,5), '', 'kd'))=5 or SUBSTRN(LIN, 4,2) = 'FD';
	if length(uic) ne 6 then uic=cats('FACOT',COMPONENT_CODE);  /* outputs inventory held by Depots */
run;

proc sql;
	create table compo.join_lin_inv_to_units_prep as
	select distinct 
 		a.UIC, 
		a.LIN,
		a.NIIN_OR_MCN, 
/*		a.COMPONENT_CODE,*/
		a.CONDITION_CODE,
		sum(a.qty) as qty, 
/*	 	B.LCC,*/
		a.compo
	from compo.INITIAL_INVENTORY_PULL as a 
	group by UIC, LIN, NIIN_OR_MCN, /*COMPONENT_CODE,*/ CONDITION_CODE, compo
    ORDER BY a.LIN, compo;
quit;

/*DEPENDENT ON SACS HEADER FILE FROM REQUIREMENT PROGRAM */
proc sql;  
	create table core_uic_header_data2 as
	select distinct 
 	 	UIC,
		compo,
		typco
		from core_uic_header_data
		where typco ne '3'
		order by UIC;
quit;

 proc sql;  
	insert into core_uic_header_data2 
	   set UIC='FACOT1',
	     typco='1',
		 compo='1'
  	   set UIC='FACOT2',
	     typco='1',
		 compo='2'
	    set UIC='FACOT3',
	     typco='1',
		 compo='3'
		  set UIC='FACOT6',
	     typco='1',
         compo='6';
quit;  

/*DEPENDENT ON THE OTHER InpUTS FROM SECTION ABOVE */
proc sql;  
	create table compo.join_lin_inv_to_units_prep2 as
	select distinct 
 		a.UIC, 
		a.LIN,
		a.NIIN_OR_MCN, 
/*		a.COMPONENT_CODE,*/
		a.CONDITION_CODE,
		a.qty, 
	 	B.LCC,
		c.typco,
		coalesce(a.compo,c.compo) as compo
	from compo.join_lin_inv_to_units_prep as a 
	LEFT JOIN SB_700_20 AS B ON A.LIN = B.LIN  AND  A.NIIN_OR_MCN = B.NIN
	FULL OUTER JOIN core_uic_header_data2 as c on a.uic = c.uic
    ORDER BY a.LIN, compo;
quit;


data obsolete LIN_INV unserviceables;
	set compo.join_lin_inv_to_units_prep2;
    if LIN ne ''; 
	if lcc in &obsolete  then output obsolete;
	else if condition_code in &unserviceable then output unserviceables;
	else output LIN_INV;
run;

proc sql;
	create table compo.inventory_by_uic as
	select distinct 
		a.LIN,
		a.compo,
 		a.UIC, 
		sum(qty) as qty 
	from LIN_INV as a 
	group by lin, compo, uic
    ORDER BY a.LIN, compo, uic;
quit;

proc sql;
	create table compo.inventory_by_uic as
	select 
		a.* 
	from compo.inventory_by_uic as a
/*	inner join study_uics as b on a.uic=b.uic */
    ORDER BY a.LIN, a.compo;
quit;

proc sql;
	create table compo.inventory_by_compo as
	select distinct 
		a.LIN,
		a.compo,
		sum(a.qty) as qty 
	from compo.inventory_by_uic as a 
	group by lin, compo
    ORDER BY a.LIN, compo;
quit;

*************************************LMI DST Extract from AESIP (Provides projected transfers****************************;
data fy_adjust;

set dst_data;
 
	suspense_date1=input(suspense_date,date11.);
	
	if month(suspense_date1) >=10 then suspense_fy = year(suspense_date1) + 1;
	else suspense_fy = year(suspense_date1);

	newnum = input(validated_quantity, COMMA10.);
	drop validated_quantity;
	rename newnum = validated_quantity;

run;

proc sql;
	create table dst_sum_to_uic as
	select distinct

		from_compo, to_compo, from_code, to_code, from_pb_lin, to_pb_lin, catalog_lin, source_niin as sourcing_niin, suspense_fy, sum(validated_quantity) as validated_quantity

	from fy_adjust
	group by 
	from_compo, to_compo, from_code, to_code, from_pb_lin, to_pb_lin, catalog_lin, source_niin, suspense_fy;
quit;

proc transpose data = dst_sum_to_uic out = dst_xtab_date;
	by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
	id suspense_fy;
	var validated_quantity;
run;

proc sql;
	create table sum_lin_inv_to_lin_niin as
	select distinct
		uic as owner,
		lin,
		niin_or_mcn as niin,
		sum(qty) as qty
	from LIN_INV
	group by 
		uic, lin, niin_or_mcn;
quit;

proc sql;
	create table join_unit_level_inv_to_dst as
	select 
		a.*, b.qty as qty_avail
	from dst_xtab_date as a left join sum_lin_inv_to_lin_niin as b
	on a.from_code =b.owner and a.catalog_lin = b.lin and a.sourcing_niin = b.niin;
quit;

data check_feasibility;
	retain from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin _&Y1. _&Y2. t_transfer qty_avail _&Y1._c _&Y2._c label;

	set join_unit_level_inv_to_dst;
	
	keep from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin _&Y1. _&Y2. t_transfer qty_avail  _&Y1._c _&Y2._c label;

	if length(from_code) = 6 then do;
		if qty_avail = . then qty_avail = 0;
		if _&Y1. = . then _&Y1. = 0;
		if _&Y2. = . then _&Y2. = 0;
		t_transfer = _&Y1. + _&Y2.;

		if qty_avail < t_transfer then do;

			_&Y1._c = min(qty_avail,_&Y1.);
			_&Y2._c = min(qty_avail - _&Y1._c, _&Y2.);
		end;
		else do;
            _&Y1._c = _&Y1.;
			_&Y2._c = _&Y2.;
		end;
	end;
	else do;
	    _&Y1._c = _&Y1.;
		_&Y2._c = _&Y2.;
	end;

	label = "v_qty_capped";

run;

proc sort data = check_feasibility; 
by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
run;

proc transpose data = check_feasibility out = dst_feasible;
	by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
	id label;
	var _&Y1._c _&Y2._c;
run;

data reassign_suspense;
	set dst_feasible;

	length suspense_date 8;
	format suspense_date date9.0;

	if v_qty_capped = . then 	v_qty_capped  = 0;
	if _name_ = "_&Y1._c" then suspense_date = "30SEP&Y1."d;
	if _name_ = "_&Y2._c" then suspense_date = "30SEP&Y2."d;

	if v_qty_capped  > 0;

run;


%macro add_typco;
%if &use_unitsum = 1 %then %do;
data unit_detail;
	length
		          UIC $ 6
                  Unit__ $ 4
                  Short_Unit_Desc $ 30
                  Long_Unit_Desc $ 60
                  MACOM $ 10
                  Assig__Cd $ 2
                  OESTS $ 1
                  ODATE__OESTS_ 8
                  CMPO $ 1
                  TPSN $ 5
                  Type_Co $ 1;
	informat ODATE__OESTS_  &date_fmt.;
	format ODATE__OESTS_  &date_fmt.;
	infile "&Data_Input_Path\unit_summary_&unit_date..txt"
		firstobs = 1 
		dlm = '09'x
 		lrecl=32767
		missover
		dsd;
	input
		 UIC $ 
                  Unit__ $ 
                  Short_Unit_Desc $ 
                  Long_Unit_Desc $ 
                  MACOM $ 
                  Assig__Cd $ 
                  OESTS $ 
                  ODATE__OESTS_ :&date_fmt.
                  CMPO $ 
                  TPSN $ 
                  Type_Co $ ;

run;
proc sql;
	create table join_typco_to_donor as
	select distinct
		a.*,
		b.type_co as from_typco
	from reassign_suspense as a left join unit_detail as b on a.from_code = b.uic;
quit;


proc sql;
	create table join_typco_to_claimer as
	select distinct
		a.*,
		b.type_co as to_typco
	from join_typco_to_donor as a left join unit_detail as b on a.to_code = b.uic;
quit;

%end;

%else; %do;
proc sql;
	create table join_typco_to_donor as
	select distinct
		a.*,
		b.typco as from_typco
	from reassign_suspense as a left join compo.uic_header_details as b on a.from_code = b.uic;
quit;


proc sql;
	create table join_typco_to_claimer as
	select distinct
		a.*,
		b.typco as to_typco
	from join_typco_to_donor as a left join compo.uic_header_details as b on a.to_code = b.uic;
quit;
%end;

%mend;

%add_typco;

data to_from_uic_manipulation_step;
	set join_typco_to_claimer;

	length From_UIC_AA_Level $ 6 To_UIC_AA_Level $ 6 from_compo_num $ 2 to_compo_num $ 2 Year 8;

	/*Assignment of the AA Level UIC
	if substrn(from_code,1,1) = "W" and substrn(from_code,5,2) notin ('99','98') then From_UIC_AA_Level = substrn(from_code,1,4)||"AA";
	else From_UIC_AA_Level = from_code;*/
    if typco ne '3';
	if substrn(from_code,5,1) in ('X','G','R') and substrn(from_code,5,2) notin ('X1','X0','G1','G0','R1','R0') then From_UIC_AA_Level = from_code;
	else if substrn(from_code,1,1) = "W" and substrn(from_code,5,2) notin ('99','98') then From_UIC_AA_Level = substrn(from_code,1,4)||"AA";
	else From_UIC_AA_Level = from_code;

	/*if substrn(to_code,1,1) = "W" and substrn(to_code,5,2) notin ('99','98') then To_UIC_AA_Level = substrn(to_code,1,4)||"AA";
	else To_UIC_AA_Level = to_code;*/

	
	if substrn(to_code,5,1) in ('X','G','R') and substrn(to_code,5,2) notin ('X1','X0','G1','G0','R1','R0') then To_UIC_AA_Level = to_code;
	else if substrn(to_code,1,1) = "W" and substrn(to_code,5,2) notin ('99','98') then To_UIC_AA_Level = substrn(to_code,1,4)||"AA";
	else To_UIC_AA_Level = to_code;

	/*Assignment of the year that the transfer will occur in*/
	if month(suspense_date) in (10,11,12) then year = year(suspense_date)  + 1;
	else year = year(suspense_date);
/*	year = suspense_fy;*/

	
	if to_typco in (' ', '2') then to_typco = 1;
	if from_typco in (' ', '2') then from_typco = 1;

	/*Assignment of the components that will be impacted*/
	if from_compo = "Active Army" then from_compo_num = '1'||from_typco;
	else if from_compo = "National Guard" then from_compo_num = '2'||from_typco;
	else if from_compo = "Army Reserve" then from_compo_num = '3'||from_typco;
	else from_compo_num = '6'||from_typco;

	if to_compo = "Active Army" then to_compo_num = '1'||to_typco;
	else if to_compo = "National Guard" then to_compo_num = '2'||to_typco;
	else if to_compo = "Army Reserve" then to_compo_num = '3'||to_typco;
	else to_compo_num = '6'||to_typco;

	if length(from_code) ne 6 then do;
		From_UIC_AA_Level = "FACOT"||from_compo_num;
		From_TYPCO = 1;
		from_compo_num = from_compo_num ||from_typco;
	end;
	if length(to_code) >=6;
run;

proc sql;
	create table compo.LMI_XFER_REMOVE as
	select distinct
		year as dates,
		from_compo_num as compos,
		from_uic_AA_LEVEL as units,
		catalog_lin as lins,
		sum(v_qty_capped) as qty
	from to_from_uic_manipulation_step where substrn(from_uic_AA_LEVEL,1,5) ne "FACOT"
	group by year, from_compo_num, from_uic_AA_LEVEL, catalog_lin;
quit;

proc sql;
	create table compo.LMI_XFER_ADD as
	select distinct
		year as dates,
		to_compo_num as compos,
		to_uic_AA_LEVEL as units,
		catalog_lin as lins,
		sum(v_qty_capped) as qty
	from to_from_uic_manipulation_step where substrn(to_uic_AA_LEVEL,1,5) ne "FACOT"
	group by year, to_compo_num, to_uic_AA_LEVEL, catalog_lin;
quit;

*************************************SUBSTITUTION RULES**********************************************;
data sb_700_20_appxH;
  set sb_700_20_appxH;

	start_Dt = today();
	format start_Dt date9.0;
	run_id = "LMDB_&LMDB_MONTH";
run;

/*This data step will reference the LMDB that you've specified and focused on the columns that
 contain substitution rules. The "transvar" varialbe is the creation of a column that will
 enable us with the ability to bring the LINs in each substitution column into a single
 column so that we can read it in as an "arc" that exists between one lin and another LIN.
 We also upper case the LIN as there are some LINs in the LMDB that are lowercase.*/
data lmdb_sub_columns (keep=LIN REPLACED_by1 REPLACED_by2 REPLACED_by3 REPLACED_by4 REPLACED_by5 
		REPLACES1 REPLACES2 REPLACES3 REPLACES4 REPLACES5 transvar rename=(REPLACED_by1=REPLACED_by_1 REPLACED_by2=REPLACED_by_2 REPLACED_by3=REPLACED_by_3 
        REPLACED_by4=REPLACED_by_4 REPLACED_by5=REPLACED_by_5 REPLACES1=REPLACES_1 REPLACES2=REPLACES_2 REPLACES3=REPLACES_3 REPLACES4=REPLACES_4 REPLACES5=REPLACES_5));
	set lmdb.lmdb_&LMDB_MONTH;

	transvar = 1;

	lin = upcase(LIN);

	if REPLACED_by1 ne '' or REPLACED_by2 ne '' or REPLACED_by3 ne '' or 
		REPLACED_by4 ne '' or REPLACED_by5 ne '' or REPLACES1 ne '' or 
		REPLACES2 ne '' or REPLACES3 ne '' or REPLACES4 ne '' or REPLACES5 ne '';
run;

/*Here we sort the previous data set by LIN so that it can be transposed*/

proc sort data = lmdb_sub_columns nodupkey; by lin; run;

proc transpose data = lmdb_sub_columns out = subrules_no_date_or_source;
	by lin;
	id transvar;
	var REPLACED_by_1 REPLACED_by_2 REPLACED_by_3 REPLACED_by_4 REPLACED_by_5 
			REPLACES_1 REPLACES_2 REPLACES_3 REPLACES_4 REPLACES_5 
			;
run;

/*Now we filter out any empty values as this indicates that a 
relationship does not exist; assign a date based on type of sub-rule
this will be used to define the authority that the rule exists under.*/
data filter_nulls;
	set subrules_no_date_or_source;

	length RUN_ID $ 12;

	if _1 ne '';

	_1 = upcase(_1);

	length date 8;
	format date date9.0;

	if _name_ in ('REPLACED_by_1', 'REPLACED_by_2', 'REPLACED_by_3', 'REPLACED_by_4', 'REPLACED_by_5') then do;
		date = '30SEP2017'd;
	end;

	else if _name_ in ('REPLACES_1', 'REPLACES_2', 'REPLACES_3', 'REPLACES_4', 'REPLACES_5') then do;
		date = '30SEP2019'd;
	end;
/*	else if _name_ = "ZLIN" then do */
/*			date = '30SEP2018'd;*/
/*	end;*/
	else do;
		date = '29SEP2017'd;
	end;

	RUN_ID = "LMDB_&LMDB_MONTH";
run;

/*The sql query here selects the minimum date observed for any 
lin-sublin combination. this will ensure all of the subrules
are distinct and references the highest authority that has blessed
off on the substitution rule.*/

proc sql;
	create table sub_rules_f1 as
	select distinct
		RUN_ID,
		lin,
		_1 as SUBLIN,
		min(date) as START_DT
	from filter_nulls
	group by lin, _1;
quit;

proc sql;
	insert into sub_rules_f1
	select distinct
		RUN_ID,
		_1 as LIN,
		LIN as SUBLIN,
		min(date) as START_DT
	from filter_nulls
	group by lin, _1;
quit;

proc sql;
	insert into sub_rules_f1
	select
		run_id,
		AUTH_LIN as lin,
		SUB_LIN as sublin,
		start_dt
	from sb_700_20_appxH;
quit;

proc sql;
	create table sub_rules_f2 as
	select distinct
		RUN_ID,
		lin,
		SUBLIN,
		min(start_dt) as START_DT
	from sub_rules_f1
	group by lin, sublin;
quit;

/*** Added where stmt to exclude LINS with mod levels less than 3 per Aria 9/23/22 ******/

proc sql;
	create table join_mca_to_lin as
	select
		a.*,b.major_capability_name as lin_mca
	from sub_rules_f2 as a left join lmdb.lmdb_&LMDB_MONTH as b
	on a.lin = b.lin
   where b.mod_level>2;
quit;

proc sql;
	create table join_mca_to_sublin as
	select
		a.*,b.major_capability_name as sublin_mca
	from join_mca_to_lin as a left join lmdb.lmdb_&LMDB_MONTH as b
	on a.sublin = b.lin
    where b.mod_level>2;
quit;

/*Now we will create the LIN-Sublin subrules for the run, assign a start_dt,
end_dt and unsub_date. The start_dt must be earlier than the scenario start
date of the SRAM run we plan to execute.*/

data lmdb.subrules_final;
	set join_mca_to_sublin;
	length SOURCE $ 10 ;
	if start_dt = today() then source = "1-SB_70_20";
	else if START_DT = '29SEP2017'd then SOURCE = "1-SB_700_20";
	else if START_DT = '30SEP2019'd then SOURCE = "3-REPLACES";
	else SOURCE = "4-REPLACED";


	if sublin_mca = '' OR LIN_MCA = '' OR (sublin_mca = lin_mca);

run;


/***************Above Code beginning REQ and OH info match last run TAEDP without shortages***************/
/**********************************RUN Bucket Pour********************************************************/
/******************* Insert Code to position ERC P shortage to be filled first ***************************/
/******************* Apply penalty when ERC A shortages are filled before ERC P***************************/
/****************************This code is used like a DARPL priority**************************************/
/*****************************************April 2024 Optimization code removed****************************/
%include "&code_path\make_index_sets_v2.sas";
%include "&code_path\Optimization_SubModule_OSD.sas";
%include "&code_path\generate_reports_NGRER_new.sas";/*generates the datasets that will feed reports and charts*/
%include "&code_path\NGRER_Summary_reports.sas";



file name: NGRER_Optimization_main_old.sas

**************************************************************************************************************************
***************************************NGRER RECODE 3/19/2024*************************************************************
**************************************************************************************************************************
;
options symbolgen MLOGIC MLOGICNEST mprint mlogic MPRINTNEST MAUTOSOURCE SYMBOLGEN SPOOL FULLSTIMER minoperator mindelimiter=',';
OPTIONS FORMCHAR="|----|+|---+=|-/\<>*";
options dlcreatedir;


data _null_;
	call symputx("xdate", put(today(),date9.));
	call symputx("i_start_time", put(time(),time12.2));
/*	i_start_time = time();*/
run;

%put &xdate;
%put &i_start_time;
%let current_cycle = FY24;
%let prior_cycle = FY23;

%let SUBVER = ;
%let subs_allowed = ;

%let SSO_update = 0;	/* This should be set to 0 until the SSO has update parity lins procurements and requirements*/


%let USE_SUB = 1;	/* This should be set to 1 to use Army regulation substitutions.  However, if set to 0 no substitution will be counted towards On Hands*/
/*parameter that enable subs 
1 -> Subs are Allowed
0 -> Subs are NOT Allowed*/
    %let SUBVER = _SUBS;
	%let subs_allowed = 1;

/*  %let xdate=19SEP2022;*/

%put &SUBVER;
*%let SAS_DATA_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\CODE;
*%let DATA_Output_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Output;
*%let DATA_Input_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input;

%let CODE_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\CODE;
%let DATA_Output_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Output;
%let DATA_Input_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input;
%let ASRA_Reports_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Output\&xdate._NGRER_OPT_Reports&SUBVER;

%let Deliverables_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Output\&xdate._NGRER_OPT_Deliverables&SUBVER.;

%let SAS_DATA_PATH = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input\&xdate._&SUBVER;

%let DARPL_PATH =  O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input\;

%let version = ;

data _null_;
	if month(today()) < 10 then call symput('min_date',year(today()));
	else call symput('min_date',year(today()) +1);
run; 

%let current_fy = &min_date;

%let LastPOM_YR = %eval(&min_date + 6);
%let FirstPOM_YR = %eval(&min_date + 2);
%let Previous_YR=%eval(&min_date -1);

%put &FirstPOM_YR;
%put &LastPOM_YR;
%put &current_fy;

%LET Y1 = &current_fy;
%LET Y2 = %eval(&current_fy + 1);
%LET Y3 = %eval(&current_fy + 2);
%LET Y4 = %eval(&current_fy + 3);
%LET Y5 = %eval(&current_fy + 4);
%LET Y6 = %eval(&current_fy + 5);
%LET Y7 = %eval(&current_fy + 6);
%LET sht_Y1 = %substr(&Y1,3,2);
%put &sht_Y1;
%LET sht_Y7 = %substr(&Y7,3,2);
%put &sht_Y7;

%let date_range =(&Y1 &Y2 &Y3 &Y4 &Y5 &Y6 &Y7);
%let date_list = (&Y1 &Y2 &Y3 &Y4 &Y5 &Y6 &Y7);
%let date_range2 =(&Y1 &Y2 &Y3);
%let date_range3 =(&Y4 &Y5 &Y6 &Y7);

Libname compo "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input\&xdate._StudyData"; 
Libname DARPL "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input\&xdate._DARPL_SUBS"; 
libname PARP "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input\&xdate._PARP";
libname Results "&Data_Output_Path";
libname Data "&ASRA_Reports_Path";
libname Outputs "&Data_Output_Path";
libname LMDB "&Data_Input_Path";
libname Deliver "&Deliverables_Path";

%let varlist = S_OH E_OH REQ ASSIGN SHORT EXCESS EOH Shortage_Cost Excess_Cost;
%let varnum = %eval(%sysfunc(countw(&varlist%str( ))));
%put &varnum;
%let liblist = PARP DARPL;
%let libnum = %eval(%sysfunc(countw(&liblist%str( ))));
%put &libnum;

%let ResultsFile = &xdate._ASRA_DARPL_Report.xlsx;
%let FM_date = 202405;
/*%let FinMgmtFile = AE2S_CURRENT_POSITION_&FM_date..csv;*/
%let FinMgmtFile = AE2S_CURRENT_POSITION_2024-05-22_16_03_14;

%let date_fmt = yymmdd10.;

/*%let folder = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\ASRA\Bucket_Pour\Q2FY21\Model Output Results;*/
%let run_control=&xdate._Linked_Excel_Input_to_PPT_Shell_Q2FY21_SUBS.xlsx;

/* These macro variables define the sets of inventory that are considered unserviceable or obsolete. */
%let unserviceable = ('H', 'P', 'S'/*, 'U'*/) /*based on Condition Code*/;
%let obsolete = ('S','O') /*based on LCC Code*/;

/*SACS FILE DATA PARAMETERS*/
%let sacs_h_index = cla_header_roll12-apr-24.txt;
%let sacs_e_index = cla_eqpdet_roll12-apr-24.txt;
%let delimter = '09'x;

/*SACS FILE DATA PARAMETERS*/
%let DARPL_NEW24 = &DATA_Input_Path.\CUI_20240315_FY24_DARPL_Update3_Release.xlsx; 
%let DARPL_NEW25 = &DATA_Input_Path.\DARPL FY2025 Update.xlsx; 


%LET USE_AUTH = 1;

/*DST Data and Procurement File DATA PARAMETERS*/

%let USE_DST = 1;	/* This should be set to 0 to use procurements in the Financial Management File.  However, set to 1 if it is requested to use LMI trensfers for two year before the POM*/
%let dst_file_name = LMI_DST_PSDs 8-13-24;
%let use_unitsum = 0; /* This should be set to 0 to use the sacs header file for matching typco data to units in the DST file must have latest unit_summary file to set to 1 */

/*Inventory LDAC DST Date  DATA PARAMETERS*/
%LET Use_csv = 0; /* This should be set to 0 when using the xlsx version of LDAC file drop;  CSV versions would be named DST&DATE_1.csv,,,etc. */ 
%LET LDAC_NAME=AE2S_LIN_DATA_G8_NIIN_File_;
%LET DSTDATE=20240812; /* Date of LDAC inventory file regardless of excel vs csv format  */

%let sb_date = SB_700_20_CHAPTERS_2024-08-13;

%let lmdb_month = Aug2024;
%let lmdb_file2 = LINS_ACTIVE_2024-08-13;

%let use_sso_scrub = 1;

/*Macro variables below are specific to the optimization module and parameters  */
%let std_time = ;
%let run_time = ;
%let run_level = D_UIC;
%let RUN_NAME = &xdate._&current_cycle._ASRA_optimization;
%let MAX_DATE = &LastPOM_YR;

libname IDM "&SAS_DATA_PATH";

%let idm_input = &SAS_DATA_PATH.\OPT_Input;
%let idm_output = &SAS_DATA_PATH.\OPT_Output;


%let model_base = Optimization_SubModule.sas;

/*Allows a user to identify a modified LIN cluster set*/
%let cluster_tag = ;

/*Allows a user to run the the input processing for the model
	1 = Run ALL Inputs
	Any other value will not run the clusters*/
%let run_all_inputs = 1;

/*If the Run All Inputs toggle is turned on
this will allow a user to run the cluster code if necessary
	1 = Run Clusters
	Any other value will not run the clusters*/
%let run_cluster = 1;

/*Allows a user to run the model if ready 
	1 = Run Model
	Any other value will not run the model
The Single Component parameter will also let a user run 
	an individual component to troubleshoot any 
	annomaly in the run. If this number is above
	0 then the model will process only that
	component.*/
%let run_model = 0;
%let single_component = 0;

%let NGRER_RUN_TOGGLE = 0;
/*First year when Intercomponent transfers are permitted*/
%let CASC_YEAR = &FirstPOM_YR;
/*Allows for the use of DST Data when this is set to 1*/
%let USE_DST = 1;

%let log_name = &xdate._&current_cycle._ASRA_STD_100_Percent_v2;

/*Added a parameter to allow a user to show the Log while the data runs rather than
outputting it to a text file. This is generally run in unison with 
running a single component to troubleshoot*/
%let show_log = 0;

/*parameter that ensures only subs where the sublin is as, or more modern, than the required lin are allowed
1 -> This is turned on always for NGRER
0 -> All subs are allowed unless otherwise specified should always be 0 for ASRA runs*/
%let modern_subs = 1;

%let lin_list = "ALL";
%let t_filter = ('1','2','3');

%let unit_yearly_xfer_pen = .01;

%let fix_flex = 1;

/*Adding in a parameter to freeze the first two years of the inventory*/
%let freeze_first_two = 1;

/*Adds a parameter that allows for the usage of LMI data - if the toggle is turned on to 1 then
it will be use and the equipfor data will be ignored, otherwise it wont be used and the equipfor data 
won't be used*/
%let use_lmi = 1;
libname idm_i "&idm_input";

libname idm_o "&idm_output";


data idm_i.i_start_time;

	call symputx("start_time", put(time(),time8.0));
	obs = 1;
	i_start_time = time();
run;
%put &start_time;

/*DARPL : THIS IS USED IN THE FORMATTING.SAS FOR THE FDA_UIC FILE*/

PROC IMPORT OUT= lmdb.lmdb_&lmdb_month
    DATAFILE= "&DATA_Input_Path.\&lmdb_file2" 
    DBMS=xlsx REPLACE;
	Sheet= "LINS_Active";
    GETNAMES=YES;
    DATAROW=2; 
RUN;

proc sort data=lmdb.lmdb_&lmdb_month out=results.Army_study_BOS(keep=Portfolio) nodupkey ;
  by Portfolio;
run;

proc sort data=lmdb.lmdb_&lmdb_month out=results.Army_study_LIN_BOS(keep=LIN Portfolio SSO_OFFICE_SYMBOL rename=SSO_OFFICE_SYMBOL=OFFICE_SYMBOL) nodupkey ;
  by LIN Portfolio SSO_OFFICE_SYMBOL;
run;

%LET NUM_STUDY_BOS = 0;

data Army_study_BOS;
set results.Army_study_BOS;
where Portfolio ne ' ' ; 
run; 

PROC SQL NOPRINT;	
	SELECT
		COUNT(Portfolio) INTO :NUM_STUDY_BOS
	FROM Army_study_BOS;

	select distinct cats("'", Portfolio , "'")
		into :Army_study_BOS separated by  ' ,' 
	FROM Army_study_BOS;
QUIT;

%put &Army_study_BOS;
%put &NUM_STUDY_BOS;

**************************Import DARPL Info *****************************************************************************;
%let new_darpl_yr =2025;
 
PROC IMPORT DATAFILE = "&DARPL_NEW24" OUT = Unit_Priority
	DBMS = XLSX REPLACE;
	GETNAMES = YES;
    DATAROW=2; 
RUN;
PROC IMPORT DATAFILE = "&DARPL_NEW25" OUT = Unit_Priority2
	DBMS = XLSX REPLACE;
	GETNAMES = YES;
    DATAROW=2; 
RUN;    

/****************************Import SACS Requirements*************************************************************/


%macro pull_SACS_files(inpath, sacs_h_index, sacs_e_index); 
/*Initialization of the current fY macro variable*/

%put &current_fy;

data equipment_details;
	length
		RUNID 6 UIC $ 6 EDATE 8 LIN $ 6 ERC $ 1 RMK1 $ 3 RMK2 $ 3 RQEQP 8 AUEQP 8 RQBOI 8 AUBOI 8 SORCE 5 MDUIC $ 2;

	infile "&DATA_Input_Path.\&sacs_e_index"
		firstobs= 2
		dlm = &delimter
		missover
		dsd;
	input
		RUNID  UIC $  EDATE  LIN $  ERC $  RMK1 $  RMK2 $  RQEQP  AUEQP  RQBOI  AUBOI  SORCE  MDUIC $;
run;

%LET NUM_STUDY_UICS = 0;

proc sql;
  create table STUDY_UICS AS
     select distinct 
	   UIC
	 from equipment_details
	 order by UIC;
quit;

PROC SQL NOPRINT;	
	SELECT
		COUNT(UIC) INTO :NUM_STUDY_UICS
	FROM STUDY_UICS;
QUIT;


/*This data statement reads in the UIC header file code mapping through the use of 
	that an infile statement that reads the .csv file. This file contains all of the SAMAS based data that is used
	to refere to a unit, its location, what MACOM it reports to, and many other fields. The code also
	comptues the type of units that are either ABCTs, HBCTs, IBCTs, SBCTs, or CABs; what
	theater the unit is in; and corrects the station codes to enable the joing to the earlier station
	code mapping. */
data compo.uic_header_details;

length
		RUNID 8 UIC $ 6 EDATEI 8 TPSN $ 5 MACOM $ 2 ACTCO $ 1 ADCCO $ 1 MDEP $ 4 
		COMPO $ 1 UNTDS $ 21 CARSS $ 2 TYPCO $ 1 UNMBR $ 4 FPA $ 1 DAMPL $ 5 SRC $ 9 ALO $ 3 
		SRCPARA $ 2 ASGMT $ 2 LOCCO $ 3 AMSCO $ 8 BRNCH $ 2 CCNUM $ 6 DOCNO $ 11 DPMNT $ 1 ELSEQ $ 2 
		FORCO $ 1 MBCMD $ 1 MBLOC $ 1 MBPRD $ 1 MBSTA 8 MTOEC $ 6 NTREF $ 1 PHASE $ 1 ROBCO $ 4 ROC $ 3 
		STACO $ 5 TDATE 8 ULCCC $ 3 UTC $ 5 COP_BDE_TYPE $ 4 THEATER $ 10;

			infile "&DATA_Input_Path.\&sacs_h_index"
		firstobs= 2
		dlm = &delimter
		missover
		dsd;

	input
		RUNID  UIC $  EDATEI  TPSN $  MACOM $  ACTCO $  ADCCO $  MDEP $  
		COMPO $  UNTDS $  CARSS $  TYPCO $  UNMBR $  FPA $  DAMPL $  SRC $  ALO $  
		SRCPARA $  ASGMT $  LOCCO $  AMSCO $  BRNCH $  CCNUM $  DOCNO $  DPMNT $  ELSEQ $  
		FORCO $  MBCMD $  MBLOC $  MBPRD $  MBSTA  MTOEC $  NTREF $  PHASE $  ROBCO $  ROC $  
		STACO $  TDATE  ULCCC $  UTC $ COP_BDE_TYPE $ THEATER $;

 run;
/*The SQL statement below handles any duplicate UIC-EDATE pairings and brings in the data we will
need in the follow on SQL joins*/
proc sql;
	create table core_uic_header_data as
	select distinct
		b.UIC,
		b.edatei as EDATE,
		B.SRC,
		b.COMPO,
		b.TYPCO,
		b.TDATE,
/*		b.TPSN,*/
/*		b.MACOM,*/
		b.DAMPL,
/*		b.BRNCH,*/
/*		b.STACO,*/
/*		b.COP_BDE_TYPE,*/
/*		b.THEATER,*/
/*		b.ASGMT,*/
		B.UNTDS
	from compo.uic_header_details as b;
quit;


/*The sql statement below performs a left join from the LIN equipment and 
	brings in fields that traditionally appear on the FDA_UIC_OUT file.
	The reassignment of DAMPL to DARPL is to remain consistent with the format of the
	data but we should be aware as analyst that this is the DAMPL and not the DARPL.
	The DARPL is a classifed data element and does not belong on this unclassified file*/

proc sql;
	create table equipment_join_header as
	select
		a.*,
		b.COMPO,
		b.TYPCO,
		b.TDATE,
/*		b.TPSN,*/
/*		b.MACOM,*/
		b.DAMPL as DARPL,
/*		b.BRNCH,*/
/*		b.STACO,*/
/*		b.COP_BDE_TYPE,*/
/*		b.THEATER,*/
/*		b.ASGMT,*/
		B.SRC,
		B.UNTDS
	from equipment_details as a left join core_uic_header_data as b
		on a.edate = b.edate and a.uic = b.uic;

/*  where lin in (&SUBSET_lins);*/
  
quit;


proc sql;
	create table study_lins as
	  select distinct
	  	LIN
	  from equipment_join_header
	  order by lin;
quit;

%LET NUM_STUDY_LINS = 0;

data STUDY_LINS;
set STUDY_LINS;
where lin ne ' ' ; 
run; 

PROC SQL NOPRINT;	
	SELECT
		COUNT(LIN) INTO :NUM_STUDY_LINS
	FROM STUDY_LINS;

	select distinct cats("'", lin , "'")
		into :STUDY_LINS separated by  ' ,' 
	FROM STUDY_LINS;
QUIT;

%put &study_lins;


/*Filters out UICS without requirements.  UIC without requirement and and large inventory were not observed to fill Army shortages over time in reality */
proc sql;
	create table equipment_join_header2 as
	select
		a.*
	from equipment_join_header as a /*inner join STUDY_UICS as b
	on a.uic = b.uic*/;
quit;


/*Filters out LINS without procurements.  LINs with no procurements will not change regards to OH, shortages or EOH   */
proc sql;
	create table equipment_join_header3 as
	select
		a.*
	from equipment_join_header2 as a /*inner join STUDY_LINS as b
	on a.lin = b.lin*/;
quit;

%mend pull_SACS_files;

%pull_SACS_files(&Data_Input_Path, &sacs_h_index, &sacs_e_index);


*************************Import Procurement Info**************************************************************************;

PROC IMPORT OUT= fdiis_lqa
    DATAFILE= "&DATA_Input_Path.\&FinMgmtFile" 
    DBMS=xlsx REPLACE;
	Sheet= "AE2S_CURRENT_POSITION";
    GETNAMES=YES;
    DATAROW=2; 
RUN;

************************Import Inventory Info****************************************************************************;
%macro import_inventory;
	  %macro load_xls_inventory(j);
		PROC IMPORT OUT= DST_DATA_&j
		    DATAFILE= "&DATA_Input_Path.\&LDAC_NAME.&DSTDATE..xlsx" 
		    DBMS=xlsx REPLACE;
			Sheet= "Sheet &j";
		    GETNAMES=YES;
		    DATAROW=2; 
		RUN;
	  %mend load_xls_inventory;
	  
	  	%do j = 1 %to 3;
		   %load_xls_inventory(&j);
		%end;
	
	PROC SQL;
		CREATE TABLE compo.Initial_inventory AS 
			SELECT * FROM DST_DATA_1
			 OUTER UNION CORR 
			SELECT * FROM DST_DATA_2
			 OUTER UNION CORR 
			SELECT * FROM DST_DATA_3
			;
	Quit;
%mend import_inventory;

%import_inventory;

****************************Import SB 700 File*************************************************************************;
/*PROC IMPORT OUT= SB_700_20*/
/*    DATAFILE= "&DATA_Input_Path.\&sb_date" */
/*    DBMS=CSV REPLACE;*/
/*	Sheet= "SB_700_20_CHAPTERS";*/
/*    GETNAMES=YES;*/
/*    DATAROW=2; */
/*RUN;*/
/*PROC IMPORT DATAFILE = "&DATA_Input_Path.\&sb_date..csv" OUT = SB_700_20*/
/*	DBMS = CSV REPLACE;*/
/*	GETNAMES = YES;*/
/*    DATAROW=2; */
/*RUN;*/

proc import out = SB_700_20
			datafile = "&DATA_Input_Path.\SB_700_20_CHAPTERS_2024-08-13.xlsx"
    DBMS=XLSX REPLACE;
    GETNAMES=YES;
    DATAROW=2; 
run;
****************************Import DST Info****************************************************************************;
proc import out = dst_data
			datafile = "&DATA_Input_Path.\LMI_DST_PSDs 8-13-24.xlsx"
    DBMS=XLSX REPLACE;
    GETNAMES=YES;
    DATAROW=2; 
run;

***************************Import Substitution Rules info****************************************************************;
proc import out = sb_700_20_appxH
			datafile = "&DATA_Input_Path.\SB_700_20_APPENDIX_H_2024-08-13.xlsx"
    DBMS=XLSX REPLACE;
    GETNAMES=YES;
    DATAROW=2; 
run;


****************************DARPL Priority File for UIC Priority from first POM year though 5th POM year*****************;
data Unit_Priority (keep=DARPL_FY DARPL_RANK UIC COMPO rename=(DARPL_FY=FY DARPL_RANK=PRIORITY));
  set Unit_Priority;
  
RUN;
data Unit_Priority2 (keep=FY DARPL_RANK UIC COMPO rename=DARPL_RANK=PRIORITY);
  set Unit_Priority2;
  
RUN;

%LET MAX_DARPL_YR = 0;

PROC SQL NOPRINT;	
	SELECT
		MAX(FY) INTO :MAX_DARPL_YR
	FROM Unit_Priority2;
quit; 

%put &MAX_DARPL_YR;

%macro insert_darpl_years;
	data darpl_base;
		set Unit_Priority2;
		if FY = &MAX_DARPL_YR;
	run; 
	%do i=0 %to %eval(&MAX_DARPL_YR - &current_fy);
	   %let curr_yr = %eval(&current_fy + &i);
	   %if &curr_yr = &new_darpl_yr %then %do;
	   %end;
	   %else %do;
			data darpl_addFY&curr_yr;
				set Unit_Priority;
				IF FY = &curr_yr;
			run;

			proc append base=darpl_base data=darpl_addFY&curr_yr;
			run;
		%end;
	%end;
%mend insert_darpl_years;

%macro add_darpl_years;
	data darpl_lastyr;
		set darpl_base;
		if FY = &MAX_DARPL_YR;
	run; 
	%do i=1 %to %eval(&LastPOM_YR - &MAX_DARPL_YR);
	   %let new_yr = %eval(&MAX_DARPL_YR + &i);
		data darpl_addFY&new_yr;
			set darpl_lastyr;
			FY = &new_yr;
		run;

		proc append base=darpl_base data=darpl_addFY&new_yr;
		run;
	%end;
%mend add_darpl_years;


%macro run_darpl_years;
	%insert_darpl_years;
	%if &MAX_DARPL_YR LT &LastPOM_YR %then %do;
		%add_darpl_years;
	%end;
%mend run_darpl_years;

%run_darpl_years;


data compo.DARPL_PRIORITY1;
  set darpl_base;
run;

proc sql;  
	insert into compo.DARPL_PRIORITY1 
	   	set 	FY=2025,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2025,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2025,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2025,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set 	FY=2026,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2026,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2026,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2026,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set 	FY=2027,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2027,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2027,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2027,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set	FY=2028,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2028,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2028,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2028,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
        	set FY=2029,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2029,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2029,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2029,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2030,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6;
		
quit;  


**************************************************************************************************************************
**************************************AUTHORATATIVE INPUT FILES FOR COMPO Split MODELS ***********************************
*************************************AUTHORATATIVE SOURCES ARE Inventory (latest ARCOP Pull)******************************
*************************************LMI DST Extract from AESIP (Provides projected transfers*****************************
*******************************************from Inventory pull until the first POM year***********************************
****************************Latest POM LQA file (Programmed LIN procurement quanities by YEAR by ROOT/BOS/APE*************
**************************************************************************************************************************/;

****************************SACS Equipment Detail (Unit REQS) and Unit Details files (UIC Compo Acto)********************;

%macro create_out_years(inset, num_years);


/*Initialization of a counter variable that will be used
to terminate the do-while loop once it exceeds the number 
of years specified by the input variable num_years*/
	%let i = 0;

	/*Entrance into teh Do-While loop*/
	%do %while  (%eval(&i) <= %eval(&num_years));

	/* assignment of the fiscal year we are processing based on 
	the global macro variabel initialized in the first data
	statement and the number of iterations that we've gone though the loop*/
	%let processing_fy = %eval(&current_fy + &i);

	/* data step to creat the requirement file in the year that we are 
	processing. Once this macro terminates there a data set labeled with 
	each fiscal year processed*/
	data FY_EQUIP_REQS_&processing_fy;
		set &inset;
		
		length FY $ 4;

		/*Per the guidance we are filtering on data where the EDATE >= September 30th, of the FY and where 
		the TDATE is <= October 1st of the FY. To compute this in the same format as the 
		EDATE and TDATE we multply the Fiscial year by 1000 and add 930 to it for the EDATE filter and
		add 1001 to the TDATE filter. For example if we are processing fiscal year 2019 the equations below 
		would result in:
			2019 * 10000 = 20190000  + 930 = 20190930
			and
			2019 * 10000 = 20190000 + 1001 = 20191001
		where this date is in the YYYYMMDD format*/
		if edate <= ((&current_fy. + &i.) * 10000 + 930) and tdate >= ((&current_fy. + &i.) * 10000 + 1001) then
			FY = &current_fy. + &i.;

		/* Filters out FYs that are unassigned and drills down to the fiscal year being processed*/
		if FY ne "";

		/*Declaration of derivative uic*/
		IF MDUIC NE '' THEN UIC = SUBSTRN(UIC,1,4) || MDUIC;

		IF SUBSTRN(MDUIC,1,1) = 'X' THEN COMPO = 1;
		ELSE IF SUBSTRN(MDUIC,1,1) = 'G' THEN COMPO = 2;
		ELSE IF SUBSTRN(MDUIC,1,1) = 'R' THEN COMPO = 3;

	run;

	/* If we are in the first iteration of the loop we'll create the base 
	data set we will append all of the upcoming data sets to.*/
	%if &i = 0 %then %do;
		data ALL_LIN_REQS;
			set FY_EQUIP_REQS_&processing_fy;
			if typco ne '3';
			if rqeqp > 0;
		run;
	%end;
	/* if we are not in the first iteration of the do-while loop then we will append the processed data
	to the primary table "ALL_LIN_REQS"*/
	%else %do;
		
		proc append base = compo.ALL_LIN_REQS data = FY_EQUIP_REQS_&processing_fy;
		run;
	%end;
	/*Now we'll update the counter variable and proceed to the next iteration of the do-while loop 
		or terminate when i is not less than or equal to the num_years specified*/
	%let i = &i +1;

	
	%end;
%mend;

/*here we call the macro and this will run it through the data set specified and the number
of years we want to produce*/
%create_out_years(equipment_join_header3, %eval(&LastPOM_YR - &current_fy));


/*This is a sql statement that produced the required and authorized values
by Fiscal year, Compo and LIN.*/
data compo.sacs_uic(rename=(rqeqp=req aueqp=auth));
  LENGTH TYPCO_CAT $8;
	set compo.ALL_LIN_REQS;
	if typco ne '3';
	if rqeqp > 0;
	if erc in ("B","C") then erc = "A";
	if compo eq '6' THEN rqeqp = aueqp;  

  	if TYPCO='1' then TYPCO_CAT = "MTOE";
	else if TYPCO='2' then TYPCO_CAT = "AUG-TDA";
    else TYPCO_CAT = "TDA";

run;

proc sql; 
	create table compo.all_reqs as 
		select distinct FY, Lin, uic, compo, typco, erc, sum (auth) as auth, sum (req) as req 
		from compo.sacs_uic
		group by Lin, uic, compo, typco, erc, fy
		ORDER BY Lin, compo, typco, erc, uic, fy;
quit;

proc transpose data=compo.sacs_uic out=compo.sacs_uic_xtab
	prefix = FY
	delimiter = _;
	by LIN COMPO TYPCO ERC UIC;
	id FY;
	var REQ;
run;

proc sql;
   create table compo.uic_typco as
     select distinct 
	   uic,
	   typco
	 from compo.sacs_uic_xtab
	 order by uic;
quit;


data compo.uic_typco;
  set compo.uic_typco;
  LENGTH TYPCO_CAT $8;
  	if TYPCO='1' then TYPCO_CAT = "MTOE";
	else if TYPCO='2' then TYPCO_CAT = "AUG-TDA";
    else TYPCO_CAT = "TDA";
run;


proc sql; 
	create table compo.sacs_compo_erc as 
		select distinct FY, Lin, compo, erc, sum (req) as req 
		from compo.all_reqs
/*		where typco ne '3'*/
/*		where LIN in &lin_list.*/
		group by Lin, compo,erc, fy
		ORDER BY Lin, compo, erc, fy;
quit;


proc transpose data=compo.sacs_compo_erc out=compo.sacs_cmpo_erc_xtab
	prefix = FY
	delimiter = _;
	by LIN COMPO ERC;
	id FY;
	var REQ;
run;

/***** Added code to get distinct LINs from SACs to go in generate_opt_model_inputs.sas per 9/23/22 Aria and Trent *****/

proc sql;
	    create table reqd_lin as
		   select distinct
		      lin
		   from compo.all_reqs;
	quit;

****************************Latest POM LQA file (Programmed LIN procurement quanities by YEAR by ROOT/BOS/APE************;
data fdiis_lqa (drop=compo rename=compo3=compo);
set fdiis_lqa;
   IF BO EQ 1 AND AMOUNT GT 0 AND FY GT &Previous_YR AND Procurement_Type IN ("NEW", "RECAP") AND AMOUNT_TYPE EQ "Quantity" AND LIN_OUT ne "N/A";
   compo3=put(compo,1.);
run;

proc sql;
	create table _fdiis_lqa_prt1 as
	select distinct
		lin_out as LIN,
		COMPO,
		FY,
		sum(Amount) as Qty
	from fdiis_lqa
	group by lin_out, compo, FY
    order by lin_out, compo, FY
;
quit;


data compo._fdiis_lqa_prt1;
set _fdiis_lqa_prt1;
	if Qty = . then Qty = 0;
run;
*******************************************from Inventory pull until the first POM year**********************************;
proc sql; 
create table compo.inventory_filter as
  select 
    A.LIN_NSLIN AS LIN,
    a.Supply_Record as UIC,
	A.*
  from compo.Initial_inventory as a 
  group by A.LIN_NSLIN, A.COMPONENT_CODE
  order by A.LIN_NSLIN, A.COMPONENT_CODE;
quit;


**************************************************************************************************************************
*****Latest SB-700 Data (Used to determine Obsolete/Unserviceable Items by LIN/NIIN LCC and Condition Codes)**************
**************************************************************************************************************************/;

data SB_700_20;
  set SB_700_20;
  NIN = SUBSTRN(NSN,5,9);
run;

proc sql;
  create table sb_700_20_count as
    select distinct
	   LIN,
	   count(LIN) as count
	from SB_700_20
	group by LIN
	order by LIN;
quit;

proc sql; 
	create table  compo.Initial_inventory_pull as
		select distinct  
 			UIC, 
			LIN,
			NIIN_OR_MCN, 
			CONDITION_CODE,
			COMPONENT_CODE,
			sum(on_hand_qty) as qty 
		from compo.inventory_filter
		Group by uic, lin,  NIIN_OR_MCN, CONDITION_CODE, COMPONENT_CODE;
quit; 

data compo.INITIAL_INVENTORY_PULL(drop=COMPONENT_CODE);
	set  compo.INITIAL_INVENTORY_PULL; 
	if substrn(uic,5,1) in ('X','G','R') and substrn(uic,5,2) notin ('X1','X0','G1','G0','R1','R0') then uic = uic;
	else if substrn(uic,1,1) = "W" and substrn(uic,5,2) notin ('99','98') then uic = substrn(uic,1,4)||"AA";
	compo = put(COMPONENT_CODE,1.);
     /* Below removes non standard LINs & splits out depot inventory added 24JUN2021 -LBurdette*/
    IF LENGTHC(COMPRESS(SUBSTRN(LIN, 2,5), '', 'kd'))=5 or SUBSTRN(LIN, 4,2) = 'FD';
	if length(uic) ne 6 then uic=cats('FACOT',COMPONENT_CODE);  /* outputs inventory held by Depots */
run;

proc sql;
	create table compo.join_lin_inv_to_units_prep as
	select distinct 
 		a.UIC, 
		a.LIN,
		a.NIIN_OR_MCN, 
		a.COMPONENT_CODE,
		a.CONDITION_CODE,
		sum(a.qty) as qty, 
/*	 	B.LCC,*/
		a.compo
	from compo.INITIAL_INVENTORY_PULL as a 
	group by UIC, LIN, NIIN_OR_MCN, COMPONENT_CODE, CONDITION_CODE, compo
    ORDER BY a.LIN, compo;
quit;

/*DEPENDENT ON SACS HEADER FILE FROM REQUIREMENT PROGRAM */
proc sql;  
	create table core_uic_header_data2 as
	select distinct 
 	 	UIC,
		compo,
		typco
		from core_uic_header_data
		where typco ne '3'
		order by UIC;
quit;

 proc sql;  
	insert into core_uic_header_data2 
	   set UIC='FACOT1',
	     typco='1',
		 compo='1'
  	   set UIC='FACOT2',
	     typco='1',
		 compo='2'
	    set UIC='FACOT3',
	     typco='1',
		 compo='3'
		  set UIC='FACOT6',
	     typco='1',
         compo='6';
quit;  

/*DEPENDENT ON THE OTHER InpUTS FROM SECTION ABOVE */
proc sql;  
	create table compo.join_lin_inv_to_units_prep2 as
	select distinct 
 		a.UIC, 
		a.LIN,
		a.NIIN_OR_MCN, 
		a.COMPONENT_CODE,
		a.CONDITION_CODE,
		a.qty, 
	 	B.LCC,
		c.typco,
		coalesce(a.compo,c.compo) as compo
	from compo.join_lin_inv_to_units_prep as a 
	LEFT JOIN SB_700_20 AS B ON A.LIN = B.LIN  AND  A.NIIN_OR_MCN = B.NIN
	FULL OUTER JOIN core_uic_header_data2 as c on a.uic = c.uic
    ORDER BY a.LIN, compo;
quit;


data obsolete LIN_INV unserviceables;
	set compo.join_lin_inv_to_units_prep2;
    if LIN ne ''; 
	if lcc in &obsolete  then output obsolete;
	else if condition_code in &unserviceable then output unserviceables;
	else output LIN_INV;
run;

proc sql;
	create table compo.inventory_by_uic as
	select distinct 
		a.LIN,
		a.compo,
 		a.UIC, 
		sum(qty) as qty 
	from LIN_INV as a 
	group by lin, compo, uic
    ORDER BY a.LIN, compo, uic;
quit;

proc sql;
	create table compo.inventory_by_uic as
	select 
		a.* 
	from compo.inventory_by_uic as a
/*	inner join study_uics as b on a.uic=b.uic */
    ORDER BY a.LIN, a.compo;
quit;

proc sql;
	create table compo.inventory_by_compo as
	select distinct 
		a.LIN,
		a.compo,
		sum(a.qty) as qty 
	from compo.inventory_by_uic as a 
	group by lin, compo
    ORDER BY a.LIN, compo;
quit;

*************************************LMI DST Extract from AESIP (Provides projected transfers****************************;
data fy_adjust;

set dst_data;
 
	suspense_date1=input(suspense_date,date11.);
	
	if month(suspense_date1) >=10 then suspense_fy = year(suspense_date1) + 1;
	else suspense_fy = year(suspense_date1);

	newnum = input(validated_quantity, COMMA10.);
	drop validated_quantity;
	rename newnum = validated_quantity;

run;

proc sql;
	create table dst_sum_to_uic as
	select distinct

		from_compo, to_compo, from_code, to_code, from_pb_lin, to_pb_lin, catalog_lin, sourcing_niin, suspense_fy, sum(validated_quantity) as validated_quantity

	from fy_adjust
	group by 
	from_compo, to_compo, from_code, to_code, from_pb_lin, to_pb_lin, catalog_lin, sourcing_niin, suspense_fy;
quit;

proc transpose data = dst_sum_to_uic out = dst_xtab_date;
	by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
	id suspense_fy;
	var validated_quantity;
run;

proc sql;
	create table sum_lin_inv_to_lin_niin as
	select distinct
		uic as owner,
		lin,
		niin_or_mcn as niin,
		sum(qty) as qty
	from LIN_INV
	group by 
		uic, lin, niin_or_mcn;
quit;

proc sql;
	create table join_unit_level_inv_to_dst as
	select 
		a.*, b.qty as qty_avail
	from dst_xtab_date as a left join sum_lin_inv_to_lin_niin as b
	on a.from_code =b.owner and a.catalog_lin = b.lin and a.sourcing_niin = b.niin;
quit;

data check_feasibility;
	retain from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin _&Y1. _&Y2. t_transfer qty_avail _&Y1._c _&Y2._c label;

	set join_unit_level_inv_to_dst;
	
	keep from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin _&Y1. _&Y2. t_transfer qty_avail  _&Y1._c _&Y2._c label;

	if length(from_code) = 6 then do;
		if qty_avail = . then qty_avail = 0;
		if _&Y1. = . then _&Y1. = 0;
		if _&Y2. = . then _&Y2. = 0;
		t_transfer = _&Y1. + _&Y2.;

		if qty_avail < t_transfer then do;

			_&Y1._c = min(qty_avail,_&Y1.);
			_&Y2._c = min(qty_avail - _&Y1._c, _&Y2.);
		end;
		else do;
            _&Y1._c = _&Y1.;
			_&Y2._c = _&Y2.;
		end;
	end;
	else do;
	    _&Y1._c = _&Y1.;
		_&Y2._c = _&Y2.;
	end;

	label = "v_qty_capped";

run;

proc sort data = check_feasibility; 
by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
run;

proc transpose data = check_feasibility out = dst_feasible;
	by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
	id label;
	var _&Y1._c _&Y2._c;
run;

data reassign_suspense;
	set dst_feasible;

	length suspense_date 8;
	format suspense_date date9.0;

	if v_qty_capped = . then 	v_qty_capped  = 0;
	if _name_ = "_&Y1._c" then suspense_date = "30SEP&Y1."d;
	if _name_ = "_&Y2._c" then suspense_date = "30SEP&Y2."d;

	if v_qty_capped  > 0;

run;


%macro add_typco;
%if &use_unitsum = 1 %then %do;
data unit_detail;
	length
		          UIC $ 6
                  Unit__ $ 4
                  Short_Unit_Desc $ 30
                  Long_Unit_Desc $ 60
                  MACOM $ 10
                  Assig__Cd $ 2
                  OESTS $ 1
                  ODATE__OESTS_ 8
                  CMPO $ 1
                  TPSN $ 5
                  Type_Co $ 1;
	informat ODATE__OESTS_  &date_fmt.;
	format ODATE__OESTS_  &date_fmt.;
	infile "&Data_Input_Path\unit_summary_&unit_date..txt"
		firstobs = 1 
		dlm = '09'x
 		lrecl=32767
		missover
		dsd;
	input
		 UIC $ 
                  Unit__ $ 
                  Short_Unit_Desc $ 
                  Long_Unit_Desc $ 
                  MACOM $ 
                  Assig__Cd $ 
                  OESTS $ 
                  ODATE__OESTS_ :&date_fmt.
                  CMPO $ 
                  TPSN $ 
                  Type_Co $ ;

run;
proc sql;
	create table join_typco_to_donor as
	select distinct
		a.*,
		b.type_co as from_typco
	from reassign_suspense as a left join unit_detail as b on a.from_code = b.uic;
quit;


proc sql;
	create table join_typco_to_claimer as
	select distinct
		a.*,
		b.type_co as to_typco
	from join_typco_to_donor as a left join unit_detail as b on a.to_code = b.uic;
quit;

%end;

%else; %do;
proc sql;
	create table join_typco_to_donor as
	select distinct
		a.*,
		b.typco as from_typco
	from reassign_suspense as a left join compo.uic_header_details as b on a.from_code = b.uic;
quit;


proc sql;
	create table join_typco_to_claimer as
	select distinct
		a.*,
		b.typco as to_typco
	from join_typco_to_donor as a left join compo.uic_header_details as b on a.to_code = b.uic;
quit;
%end;

%mend;

%add_typco;

data to_from_uic_manipulation_step;
	set join_typco_to_claimer;

	length From_UIC_AA_Level $ 6 To_UIC_AA_Level $ 6 from_compo_num $ 2 to_compo_num $ 2 Year 8;

	/*Assignment of the AA Level UIC
	if substrn(from_code,1,1) = "W" and substrn(from_code,5,2) notin ('99','98') then From_UIC_AA_Level = substrn(from_code,1,4)||"AA";
	else From_UIC_AA_Level = from_code;*/
    if typco ne '3';
	if substrn(from_code,5,1) in ('X','G','R') and substrn(from_code,5,2) notin ('X1','X0','G1','G0','R1','R0') then From_UIC_AA_Level = from_code;
	else if substrn(from_code,1,1) = "W" and substrn(from_code,5,2) notin ('99','98') then From_UIC_AA_Level = substrn(from_code,1,4)||"AA";
	else From_UIC_AA_Level = from_code;

	/*if substrn(to_code,1,1) = "W" and substrn(to_code,5,2) notin ('99','98') then To_UIC_AA_Level = substrn(to_code,1,4)||"AA";
	else To_UIC_AA_Level = to_code;*/

	
	if substrn(to_code,5,1) in ('X','G','R') and substrn(to_code,5,2) notin ('X1','X0','G1','G0','R1','R0') then To_UIC_AA_Level = to_code;
	else if substrn(to_code,1,1) = "W" and substrn(to_code,5,2) notin ('99','98') then To_UIC_AA_Level = substrn(to_code,1,4)||"AA";
	else To_UIC_AA_Level = to_code;

	/*Assignment of the year that the transfer will occur in*/
	if month(suspense_date) in (10,11,12) then year = year(suspense_date)  + 1;
	else year = year(suspense_date);
/*	year = suspense_fy;*/

	
	if to_typco in (' ', '2') then to_typco = 1;
	if from_typco in (' ', '2') then from_typco = 1;

	/*Assignment of the components that will be impacted*/
	if from_compo = "Active Army" then from_compo_num = '1'||from_typco;
	else if from_compo = "National Guard" then from_compo_num = '2'||from_typco;
	else if from_compo = "Army Reserve" then from_compo_num = '3'||from_typco;
	else from_compo_num = '6'||from_typco;

	if to_compo = "Active Army" then to_compo_num = '1'||to_typco;
	else if to_compo = "National Guard" then to_compo_num = '2'||to_typco;
	else if to_compo = "Army Reserve" then to_compo_num = '3'||to_typco;
	else to_compo_num = '6'||to_typco;

	if length(from_code) ne 6 then do;
		From_UIC_AA_Level = "FACOT"||from_compo_num;
		From_TYPCO = 1;
		from_compo_num = from_compo_num ||from_typco;
	end;
	if length(to_code) >=6;
run;

proc sql;
	create table compo.LMI_XFER_REMOVE as
	select distinct
		year as dates,
		from_compo_num as compos,
		from_uic_AA_LEVEL as units,
		catalog_lin as lins,
		sum(v_qty_capped) as qty
	from to_from_uic_manipulation_step where substrn(from_uic_AA_LEVEL,1,5) ne "FACOT"
	group by year, from_compo_num, from_uic_AA_LEVEL, catalog_lin;
quit;

proc sql;
	create table compo.LMI_XFER_ADD as
	select distinct
		year as dates,
		to_compo_num as compos,
		to_uic_AA_LEVEL as units,
		catalog_lin as lins,
		sum(v_qty_capped) as qty
	from to_from_uic_manipulation_step where substrn(to_uic_AA_LEVEL,1,5) ne "FACOT"
	group by year, to_compo_num, to_uic_AA_LEVEL, catalog_lin;
quit;

*************************************SUBSTITUTION RULES**********************************************;
data sb_700_20_appxH;
  set sb_700_20_appxH;

	start_Dt = today();
	format start_Dt date9.0;
	run_id = "LMDB_&LMDB_MONTH";
run;

/*This data step will reference the LMDB that you've specified and focused on the columns that
 contain substitution rules. The "transvar" varialbe is the creation of a column that will
 enable us with the ability to bring the LINs in each substitution column into a single
 column so that we can read it in as an "arc" that exists between one lin and another LIN.
 We also upper case the LIN as there are some LINs in the LMDB that are lowercase.*/
data lmdb_sub_columns (keep=LIN REPLACED_by1 REPLACED_by2 REPLACED_by3 REPLACED_by4 REPLACED_by5 
		REPLACES1 REPLACES2 REPLACES3 REPLACES4 REPLACES5 transvar rename=(REPLACED_by1=REPLACED_by_1 REPLACED_by2=REPLACED_by_2 REPLACED_by3=REPLACED_by_3 
        REPLACED_by4=REPLACED_by_4 REPLACED_by5=REPLACED_by_5 REPLACES1=REPLACES_1 REPLACES2=REPLACES_2 REPLACES3=REPLACES_3 REPLACES4=REPLACES_4 REPLACES5=REPLACES_5));
	set lmdb.lmdb_&LMDB_MONTH;

	transvar = 1;

	lin = upcase(LIN);

	if REPLACED_by1 ne '' or REPLACED_by2 ne '' or REPLACED_by3 ne '' or 
		REPLACED_by4 ne '' or REPLACED_by5 ne '' or REPLACES1 ne '' or 
		REPLACES2 ne '' or REPLACES3 ne '' or REPLACES4 ne '' or REPLACES5 ne '';
run;

/*Here we sort the previous data set by LIN so that it can be transposed*/

proc sort data = lmdb_sub_columns nodupkey; by lin; run;

proc transpose data = lmdb_sub_columns out = subrules_no_date_or_source;
	by lin;
	id transvar;
	var REPLACED_by_1 REPLACED_by_2 REPLACED_by_3 REPLACED_by_4 REPLACED_by_5 
			REPLACES_1 REPLACES_2 REPLACES_3 REPLACES_4 REPLACES_5 
			;
run;

/*Now we filter out any empty values as this indicates that a 
relationship does not exist; assign a date based on type of sub-rule
this will be used to define the authority that the rule exists under.*/
data filter_nulls;
	set subrules_no_date_or_source;

	length RUN_ID $ 12;

	if _1 ne '';

	_1 = upcase(_1);

	length date 8;
	format date date9.0;

	if _name_ in ('REPLACED_by_1', 'REPLACED_by_2', 'REPLACED_by_3', 'REPLACED_by_4', 'REPLACED_by_5') then do;
		date = '30SEP2017'd;
	end;

	else if _name_ in ('REPLACES_1', 'REPLACES_2', 'REPLACES_3', 'REPLACES_4', 'REPLACES_5') then do;
		date = '30SEP2019'd;
	end;
/*	else if _name_ = "ZLIN" then do */
/*			date = '30SEP2018'd;*/
/*	end;*/
	else do;
		date = '29SEP2017'd;
	end;

	RUN_ID = "LMDB_&LMDB_MONTH";
run;

/*The sql query here selects the minimum date observed for any 
lin-sublin combination. this will ensure all of the subrules
are distinct and references the highest authority that has blessed
off on the substitution rule.*/

proc sql;
	create table sub_rules_f1 as
	select distinct
		RUN_ID,
		lin,
		_1 as SUBLIN,
		min(date) as START_DT
	from filter_nulls
	group by lin, _1;
quit;

proc sql;
	insert into sub_rules_f1
	select distinct
		RUN_ID,
		_1 as LIN,
		LIN as SUBLIN,
		min(date) as START_DT
	from filter_nulls
	group by lin, _1;
quit;

proc sql;
	insert into sub_rules_f1
	select
		run_id,
		AUTH_LIN as lin,
		SUB_LIN as sublin,
		start_dt
	from sb_700_20_appxH;
quit;

proc sql;
	create table sub_rules_f2 as
	select distinct
		RUN_ID,
		lin,
		SUBLIN,
		min(start_dt) as START_DT
	from sub_rules_f1
	group by lin, sublin;
quit;

/*** Added where stmt to exclude LINS with mod levels less than 3 per Aria 9/23/22 ******/

proc sql;
	create table join_mca_to_lin as
	select
		a.*,b.major_capability_name as lin_mca
	from sub_rules_f2 as a left join lmdb.lmdb_&LMDB_MONTH as b
	on a.lin = b.lin
   where b.mod_level>2;
quit;

proc sql;
	create table join_mca_to_sublin as
	select
		a.*,b.major_capability_name as sublin_mca
	from join_mca_to_lin as a left join lmdb.lmdb_&LMDB_MONTH as b
	on a.sublin = b.lin
    where b.mod_level>2;
quit;

/*Now we will create the LIN-Sublin subrules for the run, assign a start_dt,
end_dt and unsub_date. The start_dt must be earlier than the scenario start
date of the SRAM run we plan to execute.*/

data lmdb.subrules_final;
	set join_mca_to_sublin;
	length SOURCE $ 10 ;
	if start_dt = today() then source = "1-SB_70_20";
	else if START_DT = '29SEP2017'd then SOURCE = "1-SB_700_20";
	else if START_DT = '30SEP2019'd then SOURCE = "3-REPLACES";
	else SOURCE = "4-REPLACED";

	if sublin_mca = '' OR LIN_MCA = '' OR (sublin_mca = lin_mca);

run;


/***************Above Code beginning REQ and OH info match last run TAEDP without shortages***************/
/**********************************RUN Bucket Pour********************************************************/
/******************* Insert Code to position ERC P shortage to be filled first ***************************/
/******************* Apply penalty when ERC A shortages are filled before ERC P***************************/
/****************************This code is used like a DARPL priority**************************************/
/*****************************************April 2024 Optimization code removed****************************/
%include "&code_path\make_index_sets_v2.sas";
%include "&code_path\Optimization_SubModule.sas";
%include "&code_path\generate_reports_NGRER_new.sas";/*generates the datasets that will feed reports and charts*/
%include "&code_path\NGRER_Summary_reports.sas";



file name: NGRER_Optimization_main.sas

**************************************************************************************************************************
***************************************NGRER RECODE 3/19/2024*************************************************************
**************************************************************************************************************************
;
options symbolgen MLOGIC MLOGICNEST mprint mlogic MPRINTNEST MAUTOSOURCE SYMBOLGEN SPOOL FULLSTIMER minoperator mindelimiter=',';
OPTIONS FORMCHAR="|----|+|---+=|-/\<>*";
options dlcreatedir;


data _null_;
	call symputx("xdate", put(today(),date9.));
	call symputx("i_start_time", put(time(),time12.2));
/*	i_start_time = time();*/
run;

%put &xdate;
%put &i_start_time;
%let current_cycle = FY25;
%let prior_cycle = FY24;

%let SUBVER = ;
%let subs_allowed = ;

%let SSO_update = 0;	/* This should be set to 0 until the SSO has update parity lins procurements and requirements*/


%let USE_SUB = 1;	/* This should be set to 1 to use Army regulation substitutions.  However, if set to 0 no substitution will be counted towards On Hands*/
/*parameter that enable subs 
1 -> Subs are Allowed
0 -> Subs are NOT Allowed*/
    %let SUBVER = _SUBS;
	%let subs_allowed = 1;

/*  %let xdate=19SEP2022;*/

%put &SUBVER;
*%let SAS_DATA_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\CODE;
*%let DATA_Output_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Output;
*%let DATA_Input_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Input;

%let CODE_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\CODE;
%let DATA_Output_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Output;
%let DATA_Input_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input;
%let ASRA_Reports_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Output\&xdate._NGRER_OPT_Reports&SUBVER;

%let Deliverables_Path = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Output\&xdate._NGRER_OPT_Deliverables&SUBVER.;

%let SAS_DATA_PATH = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._&SUBVER;

%let DARPL_PATH =  O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input;

%let version = ;

data _null_;
	if month(today()) < 10 then call symput('min_date',year(today()));
	else call symput('min_date',year(today()) +1);
run; 

%let current_fy = &min_date;

%let LastPOM_YR = %eval(&min_date + 6);
%let FirstPOM_YR = %eval(&min_date + 2);
%let Previous_YR=%eval(&min_date -1);

%put &FirstPOM_YR;
%put &LastPOM_YR;
%put &current_fy;

%LET Y1 = &current_fy;
%LET Y2 = %eval(&current_fy + 1);
%LET Y3 = %eval(&current_fy + 2);
%LET Y4 = %eval(&current_fy + 3);
%LET Y5 = %eval(&current_fy + 4);
%LET Y6 = %eval(&current_fy + 5);
%LET Y7 = %eval(&current_fy + 6);
%LET sht_Y1 = %substr(&Y1,3,2);
%put &sht_Y1;
%LET sht_Y7 = %substr(&Y7,3,2);
%put &sht_Y7;

%let date_range =(&Y1 &Y2 &Y3 &Y4 &Y5 &Y6 &Y7);
%let date_list = (&Y1 &Y2 &Y3 &Y4 &Y5 &Y6 &Y7);
%let date_range2 =(&Y1 &Y2 &Y3);
%let date_range3 =(&Y4 &Y5 &Y6 &Y7);

Libname compo "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._StudyData"; 
Libname DARPL "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._DARPL_SUBS"; 
libname PARP "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY25\Input\&xdate._PARP";
libname Results "&Data_Output_Path";
libname Data "&ASRA_Reports_Path";
libname Outputs "&Data_Output_Path";
libname LMDB "&Data_Input_Path";
libname Deliver "&Deliverables_Path";

%let varlist = S_OH E_OH REQ ASSIGN SHORT EXCESS EOH Shortage_Cost Excess_Cost;
%let varnum = %eval(%sysfunc(countw(&varlist%str( ))));
%put &varnum;
%let liblist = PARP DARPL;
%let libnum = %eval(%sysfunc(countw(&liblist%str( ))));
%put &libnum;

%let ResultsFile = &xdate._ASRA_DARPL_Report.xlsx;
%let FM_date = 202508;
/*%let FinMgmtFile = AE2S_CURRENT_POSITION_&FM_date..csv;*/
%let FinMgmtFile = AE2S_CURRENT_POSITION_2025-08-11;

%let date_fmt = yymmdd10.;

/*%let folder = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\ASRA\Bucket_Pour\Q2FY21\Model Output Results;*/
%let run_control=&xdate._Linked_Excel_Input_to_PPT_Shell_Q2FY21_SUBS.xlsx;

/* These macro variables define the sets of inventory that are considered unserviceable or obsolete. */
%let unserviceable = ('H', 'P', 'S'/*, 'U'*/) /*based on Condition Code*/;
%let obsolete = ('S','O') /*based on LCC Code*/;

/*SACS FILE DATA PARAMETERS*/
%let sacs_h_index = cla_header_roll18-aug-25.txt;
%let sacs_e_index = cla_eqpdet_roll18-aug-25.txt;
%let delimter = '09'x;

/*SACS FILE DATA PARAMETERS*/
%let DARPL_NEW24 = &DATA_Input_Path.\CUI_20241125_RPT_DARPL_RELEASE_FY26.xlsx; 
/*%let DARPL_NEW25 = &DATA_Input_Path.\DARPL FY2025 Update.xlsx; */


%LET USE_AUTH = 1;

/*DST Data and Procurement File DATA PARAMETERS*/

%let USE_DST = 1;	/* This should be set to 0 to use procurements in the Financial Management File.  However, set to 1 if it is requested to use LMI trensfers for two year before the POM*/
%let dst_file_name = LMI_DST_PSDs 8-7-25;
%let use_unitsum = 0; /* This should be set to 0 to use the sacs header file for matching typco data to units in the DST file must have latest unit_summary file to set to 1 */

/*Inventory LDAC DST Date  DATA PARAMETERS*/
%LET Use_csv = 0; /* This should be set to 0 when using the xlsx version of LDAC file drop;  CSV versions would be named DST&DATE_1.csv,,,etc. */ 
%LET LDAC_NAME=AE2S_LIN_DATA_G8_NIIN_File_;
%LET DSTDATE=20250811; /* Date of LDAC inventory file regardless of excel vs csv format  */

%let sb_date = SB_700_20_CHAPTERS_2025-08-11;

%let lmdb_month = Aug2025;
%let lmdb_file2 = LINS_ACTIVE_2025-08-11;

%let use_sso_scrub = 1;

/*Macro variables below are specific to the optimization module and parameters  */
%let std_time = ;
%let run_time = ;
%let run_level = D_UIC;
%let RUN_NAME = &xdate._&current_cycle._ASRA_optimization;
%let MAX_DATE = &LastPOM_YR;

libname IDM "&SAS_DATA_PATH";

%let idm_input = &SAS_DATA_PATH.\OPT_Input;
%let idm_output = &SAS_DATA_PATH.\OPT_Output;


%let model_base = Optimization_SubModule.sas;

/*Allows a user to identify a modified LIN cluster set*/
%let cluster_tag = ;

/*Allows a user to run the the input processing for the model
	1 = Run ALL Inputs
	Any other value will not run the clusters*/
%let run_all_inputs = 1;

/*If the Run All Inputs toggle is turned on
this will allow a user to run the cluster code if necessary
	1 = Run Clusters
	Any other value will not run the clusters*/
%let run_cluster = 1;

/*Allows a user to run the model if ready 
	1 = Run Model
	Any other value will not run the model
The Single Component parameter will also let a user run 
	an individual component to troubleshoot any 
	annomaly in the run. If this number is above
	0 then the model will process only that
	component.*/
%let run_model = 0;
%let single_component = 0;

%let NGRER_RUN_TOGGLE = 0;
/*First year when Intercomponent transfers are permitted*/
%let CASC_YEAR = &FirstPOM_YR;
/*Allows for the use of DST Data when this is set to 1*/
%let USE_DST = 1;

%let log_name = &xdate._&current_cycle._ASRA_STD_100_Percent_v7;

/*Added a parameter to allow a user to show the Log while the data runs rather than
outputting it to a text file. This is generally run in unison with 
running a single component to troubleshoot*/
%let show_log = 0;

/*parameter that ensures only subs where the sublin is as, or more modern, than the required lin are allowed
1 -> This is turned on always for NGRER
0 -> All subs are allowed unless otherwise specified should always be 0 for ASRA runs*/
%let modern_subs = 1;

%let lin_list = "ALL";
%let t_filter = ('1','2','3');

%let unit_yearly_xfer_pen = .01;

%let fix_flex = 1;

/*Adding in a parameter to freeze the first two years of the inventory*/
%let freeze_first_two = 1;

/*Adds a parameter that allows for the usage of LMI data - if the toggle is turned on to 1 then
it will be use and the equipfor data will be ignored, otherwise it wont be used and the equipfor data 
won't be used*/
%let use_lmi = 1;
libname idm_i "&idm_input";

libname idm_o "&idm_output";


data idm_i.i_start_time;

	call symputx("start_time", put(time(),time8.0));
	obs = 1;
	i_start_time = time();
run;
%put &start_time;

/*DARPL : THIS IS USED IN THE FORMATTING.SAS FOR THE FDA_UIC FILE*/

PROC IMPORT OUT= lmdb.lmdb_&lmdb_month
    DATAFILE= "&DATA_Input_Path.\&lmdb_file2" 
    DBMS=xlsx REPLACE;
	Sheet= "LINS_Active";
    GETNAMES=YES;
    DATAROW=2; 
RUN;

proc sort data=lmdb.lmdb_&lmdb_month out=results.Army_study_BOS(keep=Portfolio) nodupkey ;
  by Portfolio;
run;

proc sort data=lmdb.lmdb_&lmdb_month out=results.Army_study_LIN_BOS(keep=LIN Portfolio SSO_OFFICE_SYMBOL rename=SSO_OFFICE_SYMBOL=OFFICE_SYMBOL) nodupkey ;
  by LIN Portfolio SSO_OFFICE_SYMBOL;
run;

%LET NUM_STUDY_BOS = 0;

data Army_study_BOS;
set results.Army_study_BOS;
where Portfolio ne ' ' ; 
run; 

PROC SQL NOPRINT;	
	SELECT
		COUNT(Portfolio) INTO :NUM_STUDY_BOS
	FROM Army_study_BOS;

	select distinct cats("'", Portfolio , "'")
		into :Army_study_BOS separated by  ' ,' 
	FROM Army_study_BOS;
QUIT;

%put &Army_study_BOS;
%put &NUM_STUDY_BOS;

**************************Import DARPL Info *****************************************************************************;
%let new_darpl_yr =2025;
 
PROC IMPORT DATAFILE = "&DARPL_NEW24" OUT = Unit_Priority
	DBMS = XLSX REPLACE;
	GETNAMES = YES;
    DATAROW=2; 
RUN;
  

/****************************Import SACS Requirements*************************************************************/


%macro pull_SACS_files(inpath, sacs_h_index, sacs_e_index); 
/*Initialization of the current fY macro variable*/

%put &current_fy;

data equipment_details;
	length
		RUNID 6 UIC $ 6 EDATE 8 LIN $ 6 ERC $ 1 RMK1 $ 3 RMK2 $ 3 RQEQP 8 AUEQP 8 RQBOI 8 AUBOI 8 SORCE 5 MDUIC $ 2;

	infile "&DATA_Input_Path.\&sacs_e_index"
		firstobs= 2
		dlm = &delimter
		missover
		dsd;
	input
		RUNID  UIC $  EDATE  LIN $  ERC $  RMK1 $  RMK2 $  RQEQP  AUEQP  RQBOI  AUBOI  SORCE  MDUIC $;
run;

%LET NUM_STUDY_UICS = 0;

proc sql;
  create table STUDY_UICS AS
     select distinct 
	   UIC
	 from equipment_details
	 order by UIC;
quit;

PROC SQL NOPRINT;	
	SELECT
		COUNT(UIC) INTO :NUM_STUDY_UICS
	FROM STUDY_UICS;
QUIT;


/*This data statement reads in the UIC header file code mapping through the use of 
	that an infile statement that reads the .csv file. This file contains all of the SAMAS based data that is used
	to refere to a unit, its location, what MACOM it reports to, and many other fields. The code also
	comptues the type of units that are either ABCTs, HBCTs, IBCTs, SBCTs, or CABs; what
	theater the unit is in; and corrects the station codes to enable the joing to the earlier station
	code mapping. */
data compo.uic_header_details;

length
		RUNID 8 UIC $ 6 EDATEI 8 TPSN $ 5 MACOM $ 2 ACTCO $ 1 ADCCO $ 1 MDEP $ 4 
		COMPO $ 1 UNTDS $ 21 CARSS $ 2 TYPCO $ 1 UNMBR $ 4 FPA $ 1 DAMPL $ 5 SRC $ 9 ALO $ 3 
		SRCPARA $ 2 ASGMT $ 2 LOCCO $ 3 AMSCO $ 8 BRNCH $ 2 CCNUM $ 6 DOCNO $ 11 DPMNT $ 1 ELSEQ $ 2 
		FORCO $ 1 MBCMD $ 1 MBLOC $ 1 MBPRD $ 1 MBSTA 8 MTOEC $ 6 NTREF $ 1 PHASE $ 1 ROBCO $ 4 ROC $ 3 
		STACO $ 5 TDATE 8 ULCCC $ 3 UTC $ 5 COP_BDE_TYPE $ 4 THEATER $ 10;

			infile "&DATA_Input_Path.\&sacs_h_index"
		firstobs= 2
		dlm = &delimter
		missover
		dsd;

	input
		RUNID  UIC $  EDATEI  TPSN $  MACOM $  ACTCO $  ADCCO $  MDEP $  
		COMPO $  UNTDS $  CARSS $  TYPCO $  UNMBR $  FPA $  DAMPL $  SRC $  ALO $  
		SRCPARA $  ASGMT $  LOCCO $  AMSCO $  BRNCH $  CCNUM $  DOCNO $  DPMNT $  ELSEQ $  
		FORCO $  MBCMD $  MBLOC $  MBPRD $  MBSTA  MTOEC $  NTREF $  PHASE $  ROBCO $  ROC $  
		STACO $  TDATE  ULCCC $  UTC $ COP_BDE_TYPE $ THEATER $;

 run;
/*The SQL statement below handles any duplicate UIC-EDATE pairings and brings in the data we will
need in the follow on SQL joins*/
proc sql;
	create table core_uic_header_data as
	select distinct
		b.UIC,
		b.edatei as EDATE,
		B.SRC,
		b.COMPO,
		b.TYPCO,
		b.TDATE,
/*		b.TPSN,*/
/*		b.MACOM,*/
		b.DAMPL,
/*		b.BRNCH,*/
/*		b.STACO,*/
/*		b.COP_BDE_TYPE,*/
/*		b.THEATER,*/
/*		b.ASGMT,*/
		B.UNTDS
	from compo.uic_header_details as b;
quit;


/*The sql statement below performs a left join from the LIN equipment and 
	brings in fields that traditionally appear on the FDA_UIC_OUT file.
	The reassignment of DAMPL to DARPL is to remain consistent with the format of the
	data but we should be aware as analyst that this is the DAMPL and not the DARPL.
	The DARPL is a classifed data element and does not belong on this unclassified file*/

proc sql;
	create table equipment_join_header as
	select
		a.*,
		b.COMPO,
		b.TYPCO,
		b.TDATE,
/*		b.TPSN,*/
/*		b.MACOM,*/
		b.DAMPL as DARPL,
/*		b.BRNCH,*/
/*		b.STACO,*/
/*		b.COP_BDE_TYPE,*/
/*		b.THEATER,*/
/*		b.ASGMT,*/
		B.SRC,
		B.UNTDS
	from equipment_details as a left join core_uic_header_data as b
		on a.edate = b.edate and a.uic = b.uic;

/*  where lin in (&SUBSET_lins);*/
  
quit;


proc sql;
	create table study_lins as
	  select distinct
	  	LIN
	  from equipment_join_header
	  order by lin;
quit;

%LET NUM_STUDY_LINS = 0;

data STUDY_LINS;
set STUDY_LINS;
where lin ne ' ' ; 
run; 

PROC SQL NOPRINT;	
	SELECT
		COUNT(LIN) INTO :NUM_STUDY_LINS
	FROM STUDY_LINS;

	select distinct cats("'", lin , "'")
		into :STUDY_LINS separated by  ' ,' 
	FROM STUDY_LINS;
QUIT;

%put &study_lins;


/*Filters out UICS without requirements.  UIC without requirement and and large inventory were not observed to fill Army shortages over time in reality */
proc sql;
	create table equipment_join_header2 as
	select
		a.*
	from equipment_join_header as a /*inner join STUDY_UICS as b
	on a.uic = b.uic*/;
quit;


/*Filters out LINS without procurements.  LINs with no procurements will not change regards to OH, shortages or EOH   */
proc sql;
	create table equipment_join_header3 as
	select
		a.*
	from equipment_join_header2 as a /*inner join STUDY_LINS as b
	on a.lin = b.lin*/;
quit;

%mend pull_SACS_files;

%pull_SACS_files(&Data_Input_Path, &sacs_h_index, &sacs_e_index);


*************************Import Procurement Info**************************************************************************;

PROC IMPORT OUT= fdiis_lqa
    DATAFILE= "&DATA_Input_Path.\&FinMgmtFile" 
    DBMS=xlsx REPLACE;
	Sheet= "AE2S_CURRENT_POSITION";
    GETNAMES=YES;
    DATAROW=2; 
RUN;

************************Import Inventory Info****************************************************************************;
%macro import_inventory;
	  %macro load_xls_inventory(j);
		PROC IMPORT OUT= DST_DATA_&j
		    DATAFILE= "&DATA_Input_Path.\&LDAC_NAME.&DSTDATE..xlsx" 
		    DBMS=xlsx REPLACE;
			Sheet= "Sheet &j";
		    GETNAMES=YES;
		    DATAROW=2; 
		RUN;
	  %mend load_xls_inventory;
	  
	  	%do j = 1 %to 3;
		   %load_xls_inventory(&j);
		%end;
	
	PROC SQL;
		CREATE TABLE compo.Initial_inventory AS 
			SELECT * FROM DST_DATA_1
			 OUTER UNION CORR 
			SELECT * FROM DST_DATA_2
			 OUTER UNION CORR 
			SELECT * FROM DST_DATA_3
			;
	Quit;
%mend import_inventory;

%import_inventory;

****************************Import SB 700 File*************************************************************************;
/*PROC IMPORT OUT= SB_700_20*/
/*    DATAFILE= "&DATA_Input_Path.\&sb_date" */
/*    DBMS=CSV REPLACE;*/
/*	Sheet= "SB_700_20_CHAPTERS";*/
/*    GETNAMES=YES;*/
/*    DATAROW=2; */
/*RUN;*/
PROC IMPORT DATAFILE = "&DATA_Input_Path.\SB_700_20_CHAPTERS_2025-08-11.xlsx" OUT = SB_700_20
    DBMS=XLSX REPLACE;
	GETNAMES = YES;
    DATAROW=2; 
RUN;
****************************Import DST Info****************************************************************************;
proc import out = dst_data
			datafile = "&DATA_Input_Path.\LMI_DST_PSDs 8-7-25.xlsx"
    DBMS=XLSX REPLACE;
    GETNAMES=YES;
    DATAROW=2; 
run;

***************************Import Substitution Rules info****************************************************************;
proc import out = sb_700_20_appxH
			datafile = "&DATA_Input_Path.\SB_700_20_APPENDIX_H_2025-08-11.xlsx"
    DBMS=XLSX REPLACE;
    GETNAMES=YES;
    DATAROW=2; 
run;


/*data sb_700_20_appxH;*/
/*	length*/
/*		lin $ 6*/
/*		lin_name $ 255*/
/*		sublin $ 6*/
/*		sub_name $ 255;*/
/*		*/
/*	infile "&DATA_Input_Path.\SB_700_20_APPENDIX_H.csv"*/
/*		firstobs = 2*/
/*		missover*/
/*		dlm = ','*/
/*		dsd;*/
/*	input*/
/*		lin $ lin_name $ sublin $ sub_name $;*/
/*run;*/

****************************DARPL Priority File for UIC Priority from first POM year though 5th POM year*****************;



data Unit_Priority2 (keep=DARPL_RANK UIC COMPO rename=(DARPL_RANK=PRIORITY));
  set Unit_Priority;
  
RUN;

data Unit_Priority_temp;
  set Unit_Priority2;
  do FY=2025 to 2031;
  output;
  end;
run;

proc sort data=Unit_Priority_temp out=Unit_Priority; by FY PRIORITY; run;


/*data Unit_Priority2 (keep=FY DARPL_RANK UIC COMPO rename=DARPL_RANK=PRIORITY);*/
/*  set Unit_Priority2;*/
/*  */
/*RUN;*/

/*%LET MAX_DARPL_YR = 0;*/
/**/
/*PROC SQL NOPRINT;	*/
/*	SELECT*/
/*		MAX(FY) INTO :MAX_DARPL_YR*/
/*	FROM Unit_Priority2;*/
/*quit; */
/**/
/*%put &MAX_DARPL_YR;*/
/**/
/*%macro insert_darpl_years;*/
/*	data darpl_base;*/
/*		set Unit_Priority2;*/
/*		if FY = &MAX_DARPL_YR;*/
/*	run; */
/*	%do i=0 %to %eval(&MAX_DARPL_YR - &current_fy);*/
/*	   %let curr_yr = %eval(&current_fy + &i);*/
/*	   %if &curr_yr = &new_darpl_yr %then %do;*/
/*	   %end;*/
/*	   %else %do;*/
/*			data darpl_addFY&curr_yr;*/
/*				set Unit_Priority;*/
/*				IF FY = &curr_yr;*/
/*			run;*/
/**/
/*			proc append base=darpl_base data=darpl_addFY&curr_yr;*/
/*			run;*/
/*		%end;*/
/*	%end;*/
/*%mend insert_darpl_years;*/
/**/
/*%macro add_darpl_years;*/
/*	data darpl_lastyr;*/
/*		set darpl_base;*/
/*		if FY = &MAX_DARPL_YR;*/
/*	run; */
/*	%do i=1 %to %eval(&LastPOM_YR - &MAX_DARPL_YR);*/
/*	   %let new_yr = %eval(&MAX_DARPL_YR + &i);*/
/*		data darpl_addFY&new_yr;*/
/*			set darpl_lastyr;*/
/*			FY = &new_yr;*/
/*		run;*/
/**/
/*		proc append base=darpl_base data=darpl_addFY&new_yr;*/
/*		run;*/
/*	%end;*/
/*%mend add_darpl_years;*/
/**/
/**/
/*%macro run_darpl_years;*/
/*	%insert_darpl_years;*/
/*	%if &MAX_DARPL_YR LT &LastPOM_YR %then %do;*/
/*		%add_darpl_years;*/
/*	%end;*/
/*%mend run_darpl_years;*/
/**/
/*%run_darpl_years;*/
/**/

data DARPL_PRIORITY1;
  set unit_priority;
run;

proc sql;  
	insert into DARPL_PRIORITY1 
	   	set 	FY=2025,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2025,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2025,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2025,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set 	FY=2026,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2026,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2026,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2026,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set 	FY=2027,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2027,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2027,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2027,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set	FY=2028,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2028,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2028,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2028,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
        	set FY=2029,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2029,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2029,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2029,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2030,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2030,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6
		set FY=2031,
		PRIORITY=1,
		UIC='UICIN1',
		compo=1
		set FY=2031,
		PRIORITY=1,
		UIC='UICIN2',
		compo=2
		set FY=2031,
		PRIORITY=1,
		UIC='UICIN3',
		compo=3
        	set FY=2031,
		PRIORITY=1,
		UIC='UICIN6',
		compo=6;
		
quit;  

data compo.DARPL_PRIORITY1;
  set DARPL_PRIORITY1;
run;
**************************************************************************************************************************
**************************************AUTHORATATIVE INPUT FILES FOR COMPO Split MODELS ***********************************
*************************************AUTHORATATIVE SOURCES ARE Inventory (latest ARCOP Pull)******************************
*************************************LMI DST Extract from AESIP (Provides projected transfers*****************************
*******************************************from Inventory pull until the first POM year***********************************
****************************Latest POM LQA file (Programmed LIN procurement quanities by YEAR by ROOT/BOS/APE*************
**************************************************************************************************************************/;

****************************SACS Equipment Detail (Unit REQS) and Unit Details files (UIC Compo Acto)********************;

%macro create_out_years(inset, num_years);


/*Initialization of a counter variable that will be used
to terminate the do-while loop once it exceeds the number 
of years specified by the input variable num_years*/
	%let i = 0;

	/*Entrance into teh Do-While loop*/
	%do %while  (%eval(&i) <= %eval(&num_years));

	/* assignment of the fiscal year we are processing based on 
	the global macro variabel initialized in the first data
	statement and the number of iterations that we've gone though the loop*/
	%let processing_fy = %eval(&current_fy + &i);

	/* data step to creat the requirement file in the year that we are 
	processing. Once this macro terminates there a data set labeled with 
	each fiscal year processed*/
	data FY_EQUIP_REQS_&processing_fy;
		set &inset;
		
		length FY $ 4;

		/*Per the guidance we are filtering on data where the EDATE >= September 30th, of the FY and where 
		the TDATE is <= October 1st of the FY. To compute this in the same format as the 
		EDATE and TDATE we multply the Fiscial year by 1000 and add 930 to it for the EDATE filter and
		add 1001 to the TDATE filter. For example if we are processing fiscal year 2019 the equations below 
		would result in:
			2019 * 10000 = 20190000  + 930 = 20190930
			and
			2019 * 10000 = 20190000 + 1001 = 20191001
		where this date is in the YYYYMMDD format*/
		if edate <= ((&current_fy. + &i.) * 10000 + 930) and tdate >= ((&current_fy. + &i.) * 10000 + 1001) then
			FY = &current_fy. + &i.;

		/* Filters out FYs that are unassigned and drills down to the fiscal year being processed*/
		if FY ne "";

		/*Declaration of derivative uic*/
		IF MDUIC NE '' THEN UIC = SUBSTRN(UIC,1,4) || MDUIC;

		IF SUBSTRN(MDUIC,1,1) = 'X' THEN COMPO = 1;
		ELSE IF SUBSTRN(MDUIC,1,1) = 'G' THEN COMPO = 2;
		ELSE IF SUBSTRN(MDUIC,1,1) = 'R' THEN COMPO = 3;

	run;

	/* If we are in the first iteration of the loop we'll create the base 
	data set we will append all of the upcoming data sets to.*/
	%if &i = 0 %then %do;
		data ALL_LIN_REQS;
			set FY_EQUIP_REQS_&processing_fy;
			if typco ne '3';
			if rqeqp > 0;
		run;
	%end;
	/* if we are not in the first iteration of the do-while loop then we will append the processed data
	to the primary table "ALL_LIN_REQS"*/
	%else %do;
		
		proc append base = compo.ALL_LIN_REQS data = FY_EQUIP_REQS_&processing_fy;
		run;
	%end;
	/*Now we'll update the counter variable and proceed to the next iteration of the do-while loop 
		or terminate when i is not less than or equal to the num_years specified*/
	%let i = &i +1;

	
	%end;
%mend;

/*here we call the macro and this will run it through the data set specified and the number
of years we want to produce*/
%create_out_years(equipment_join_header3, %eval(&LastPOM_YR - &current_fy));

proc append base = compo.ALL_LIN_REQS data = FY_EQUIP_REQS_2027 force;
		run;
/*This is a sql statement that produced the required and authorized values
by Fiscal year, Compo and LIN.*/
data compo.all_reqs(rename=(rqeqp=req aueqp=auth));
  LENGTH TYPCO_CAT $8;
	set compo.ALL_LIN_REQS;
	if typco ne '3';
	if rqeqp > 0;
	if erc in ("B","C") then erc = "A";
	if compo eq '6' THEN rqeqp = aueqp;  

  	if TYPCO='1' then TYPCO_CAT = "MTOE";
	else if TYPCO='2' then TYPCO_CAT = "AUG-TDA";
    else TYPCO_CAT = "TDA";

run;

proc sql; 
	create table compo.sacs_uic as 
		select distinct FY, Lin, uic, compo, typco, erc, sum (auth) as auth, sum (req) as req 
		from compo.all_reqs
		group by Lin, uic, compo, typco, erc, fy
		ORDER BY Lin, compo, typco, erc, uic, fy;
quit;


proc transpose data=compo.sacs_uic out=compo.sacs_uic_xtab
	prefix = FY
	delimiter = _;
	by LIN COMPO TYPCO ERC UIC;
	id FY;
	var REQ;
run;

proc sql;
   create table compo.uic_typco as
     select distinct 
	   uic,
	   typco
	 from compo.sacs_uic_xtab
	 order by uic;
quit;


data compo.uic_typco;
  set compo.uic_typco;
  LENGTH TYPCO_CAT $8;
  	if TYPCO='1' then TYPCO_CAT = "MTOE";
	else if TYPCO='2' then TYPCO_CAT = "AUG-TDA";
    else TYPCO_CAT = "TDA";
run;


proc sql; 
	create table compo.sacs_compo_erc as 
		select distinct FY, Lin, compo, erc, sum (req) as req 
		from compo.all_reqs
/*		where typco ne '3'*/
/*		where LIN in &lin_list.*/
		group by Lin, compo,erc, fy
		ORDER BY Lin, compo, erc, fy;
quit;


proc transpose data=compo.sacs_compo_erc out=compo.sacs_cmpo_erc_xtab
	prefix = FY
	delimiter = _;
	by LIN COMPO ERC;
	id FY;
	var REQ;
run;

/***** Added code to get distinct LINs from SACs to go in generate_opt_model_inputs.sas per 9/23/22 Aria and Trent *****/

proc sql;
	    create table reqd_lin as
		   select distinct
		      lin
		   from compo.all_reqs;
	quit;

****************************Latest POM LQA file (Programmed LIN procurement quanities by YEAR by ROOT/BOS/APE************;
data fdiis_lqa (drop=compo rename=compo3=compo);
set fdiis_lqa;
   IF BO EQ '1' AND AMOUNT GT 0 AND FY GT &Previous_YR AND Procurement_Type IN ("NEW", "RECAP") AND AMOUNT_TYPE EQ "Quantity" AND LIN_OUT ne "N/A";
   compo3=put(compo,1.);
run;

proc sql;
	create table _fdiis_lqa_prt1 as
	select distinct
		lin_out as LIN,
		COMPO,
		FY,
		sum(Amount) as Qty
	from fdiis_lqa
	group by lin_out, compo, FY
    order by lin_out, compo, FY
;
quit;


data compo._fdiis_lqa_prt1;
set _fdiis_lqa_prt1;
	if Qty = . then Qty = 0;
run;
*******************************************from Inventory pull until the first POM year**********************************;
proc sql; 
create table compo.inventory_filter as
  select 
    A.LIN_NSLIN AS LIN,
    a.Supply_Record as UIC,
	A.*
  from compo.Initial_inventory as a 
  group by A.LIN_NSLIN, A.COMPONENT_CODE
  order by A.LIN_NSLIN, A.COMPONENT_CODE;
quit;


**************************************************************************************************************************
*****Latest SB-700 Data (Used to determine Obsolete/Unserviceable Items by LIN/NIIN LCC and Condition Codes)**************
**************************************************************************************************************************/;

data SB_700_20;
  set SB_700_20;
  NIN = SUBSTRN(NSN,5,9);
run;

proc sql;
  create table sb_700_20_count as
    select distinct
	   LIN,
	   count(LIN) as count
	from SB_700_20
	group by LIN
	order by LIN;
quit;

proc sql; 
	create table  compo.Initial_inventory_pull as
		select distinct  
 			UIC, 
			LIN,
			NIIN_OR_MCN, 
			CONDITION_CODE,
			COMPONENT_CODE,
			sum(on_hand_qty) as qty 
		from compo.inventory_filter
		Group by uic, lin,  NIIN_OR_MCN, CONDITION_CODE, COMPONENT_CODE;
quit; 

data compo.INITIAL_INVENTORY_PULL(drop=COMPONENT_CODE);
	set  compo.INITIAL_INVENTORY_PULL; 
	if substrn(uic,5,1) in ('X','G','R') and substrn(uic,5,2) notin ('X1','X0','G1','G0','R1','R0') then uic = uic;
	else if substrn(uic,1,1) = "W" and substrn(uic,5,2) notin ('99','98') then uic = substrn(uic,1,4)||"AA";
	compo = put(COMPONENT_CODE,1.);
     /* Below removes non standard LINs & splits out depot inventory added 24JUN2021 -LBurdette*/
    IF LENGTHC(COMPRESS(SUBSTRN(LIN, 2,5), '', 'kd'))=5 or SUBSTRN(LIN, 4,2) = 'FD';
	if length(uic) ne 6 then uic=cats('FACOT',COMPONENT_CODE);  /* outputs inventory held by Depots */
run;

proc sql;
	create table compo.join_lin_inv_to_units_prep as
	select distinct 
 		a.UIC, 
		a.LIN,
		a.NIIN_OR_MCN, 
/*		a.COMPONENT_CODE,*/
		a.CONDITION_CODE,
		sum(a.qty) as qty, 
/*	 	B.LCC,*/
		a.compo
	from compo.INITIAL_INVENTORY_PULL as a 
	group by UIC, LIN, NIIN_OR_MCN, /*COMPONENT_CODE,*/ CONDITION_CODE, compo
    ORDER BY a.LIN, compo;
quit;

/*DEPENDENT ON SACS HEADER FILE FROM REQUIREMENT PROGRAM */
proc sql;  
	create table core_uic_header_data2 as
	select distinct 
 	 	UIC,
		compo,
		typco
		from core_uic_header_data
		where typco ne '3'
		order by UIC;
quit;

 proc sql;  
	insert into core_uic_header_data2 
	   set UIC='FACOT1',
	     typco='1',
		 compo='1'
  	   set UIC='FACOT2',
	     typco='1',
		 compo='2'
	    set UIC='FACOT3',
	     typco='1',
		 compo='3'
		  set UIC='FACOT6',
	     typco='1',
         compo='6';
quit;  

/*DEPENDENT ON THE OTHER InpUTS FROM SECTION ABOVE */
proc sql;  
	create table compo.join_lin_inv_to_units_prep2 as
	select distinct 
 		a.UIC, 
		a.LIN,
		a.NIIN_OR_MCN, 
/*		a.COMPONENT_CODE,*/
		a.CONDITION_CODE,
		a.qty, 
	 	B.LCC,
		c.typco,
		coalesce(a.compo,c.compo) as compo
	from compo.join_lin_inv_to_units_prep as a 
	LEFT JOIN SB_700_20 AS B ON A.LIN = B.LIN  AND  A.NIIN_OR_MCN = B.NIN
	FULL OUTER JOIN core_uic_header_data2 as c on a.uic = c.uic
    ORDER BY a.LIN, compo;
quit;


data obsolete LIN_INV unserviceables;
	set compo.join_lin_inv_to_units_prep2;
    if LIN ne ''; 
	if lcc in &obsolete  then output obsolete;
	else if condition_code in &unserviceable then output unserviceables;
	else output LIN_INV;
run;

proc sql;
	create table compo.inventory_by_uic as
	select distinct 
		a.LIN,
		a.compo,
 		a.UIC, 
		sum(qty) as qty 
	from LIN_INV as a 
	group by lin, compo, uic
    ORDER BY a.LIN, compo, uic;
quit;

proc sql;
	create table compo.inventory_by_uic as
	select 
		a.* 
	from compo.inventory_by_uic as a
/*	inner join study_uics as b on a.uic=b.uic */
    ORDER BY a.LIN, a.compo;
quit;

proc sql;
	create table compo.inventory_by_compo as
	select distinct 
		a.LIN,
		a.compo,
		sum(a.qty) as qty 
	from compo.inventory_by_uic as a 
	group by lin, compo
    ORDER BY a.LIN, compo;
quit;

*************************************LMI DST Extract from AESIP (Provides projected transfers****************************;
data fy_adjust;

set dst_data;
 
	suspense_date1=input(suspense_date,date11.);
	
	if month(suspense_date1) >=10 then suspense_fy = year(suspense_date1) + 1;
	else suspense_fy = year(suspense_date1);

	newnum = input(validated_quantity, COMMA10.);
	drop validated_quantity;
	rename newnum = validated_quantity;

run;

proc sql;
	create table dst_sum_to_uic as
	select distinct

		from_compo, to_compo, from_code, to_code, from_pb_lin, to_pb_lin, catalog_lin, source_niin as sourcing_niin, suspense_fy, sum(validated_quantity) as validated_quantity

	from fy_adjust
	group by 
	from_compo, to_compo, from_code, to_code, from_pb_lin, to_pb_lin, catalog_lin, source_niin, suspense_fy;
quit;

proc transpose data = dst_sum_to_uic out = dst_xtab_date;
	by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
	id suspense_fy;
	var validated_quantity;
run;

proc sql;
	create table sum_lin_inv_to_lin_niin as
	select distinct
		uic as owner,
		lin,
		niin_or_mcn as niin,
		sum(qty) as qty
	from LIN_INV
	group by 
		uic, lin, niin_or_mcn;
quit;

proc sql;
	create table join_unit_level_inv_to_dst as
	select 
		a.*, b.qty as qty_avail
	from dst_xtab_date as a left join sum_lin_inv_to_lin_niin as b
	on a.from_code =b.owner and a.catalog_lin = b.lin and a.sourcing_niin = b.niin;
quit;

data check_feasibility;
	retain from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin _&Y1. _&Y2. t_transfer qty_avail _&Y1._c _&Y2._c label;

	set join_unit_level_inv_to_dst;
	
	keep from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin _&Y1. _&Y2. t_transfer qty_avail  _&Y1._c _&Y2._c label;

	if length(from_code) = 6 then do;
		if qty_avail = . then qty_avail = 0;
		if _&Y1. = . then _&Y1. = 0;
		if _&Y2. = . then _&Y2. = 0;
		t_transfer = _&Y1. + _&Y2.;

		if qty_avail < t_transfer then do;

			_&Y1._c = min(qty_avail,_&Y1.);
			_&Y2._c = min(qty_avail - _&Y1._c, _&Y2.);
		end;
		else do;
            _&Y1._c = _&Y1.;
			_&Y2._c = _&Y2.;
		end;
	end;
	else do;
	    _&Y1._c = _&Y1.;
		_&Y2._c = _&Y2.;
	end;

	label = "v_qty_capped";

run;

proc sort data = check_feasibility; 
by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
run;

proc transpose data = check_feasibility out = dst_feasible;
	by from_compo to_compo from_code to_code from_pb_lin to_pb_lin catalog_lin sourcing_niin;
	id label;
	var _&Y1._c _&Y2._c;
run;

data reassign_suspense;
	set dst_feasible;

	length suspense_date 8;
	format suspense_date date9.0;

	if v_qty_capped = . then 	v_qty_capped  = 0;
	if _name_ = "_&Y1._c" then suspense_date = "30SEP&Y1."d;
	if _name_ = "_&Y2._c" then suspense_date = "30SEP&Y2."d;

	if v_qty_capped  > 0;

run;


%macro add_typco;
%if &use_unitsum = 1 %then %do;
data unit_detail;
	length
		          UIC $ 6
                  Unit__ $ 4
                  Short_Unit_Desc $ 30
                  Long_Unit_Desc $ 60
                  MACOM $ 10
                  Assig__Cd $ 2
                  OESTS $ 1
                  ODATE__OESTS_ 8
                  CMPO $ 1
                  TPSN $ 5
                  Type_Co $ 1;
	informat ODATE__OESTS_  &date_fmt.;
	format ODATE__OESTS_  &date_fmt.;
	infile "&Data_Input_Path\unit_summary_&unit_date..txt"
		firstobs = 1 
		dlm = '09'x
 		lrecl=32767
		missover
		dsd;
	input
		 UIC $ 
                  Unit__ $ 
                  Short_Unit_Desc $ 
                  Long_Unit_Desc $ 
                  MACOM $ 
                  Assig__Cd $ 
                  OESTS $ 
                  ODATE__OESTS_ :&date_fmt.
                  CMPO $ 
                  TPSN $ 
                  Type_Co $ ;

run;
proc sql;
	create table join_typco_to_donor as
	select distinct
		a.*,
		b.type_co as from_typco
	from reassign_suspense as a left join unit_detail as b on a.from_code = b.uic;
quit;


proc sql;
	create table join_typco_to_claimer as
	select distinct
		a.*,
		b.type_co as to_typco
	from join_typco_to_donor as a left join unit_detail as b on a.to_code = b.uic;
quit;

%end;

%else; %do;
proc sql;
	create table join_typco_to_donor as
	select distinct
		a.*,
		b.typco as from_typco
	from reassign_suspense as a left join compo.uic_header_details as b on a.from_code = b.uic;
quit;


proc sql;
	create table join_typco_to_claimer as
	select distinct
		a.*,
		b.typco as to_typco
	from join_typco_to_donor as a left join compo.uic_header_details as b on a.to_code = b.uic;
quit;
%end;

%mend;

%add_typco;

data to_from_uic_manipulation_step;
	set join_typco_to_claimer;

	length From_UIC_AA_Level $ 6 To_UIC_AA_Level $ 6 from_compo_num $ 2 to_compo_num $ 2 Year 8;

	/*Assignment of the AA Level UIC
	if substrn(from_code,1,1) = "W" and substrn(from_code,5,2) notin ('99','98') then From_UIC_AA_Level = substrn(from_code,1,4)||"AA";
	else From_UIC_AA_Level = from_code;*/
    if typco ne '3';
	if substrn(from_code,5,1) in ('X','G','R') and substrn(from_code,5,2) notin ('X1','X0','G1','G0','R1','R0') then From_UIC_AA_Level = from_code;
	else if substrn(from_code,1,1) = "W" and substrn(from_code,5,2) notin ('99','98') then From_UIC_AA_Level = substrn(from_code,1,4)||"AA";
	else From_UIC_AA_Level = from_code;

	/*if substrn(to_code,1,1) = "W" and substrn(to_code,5,2) notin ('99','98') then To_UIC_AA_Level = substrn(to_code,1,4)||"AA";
	else To_UIC_AA_Level = to_code;*/

	
	if substrn(to_code,5,1) in ('X','G','R') and substrn(to_code,5,2) notin ('X1','X0','G1','G0','R1','R0') then To_UIC_AA_Level = to_code;
	else if substrn(to_code,1,1) = "W" and substrn(to_code,5,2) notin ('99','98') then To_UIC_AA_Level = substrn(to_code,1,4)||"AA";
	else To_UIC_AA_Level = to_code;

	/*Assignment of the year that the transfer will occur in*/
	if month(suspense_date) in (10,11,12) then year = year(suspense_date)  + 1;
	else year = year(suspense_date);
/*	year = suspense_fy;*/

	
	if to_typco in (' ', '2') then to_typco = 1;
	if from_typco in (' ', '2') then from_typco = 1;

	/*Assignment of the components that will be impacted*/
	if from_compo = "Active Army" then from_compo_num = '1'||from_typco;
	else if from_compo = "National Guard" then from_compo_num = '2'||from_typco;
	else if from_compo = "Army Reserve" then from_compo_num = '3'||from_typco;
	else from_compo_num = '6'||from_typco;

	if to_compo = "Active Army" then to_compo_num = '1'||to_typco;
	else if to_compo = "National Guard" then to_compo_num = '2'||to_typco;
	else if to_compo = "Army Reserve" then to_compo_num = '3'||to_typco;
	else to_compo_num = '6'||to_typco;

	if length(from_code) ne 6 then do;
		From_UIC_AA_Level = "FACOT"||from_compo_num;
		From_TYPCO = 1;
		from_compo_num = from_compo_num ||from_typco;
	end;
	if length(to_code) >=6;
run;

proc sql;
	create table compo.LMI_XFER_REMOVE as
	select distinct
		year as dates,
		from_compo_num as compos,
		from_uic_AA_LEVEL as units,
		catalog_lin as lins,
		sum(v_qty_capped) as qty
	from to_from_uic_manipulation_step where substrn(from_uic_AA_LEVEL,1,5) ne "FACOT"
	group by year, from_compo_num, from_uic_AA_LEVEL, catalog_lin;
quit;

proc sql;
	create table compo.LMI_XFER_ADD as
	select distinct
		year as dates,
		to_compo_num as compos,
		to_uic_AA_LEVEL as units,
		catalog_lin as lins,
		sum(v_qty_capped) as qty
	from to_from_uic_manipulation_step where substrn(to_uic_AA_LEVEL,1,5) ne "FACOT"
	group by year, to_compo_num, to_uic_AA_LEVEL, catalog_lin;
quit;

*************************************SUBSTITUTION RULES**********************************************;
data sb_700_20_appxH;
  set sb_700_20_appxH;

	start_Dt = today();
	format start_Dt date9.0;
	run_id = "LMDB_&LMDB_MONTH";
run;

/*This data step will reference the LMDB that you've specified and focused on the columns that
 contain substitution rules. The "transvar" varialbe is the creation of a column that will
 enable us with the ability to bring the LINs in each substitution column into a single
 column so that we can read it in as an "arc" that exists between one lin and another LIN.
 We also upper case the LIN as there are some LINs in the LMDB that are lowercase.*/
data lmdb_sub_columns (keep=LIN REPLACED_by1 REPLACED_by2 REPLACED_by3 REPLACED_by4 REPLACED_by5 
		REPLACES1 REPLACES2 REPLACES3 REPLACES4 REPLACES5 transvar rename=(REPLACED_by1=REPLACED_by_1 REPLACED_by2=REPLACED_by_2 REPLACED_by3=REPLACED_by_3 
        REPLACED_by4=REPLACED_by_4 REPLACED_by5=REPLACED_by_5 REPLACES1=REPLACES_1 REPLACES2=REPLACES_2 REPLACES3=REPLACES_3 REPLACES4=REPLACES_4 REPLACES5=REPLACES_5));
	set lmdb.lmdb_&LMDB_MONTH;

	transvar = 1;

	lin = upcase(LIN);

	if REPLACED_by1 ne '' or REPLACED_by2 ne '' or REPLACED_by3 ne '' or 
		REPLACED_by4 ne '' or REPLACED_by5 ne '' or REPLACES1 ne '' or 
		REPLACES2 ne '' or REPLACES3 ne '' or REPLACES4 ne '' or REPLACES5 ne '';
run;

/*Here we sort the previous data set by LIN so that it can be transposed*/

proc sort data = lmdb_sub_columns nodupkey; by lin; run;

proc transpose data = lmdb_sub_columns out = subrules_no_date_or_source;
	by lin;
	id transvar;
	var REPLACED_by_1 REPLACED_by_2 REPLACED_by_3 REPLACED_by_4 REPLACED_by_5 
			REPLACES_1 REPLACES_2 REPLACES_3 REPLACES_4 REPLACES_5 
			;
run;

/*Now we filter out any empty values as this indicates that a 
relationship does not exist; assign a date based on type of sub-rule
this will be used to define the authority that the rule exists under.*/
data filter_nulls;
	set subrules_no_date_or_source;

	length RUN_ID $ 12;

	if _1 ne '';

	_1 = upcase(_1);

	length date 8;
	format date date9.0;

	if _name_ in ('REPLACED_by_1', 'REPLACED_by_2', 'REPLACED_by_3', 'REPLACED_by_4', 'REPLACED_by_5') then do;
		date = '30SEP2017'd;
	end;

	else if _name_ in ('REPLACES_1', 'REPLACES_2', 'REPLACES_3', 'REPLACES_4', 'REPLACES_5') then do;
		date = '30SEP2019'd;
	end;
/*	else if _name_ = "ZLIN" then do */
/*			date = '30SEP2018'd;*/
/*	end;*/
	else do;
		date = '29SEP2017'd;
	end;

	RUN_ID = "LMDB_&LMDB_MONTH";
run;

/*The sql query here selects the minimum date observed for any 
lin-sublin combination. this will ensure all of the subrules
are distinct and references the highest authority that has blessed
off on the substitution rule.*/

proc sql;
	create table sub_rules_f1 as
	select distinct
		RUN_ID,
		lin,
		_1 as SUBLIN,
		min(date) as START_DT
	from filter_nulls
	group by lin, _1;
quit;

proc sql;
	insert into sub_rules_f1
	select distinct
		RUN_ID,
		_1 as LIN,
		LIN as SUBLIN,
		min(date) as START_DT
	from filter_nulls
	group by lin, _1;
quit;

proc sql;
	insert into sub_rules_f1
	select
		run_id,
		AUTH_LIN as lin,
		SUB_LIN as sublin,
		start_dt
	from sb_700_20_appxH;
quit;

proc sql;
	create table sub_rules_f2 as
	select distinct
		RUN_ID,
		lin,
		SUBLIN,
		min(start_dt) as START_DT
	from sub_rules_f1
	group by lin, sublin;
quit;

/*** Added where stmt to exclude LINS with mod levels less than 3 per Aria 9/23/22 ******/

proc sql;
	create table join_mca_to_lin as
	select
		a.*,b.major_capability_name as lin_mca
	from sub_rules_f2 as a left join lmdb.lmdb_&LMDB_MONTH as b
	on a.lin = b.lin
   where b.mod_level>2;
quit;

proc sql;
	create table join_mca_to_sublin as
	select
		a.*,b.major_capability_name as sublin_mca
	from join_mca_to_lin as a left join lmdb.lmdb_&LMDB_MONTH as b
	on a.sublin = b.lin
    where b.mod_level>2;
quit;

/*Now we will create the LIN-Sublin subrules for the run, assign a start_dt,
end_dt and unsub_date. The start_dt must be earlier than the scenario start
date of the SRAM run we plan to execute.*/

data lmdb.subrules_final;
	set join_mca_to_sublin;
	length SOURCE $ 10 ;
	if start_dt = today() then source = "1-SB_70_20";
	else if START_DT = '29SEP2017'd then SOURCE = "1-SB_700_20";
	else if START_DT = '30SEP2019'd then SOURCE = "3-REPLACES";
	else SOURCE = "4-REPLACED";


	if sublin_mca = '' OR LIN_MCA = '' OR (sublin_mca = lin_mca);

run;


/***************Above Code beginning REQ and OH info match last run TAEDP without shortages***************/
/**********************************RUN Bucket Pour********************************************************/
/******************* Insert Code to position ERC P shortage to be filled first ***************************/
/******************* Apply penalty when ERC A shortages are filled before ERC P***************************/
/****************************This code is used like a DARPL priority**************************************/
/*****************************************April 2024 Optimization code removed****************************/
%include "&code_path\make_index_sets_v2.sas";
%include "&code_path\Optimization_SubModule_GTW.sas";
%include "&code_path\generate_reports_NGRER_new.sas";/*generates the datasets that will feed reports and charts*/
%include "&code_path\NGRER_Summary_reports.sas";



file name:  model_optimization_test.sas

/*The macro defined below contains the optimization and multiple steps to append
the results of the model to the permenant datasets in IDM_O*/

%macro run_opt_model;

OPTIONS FULLSTIMER;

		proc optmodel;


			/*This line of code in the proc-optmodel environment
				creates a numeric data set to store date values*/
			set <number> dates ;
			/*This line of code in the proc-optmodel environment
				creates a numeric data set of modeling dates 
				that spans the first_year and last_year macro variables*/
			set <number> modeling_dates = {&first_year...&last_year.};
			/*This line of code in the proc-optmodel environment
				creates a string based index set for required LINs 
				to be stored after being read into it*/
			set <string> reqd_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for inventory LINs 
				to be stored after being read into it*/
			set <string> inv_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for sub-rules LINs 
				to be stored after being read into it*/
			set <string> sub_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for Units to be
				stored after being read into it*/
			set <string> units ;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for compos to be
				stored after being read into it*/
			set <string> compos ;

	/*DJE Additions That Enable Tightening of Constraints*/

			/*The erc P assign set will take down
			the years, compos, units and lIns where ERC P inventory
			is needed.*/
			set <number,string,string,string> ERC_P_ASSIGN_SET;


			/*The erc P assign set is read in from the data set
			above created in the run opt clusters module.*/

			read data ERC_P_IND_SET into ERC_P_ASSIGN_SET = [dates compos units lins];
			
			/*The erc a assign set will take down
			the years, compos, units and lIns where ERC P inventory
			is needed.*/
			set <number,string,string,string> ERC_A_ASSIGN_SET;

			/*The erc a assign set is read in from the data set
			above created in the run opt clusters module.*/

			read data ERC_A_IND_SET into ERC_A_ASSIGN_SET = [dates compos units lins];

			/*This set is similar to the other erc P assign set but includes
			a slot for sublins.*/
			set <number,string,string,string, string> ERC_P_SUBASSIGN_SET;

			/*The erc P sub-assign set is read in from the data set
			above created in the run opt clusters module.*/
			read data ERC_P_SUBID_SET into ERC_P_SUBASSIGN_SET = [dates compos units lins sublins];
			/*This set is similar to the other erc A assign set but includes
			a slot for sublins.*/
			set <number,string,string,string,string> ERC_A_SUBASSIGN_SET;

			/*The erc A sub-assign set is read in from the data set
			above created in the run opt clusters module.*/
			read data ERC_A_SUBID_SET into ERC_A_SUBASSIGN_SET = [dates compos units lins sublins];
						
			/*The lin/sublin set will capture lin-sublin pairings as needed.*/
			set <string,string> LIN_SUBLIN_SET;

			/*The SUBLIN_SET set is read in from the data set
			above created in the run opt clusters module.*/

			read data SUBLIN_ID_SET into LIN_SUBLIN_SET = [lins sublins];
			
			/*This line of code in the proc-optmodel environment
				creates a numerical set for sub-rule sources that
				are to be ignored*/
			set <number> sources = &sub_ignore_set;

		/*Read data into the sets*/
			
			/*This line of code in the proc-optmodel environment
				reads the dates in the dates input set
				into the numerical index set dates*/
			
			read data idm_i.dates into dates = [dates];
			/*This line of code in the proc-optmodel environment
				reads the required lins in the reqd_lins input set
				into the string index set reqd_lins*/	
			read data reqd_lins into reqd_lins = [lins];	
			/*This line of code in the proc-optmodel environment
				reads the inventory lins in the reqd_lins input set
				into the string index set inv_lins*/	
			read data inv_lins into inv_lins = [lins];
			/*This line of code in the proc-optmodel environment
				reads the sub lins in the lmdb.lins input set
				into the string index set sub_lins*/
			read data lmdb.lins into sub_lins = [lins];
			/*This line of code in the proc-optmodel environment
				reads the units in the unit_compo_number input set
				into the string index set units*/
			read data unit_compo_number into units = [units];
			/*This line of code in the proc-optmodel environment
				reads the compos in the p_compos input set
				into the string index set compos*/
			read data p_compos into compos = [compos];

			/*This line of code creates a master index
			set of all LINs*/
			set <string> lins = (reqd_lins union inv_lins/* union sub_lins*/);  /* added sub_lins JUN2021 - LHB*/
			/*This line of code creates a master index
			set of all LINs for use as sublins*/
			set <string> sublins = (reqd_lins union inv_lins/* union sub_lins*/);  /* added sub_lins JUN2021 - LHB*/			

			/*This line of code creates an index set
			called from_compos based on the compos index set*/
			set <string> from_compos = compos;
			/*This line of code creates an index set
			called to_compos based on the compos index set*/
			set <string> to_compos = compos;
			
			/*An index set of Dates, compos and LINs to fill with
			excess inventory*/
			set<num,string,string> EXCESS_ID_SET = {dates cross compos cross lins};

		/*defines a numeric data value to represent
			the LIN Transfers coming into a unit in the compo*/

			num lin_xfer_add{dates, compos, units, lins} init 0;

		/*reads the incoming lin transfer data into the numeric data element*/
%if %eval(&USE_DST = 1)  %then %do;

%put Reading in DST Transfer In data;
			read data xfers_in into [dates compos units lins]
				lin_xfer_add = col('qty');
%end;
		/*defines a numeric data value to represent
			the LIN Transfers leaving a unit in the compo*/

			num lin_xfer_out{dates, compos, units, lins} init 0;

		/*reads the leaving lin transfer data into the numeric data element*/
%if %eval(&USE_DST = 1)  %then %do;

%put Reading in DST Transfer Out data;
			read data xfers_out into [dates compos units lins]
				lin_xfer_out = col('qty');
%end;
		/*defines a numeric data value to represent
			the mod_levels for the LINs in the component we 
				are processing*/
			num mod_level {lins} init 0;

		/*reads the mod_level data into the numeric data element*/
			read data lins into [lins] 
				mod_level = col('mod_level');

		/*defines the numeric sources for all sublins we use 10 as the initializer so that
				we can direct the model to ignore all substitutions where the source is >= 7*/
			num source{LIN_SUBLIN_SET} init 10;

		/*reads in the source data for the lins/sublins pairings*/
			read data sub_rules into [lins sublins]
				source = col('source');

		/*If two LINs are the same then we don't want to let them 
				substitute for one another*/
			for {<l,s> in LIN_SUBLIN_SET} if l = s then source[l,s] = 10;

		/*defines the numeric data element across the 
			compos, units, lins, and inventory ercs for the 
			data to be stored from the inventory data set.*/
			num inv{compos, units, lins} init 0;
		/*reads in the inventory data from the inventory data set*/
			read data inventory into [compos units lins = lins]
				inv = col('inv');

		/*defines the numeric data element across the 
			dates, compos,lins for procurement data to
				be stored from the procurements data set.*/
			num procs{dates,compos,lins} init 0;

		/*reads in the procurement data from the procurement data set
			into the numerical value*/

		/*Added in a feature to ignore procurements when the NGRER_RUN_TOGGLE is turned on*/
			%if %eval(&NGRER_RUN_TOGGLE ne 1) %then %do;

%put Reading in procurement data;

			read data procurements into [dates compos lins]
				procs = col('qty');
/*				procs = col('procs');*/
			%end;

				
		/*defines the darpl numbers, we use a very large number (100000) 
				to identify values where the DARPL is not observed for 
				a unit entry on a specific date*/
			num darpl{dates, compos, units} init 100000;

		/*reads in the DARPL data across the years, compo, and units*/
			read data darpl into [dates compos units]
				darpl = col('darpl');
/*				darpl = col('priority');*/

		/*defines the numeric data element across the 
			dates, compos,lins for requirement data to
				be stored from the requirements data set.*/
			num reqd_P{ERC_P_ASSIGN_SET} init 0;
			num reqd_A{ERC_A_ASSIGN_SET} init 0;

		/*reads in the requirement data from the requirement data set
			into the numerical value*/
			read data ERC_P_IND_SET into [dates compos units lins]
				reqd_P = col('reqd');
			read data ERC_A_IND_SET into [dates compos units lins]
				reqd_A = col('reqd');


		/*If there are valid intercompo transfer rules we define 
				and read in the valid transfer rules from the 
				compo-transfer data set. We also set intracompo 
				transfers to be permitted*/

		%if %eval(&valid_transfer. > 0) %then %do;	
%put Reading in the Compo Transfer Index Sets;
			set<number, string, string, string, string> ERC_P_XFER_SET;

			read data ERC_P_XFER_IND_SET into ERC_P_XFER_SET = [dates to_compos from_compos units lins];
			
			set<number, string, string, string, string> ERC_A_XFER_SET;

			read data ERC_A_XFER_IND_SET into ERC_A_XFER_SET = [dates to_compos from_compos units lins];

%put Reading in the Compo Substitution Transfer Index Sets;
			set <number, string, string, string, string, string> ERC_P_SUBXFER_SET;
			
			read data ERC_P_SUBXFER_ID_SET into ERC_P_SUBXFER_SET = [dates to_compos from_compos units lins sublins];
			
			set <number, string, string, string, string, string> ERC_A_SUBXFER_SET;
			
			read data ERC_A_SUBXFER_ID_SET into ERC_A_SUBXFER_SET = [dates to_compos from_compos units lins sublins];

		%end;


		/*We define a numerical data element that
			will be used to penalize by lin if modern
			excess is unassigned*/
			num lin_excess_pen{lins} init 0;

			/*this is a for-loop that assigns the mod-5 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 5 then lin_excess_pen[l] = &mod_5_e_pen.;

			/*this is a for-loop that assigns the mod-4 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 4 then lin_excess_pen[l] = &mod_4_e_pen.;

			/*this is a for-loop that assigns the mod-3 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 3 then lin_excess_pen[l] = &mod_3_e_pen.;

			/*this is a for-loop that assigns the mod-2 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 2 then lin_excess_pen[l] = &mod_2_e_pen.;
			/*this is a for-loop that assigns the mod-1 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 1 then lin_excess_pen[l] = &mod_1_e_pen.;

			/*Defines a data element that will store the cummulative procurements
				by year for each LIN and in each Compo.*/
			num lin_procs{dates, compos, lins} init 0;
			/*This for-loop populates the cummulative procurements values
				by year for each LIN and in each Compo.*/
			for {d in dates, c in compos, l in lins} lin_procs[d,c,l] = (sum{v in dates inter {&min_year...d}}(procs[v,c,l]));

			/*Defines a data element that will store the cummulative transfers out
				by year for each LIN, unit, and in each Compo.*/
			num cum_xfers_out{dates, compos, units, lins} init 0;

			/*This for-loop populates the cummulative transfer out values
				by year for each LIN/Unit and in each Compo.*/
			for {d in dates, c in compos, u in units, l in lins} cum_xfers_out[d,c,u,l] 
						= max((sum{v in dates inter {&min_year...d}}(lin_xfer_out[v,c,u,l])),0);


			/*Defines a data element that will store the cummulative transfers in
				by year for each LIN, unit, and in each Compo.*/
			num cum_xfers_in{dates, compos, units, lins} init 0;
			/*This for-loop populates the cummulative transfer out values
				by year for each LIN/Unit and in each Compo.*/
			for {d in dates, c in compos, u in units, l in lins} cum_xfers_in[d,c,u,l] 
						= max((sum{v in dates inter {&min_year...d}}(lin_xfer_add[v,c,u,l])),0);

			num inv_avail{dates, compos, lins} init 0;

			for {d in dates, c in compos, l in lins}
					inv_avail[d,c,l] = 
						max(lin_procs[d,c,l] 
							+ sum{u in units}(inv[c,u,l] + cum_xfers_in[d,c,u,l]  - cum_xfers_out[d,c,u,l]) ,0);

			%put Outputting assignments;
			/*This line of code write lin availability numbers by date, compo, and lin  to a data set*/
			create data lin_avail_&working_comp from [modeling_dates compos lins]
					inv_avail;


%put Defining Non-Substitution Inventory Assignment Decision Variables; 
		/* DJE ADDED TO introduce ERC_P_ASSIGN and ERC_A_ASSIGN decision Variables 07APR2017 1443*/
			var erc_P_assign{ERC_P_ASSIGN_SET} >=0 integer;
			var erc_A_assign{ERC_A_ASSIGN_SET} >=0 integer;

%put Defining Substitution Inventory Assignment Decision Variables;
		/* DJE ADDED TO introduce ERC_P_ASSIGN and ERC_A_ASSIGN decision Variables 10APR2017 1257*/
			var erc_P_subassign{ERC_P_SUBASSIGN_SET} >=0 integer;
			var erc_A_subassign{ERC_A_SUBASSIGN_SET} >=0 integer;


			/*If there are valid intercompo transfer rules we define 
				transfer decision variables and substitution transfer variables*/
			%if %eval(&valid_transfer. > 0) %then %do;
%put Defining Compo Transfer Decision Variables;
			/*Decision Variables for xfers*/
				var erc_p_xfer{ERC_P_XFER_SET} >= 0 integer;
				var erc_a_xfer{ERC_A_XFER_SET} >= 0 integer;
			/*Decision Variables for substitution transfers*/
				var erc_p_subxfer{ERC_P_SUBXFER_SET} >= 0 integer;
				var erc_a_subxfer{ERC_A_SUBXFER_SET} >= 0 integer;

			%end;

			
			/*Defines the non-negative integer decision variable 
					that will store the excess equipment values*/
%put Defining the Aggregate Excess Decision Variables;
			var excess {EXCESS_ID_SET} >= 0 integer;

			/*DJE Adding a break out constraint that places shortage into erc p and erc a sets*/
%put Defining the Shortage Decision Variables;
			var Short_Ps{ERC_P_ASSIGN_SET} >=0 integer;
			var Short_As{ERC_A_ASSIGN_SET} >=0 integer;

			/*Defines the non-negative integer decision variable 
					that will store inventory addition values when 
					we don't have enough equipment to transfer out of a LIN*/
%put Defining an Inventory Relaxation Decision Variables;
			var add_inv {modeling_dates, compos, lins} >= 0 integer;

			%if %eval(&fix_flex. = 1)%then %do;
%put Disabling the Inventory Relaxation Decision Variables;
				for {d in dates, c in compos, l in lins} fix add_inv[d,c,l]=0;
			%end;
			/*The following for-loops fix decision variables that the model will
			not need to solve*/
				/*If a requirement is zero then we fix the shortage value to zero as
				a shortage cannot exist*/
%put Fixing the shortage decision variables to zero when requirement data on a date, compo, unit and lin is zero;
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				if reqd_P[d,c,u,l] = 0 then fix Short_Ps[d,c,u,l] = 0;
			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				if reqd_A[d,c,u,l] = 0 then fix Short_As[d,c,u,l] = 0;	
%put Fixing the assignment decision variables to zero when requirement data on a date, compo, unit and lin is zero;
				/*If a requirement is zero then we fix the assign value to zero as
				a assignment cannot exist*/
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				if reqd_P[d,c,u,l] = 0 then fix erc_p_assign[d,c,u,l] = 0;
			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				if reqd_A[d,c,u,l] = 0 then fix erc_A_assign[d,c,u,l] = 0;
				
		/*If the toggle for modern subs is on then fix the sub_assign to 0 where the mod_Level of a lin is less than or
		equal to the the mod levle of the sub_Lins*/
		%if %eval(&modern_subs. > 0) %then %do;
%put Fixing the substitution decision variables to zero the sublin is less modern than the lin;
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}			
				if mod_level[s]< mod_level[l] then fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				if mod_level[s]< mod_level[l] then fix erc_A_subassign[ d, c, u, l, s] = 0
			;
			%if %eval(&valid_transfer. > 0) %then %do;
			/*fixing the sub transfer rules*/
%put Fixing the Compo transfers through less modern substitutions to zero;

			for {<d,t,f,u,l,s> in ERC_P_SUBXFER_SET}			
				if mod_level[s]< mod_level[l] then fix erc_p_subxfer[ d, t, f, u, l, s] = 0
			;
			for {<d,t,f,u,l,s> in ERC_A_SUBXFER_SET}			
				if mod_level[s]< mod_level[l] then fix erc_a_subxfer[ d, t, f, u, l, s] = 0
			;
			%end;
		%end;

		/*If the toggle for no-subs is on then fix the sub_assign to 0 for all of these decision variables*/
		%if %eval(&subs_allowed. = 0) %then %do;
%put Fixing the substitution decision variables to zero because none are permitted in this run;
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}			
				fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				fix erc_A_subassign[ d, c, u, l, s] = 0
			;
			%if %eval(&valid_transfer. > 0) %then %do;
			/*fixing the sub transfer rules*/
%put Fixing the Compo transfers through substitutions to zero;

				for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET}
					fix erc_p_subxfer[d,c,f,u,l,s] = 0
				;
						
				for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET}
					fix erc_a_subxfer[d,c,f,u,l,s] = 0
				;

			%end;
		%end;

		/*Added in a feature to fix the assignment of inventory to 0 for all ML1 and ML2 LINs when
			the NGRER_RUN_TOGGLE is turned on*/
			%if %eval(&NGRER_RUN_TOGGLE = 1) %then %do;

%put Fixing the assignment of ML1 and ML2 inventory to 0;

				/*Fixing ERC P Assignments*/
					for {<d,c,u,l> in ERC_P_ASSIGN_SET} if mod_level[l] <3 then fix erc_P_assign[d, c, u, l] = 0;
				/*Fixing ERC A Assignments*/
					for {<d,c,u,l> in ERC_A_ASSIGN_SET} if mod_level[l] <3 then fix erc_A_assign[d, c, u, l] = 0;
				/*Fixing ERC P Sub Assignments*/
					for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET} if mod_level[s] <3 then fix erc_p_subassign[ d, c, u, l, s] = 0;
				/*Fixing ERC A Sub Assignments*/
					for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET} if mod_level[s] <3 then fix erc_a_subassign[ d, c, u, l, s] = 0;
				%if %eval(&valid_transfer. > 0) %then %do;
					/*Fixing ERC P Xfer Assignments*/
					for{<d,c,f,u,l> in ERC_P_XFER_SET} if mod_level[l] <3 then fix erc_p_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l> in ERC_A_XFER_SET} if mod_level[l] <3 then fix erc_a_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET} if mod_level[s] <3 then fix erc_P_subxfer[d,c,f,u,l,s] = 0;
					for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET} if mod_level[s] <3 then fix erc_A_subxfer[d,c,f,u,l,s] = 0;

					/*fixing these variables to 0 for years earlier than a user specified CASC_YEAR*/
%put Fixing the cascading to 0 in years before &CASC_YEAR;	
					for{<d,c,f,u,l> in ERC_P_XFER_SET} if d < &CASC_YEAR. then fix erc_p_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l> in ERC_A_XFER_SET} if d < &CASC_YEAR. then fix erc_a_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET} if d < &CASC_YEAR. then fix erc_P_subxfer[d,c,f,u,l,s] = 0;
					for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET} if d < &CASC_YEAR. then fix erc_A_subxfer[d,c,f,u,l,s] = 0;


				%end;
			%end;


			/*If a the source for a sub-rule is greater than or equal to 7 thn we fix
				substitutions assignments to 0*/
%put Fixing the substitution decision variables to zero for in lieu of substutions;	
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}
				if source[l,s] >= 7 then fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				if source[l,s] >= 7 then fix erc_a_subassign[ d, c, u, l, s] = 0
			;
%if %eval(&valid_transfer. > 0) %then %do;	
%put Fixing the substitution transfer decision variables to zero for in lieu of substutions;		
			for {<d,f,c,u,l,s> in ERC_P_SUBXFER_SET}			
				if source[l,s] >= 7 then fix erc_p_subxfer[d,f,c,u,l,s] = 0
			;
			
			for {<d,f,c,u,l,s> in ERC_A_SUBXFER_SET}			
				if source[l,s] >= 7 then fix erc_a_subxfer[d,f,c,u,l,s] = 0
			;
%end;
			/*If we are freezing the first year of inventory to what it is then we 
			set a constraint to make all assignments and excess to the
			inveentory in the first year*/

			%if %eval(&freeze_first_two. = 1) %then %do;
%put Constraint that Fixes the First two years is active;
			Con Freeze_Year_1{ d in modeling_dates inter {&min_year..&year_two.},c in compos, l in lins, u in units}:
					sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,u,l])
						+ sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,u,l])
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,u,s,l]))
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,u,s,l]))
					= 
					inv[c,u,l]+ cum_xfers_in[d,c,u,l] - cum_xfers_out[d,c,u,l];
			%end;

/*This if-then-do statement will define component level fencing constraints that ensure the LIN 
			level inventory balances out with the initial inventory plus procurements allocated
			to each component*/

			%if %eval(&valid_transfer. = 0) %then %do;	
%put We are using the constraints that do not enable compo transfers;		
			/*New inventory constraints to handle the tuple based index sets*/
				CON INV_MGMT_Y1A {d in dates inter {&min_year.}, c in compos, l in lins }:
						sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ excess[d,c,l]	
							= 
							inv_avail[d,c,l]
							+ add_inv[d,c,l];
	
/*New inventory constraints to handle the tuple based index sets*/
				Con INV_MGMT_YNA {d in modeling_dates diff {&min_year.}, c in compos, l in lins}:
					sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ excess[d,c,l]				
					/*total inventory within the component + procurements through the date of the constraint*/
							=
							inv_avail[d,c,l]
							+ (add_inv[d,c,l]);

				/*ERC P Shortage break out*/
				Con Shortage_Value_P {<d,c,u,l> in ERC_P_ASSIGN_SET}:
					Short_Ps[d,c,u,l] + erc_p_assign[d,c,u,l]
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target.  * reqd_P[d,c,u,l])
				;
				/*ERC A Shortage break out*/
				Con Shortage_Value_A {<d,c,u,l> in ERC_A_ASSIGN_SET}:
					Short_As[d,c,u,l] + erc_a_assign[d,c,u,l]						
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l and sublin = s }<date,compo,unit,lin,sublin>)}(erc_a_subassign[d,c,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target.  * reqd_A[d,c,u,l])
				;
			%end;

			%else %do;	

%put We are using the constraints that enable compo transfers;
		%put definining the Year 1 inventory flow constraint;
			/*New inventory constraints to handle the tuple based index sets*/
				CON INV_MGMT_Y1A {d in dates inter {&min_year.}, c in compos, l in lins }:
						sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ (excess[d,c,l])
						+ sum{<date,t,compo,u,lin> in ERC_P_XFER_SET: date = d and compo = c and lin=l}(erc_p_xfer[date,t,compo,u,lin])
						+ sum{<date,t,compo,u,lin> in ERC_A_XFER_SET: date = d and compo = c and lin=l}(erc_A_xfer[date,t,compo,u,lin])
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_P_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_p_subxfer[date,t,compo,u,s,lin]))
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_A_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_a_subxfer[date,t,compo,u,s,lin]))
							= 
							inv_avail[d,c,l] + add_inv[d,c,l]
				;
			/*New inventory constraints to handle the tuple based index sets*/
				%put definining the Year 2 through n inventory flow constraint;
				Con INV_MGMT_YNA {d in modeling_dates diff {&min_year.}, c in compos, l in lins}:
					sum{ v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{ v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{ v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ (excess[d,c,l])						
						+ sum{<date,t,compo,u,lin> in ERC_P_XFER_SET: date = d and compo = c and lin=l}(erc_p_xfer[date,t,compo,u,lin])
						+ sum{<date,t,compo,u,lin> in ERC_A_XFER_SET: date = d and compo = c and lin=l}(erc_A_xfer[date,t,compo,u,lin])
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_P_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_p_subxfer[date,t,compo,u,s,lin]))
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_A_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_a_subxfer[date,t,compo,u,s,lin]))
					/*total inventory within the component + procurements through the date of the constraint*/
							=
							inv_avail[d,c,l] + (add_inv[d,c,l])
				;
				/*ERC P Shortage break out*/
				Con Shortage_Value_P {<d,c,u,l> in ERC_P_ASSIGN_SET}:
					Short_Ps[d,c,u,l] + erc_p_assign[d,c,u,l]
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
						+ sum{f in compos diff {c}}
							(sum{(setof{<date, to, from, unit, lin> in ERC_P_XFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l}
							<date,to,from,unit,lin>)}(erc_p_xfer[d,c,f,u,l]))
						+ sum{f in compos diff {c}, s in sublins diff {l}}
							(sum{(setof{<date, to, from, unit, lin, sublin> in ERC_P_SUBXFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l and sublin = s}
							<date,to,from,unit,lin,sublin>)}(erc_p_subxfer[d,c,f,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target. * reqd_P[d,c,u,l])
				;
				/*ERC A Shortage break out*/
				Con Shortage_Value_A {<d,c,u,l> in ERC_A_ASSIGN_SET}:
					Short_As[d,c,u,l] + erc_a_assign[d,c,u,l]						
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l and sublin = s }<date,compo,unit,lin,sublin>)}(erc_a_subassign[d,c,u,l,s]))
						+ sum{f in compos diff {c}}
							(sum{(setof{<date, to, from, unit, lin> in ERC_A_XFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l}
							<date,to,from,unit,lin>)}(erc_a_xfer[d,c,f,u,l]))
						+ sum{f in compos diff {c}, s in sublins diff {l}}
							(sum{(setof{<date, to, from, unit, lin, sublin> in ERC_A_SUBXFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l and sublin = s}
							<date,to,from,unit,lin,sublin>)}(erc_a_subxfer[d,c,f,u,l,s]))

						= ceil( &fill_target. * reqd_A[d,c,u,l])
				;
			%end;
						
		/*Minimize the objective function value relative to the overall shortages, modern-excess, and transfers that occur*/

%put Setting up the objective function;
		min z = 
		/*Shortage penalties*/
			%put Penalizing ERC P Shortages;
				&p_pri. * sum{<d,c,u,l> in ERC_P_ASSIGN_SET}(
							(100000-darpl[d,c,u]) * Short_Ps[d,c,u,l])
			%put Penalizing ERC A Shortages;
				+ &a_pri. * sum{<d,c,u,l> in ERC_A_ASSIGN_SET}(
							(100000-darpl[d,c,u]) * Short_As[d,c,u,l])
				/*+ &b_pri. * sum{d in modeling_dates, c in compos, u in units, l in reqd_lins, e in reqd_ercs inter {"B"}}(
							(100000-darpl[d,c,u]) * shortage[d,c,u,l,e])
				+ &c_pri. * sum{d in modeling_dates, c in compos, u in units, l in reqd_lins, e in reqd_ercs inter {"C"}}(
							(100000-darpl[d,c,u]) * shortage[d,c,u,l,e])*/
			/*if we have valid transfer rules we slightly penalize transfering equipment across component to
				reduce the possibility of multiple optimal solutions and erroneous transfers*/
			%if %eval(&valid_transfer. > 0) %then %do;

				%if %eval(&trans_pen. <= 0) %then %put Rewarding Compo Transfers;
				%else %put Penalizing Compo Transfers;
				+ &trans_pen. * (
					sum{<d,to,from,u,l> in ERC_P_XFER_SET}(erc_p_xfer[d,to,from,u,l])
					+
					sum{<d,to,from,u,l> in ERC_A_XFER_SET}(erc_a_xfer[d,to,from,u,l])
					+
					sum{<d,to,from,u,l,s> in ERC_P_SUBXFER_SET}(erc_p_subxfer[d,to,from,u,l,s])
					+
					sum{<d,to,from,u,l,s> in ERC_A_SUBXFER_SET}(erc_a_subxfer[d,to,from,u,l,s])
					)
				 
			%end;
			%put Penalizing Unit transfers that move inventory away from where they were originally;
			/*We penalize spurious assignment that while the same as another we want consistent
			inventory assignments over the years and units*/
				+ &unit_yearly_xfer_pen. * 
					(sum{d in modeling_dates inter {&first_year.}}
							sum{<sd,compo,unit,lin> in ERC_P_ASSIGN_SET: sd = d}
						(
						  erc_p_assign[sd,compo,unit,lin]-
						sum {f in modeling_dates diff {&first_year.}}
							sum{<fy,sc,su,sl> in ERC_P_ASSIGN_SET: fy = f and sc = compo and su = unit and sl = lin}
									(erc_p_assign[fy, sc, su, sl])
						)
					+
					sum{d in modeling_dates inter {&first_year.}}
							sum{<sd,compo,unit,lin> in ERC_A_ASSIGN_SET: sd = d}
						(
						  erc_a_assign[sd,compo,unit,lin]-
						sum {f in modeling_dates diff {&first_year.}}
							sum{<fy,sc,su,sl> in ERC_A_ASSIGN_SET: fy = f and sc = compo and su = unit and sl = lin}
									(erc_a_assign[fy, sc, su, sl])
						)
					)
		/*Modern Excess inventory penalties*/
				+ sum{d in modeling_dates, c in compos, l in lins}(lin_excess_pen[l] * excess[d,c,l])
		/*Substitution assignment penalties*/
				+ &sub_assign_pen. * 
					(	  sum{<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}(erc_p_subassign[d,c,u,l,s])
						+ sum{<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}(erc_a_subassign[d,c,u,l,s])
						%if %eval(&valid_transfer. > 0) %then %do;
						+ sum{<d,to,from,u,l,s> in ERC_P_SUBXFER_SET}(erc_p_subxfer[d,to,from,u,l,s])
						+ sum{<d,to,from,u,l,s> in ERC_A_SUBXFER_SET}(erc_a_subxfer[d,to,from,u,l,s])
						%end;
					)
		/*Penalty for giving away inventory that a unit has in a future year*/
		/*Big-M penalty for having to add inventory to make the inventory constraints feasible*/
		%if %eval(&fix_flex. = 0) %then %put Penalizing the use of the slack variable;
				+ 10000000* (sum{d in modeling_dates, c in compos, l in lins}(add_inv[d,c,l]))
		;
		/*This line of code will envoke the solver and as long as we are within 5% of a linear optimum we are good*/
	%put Time to solve this thing!;
			solve with milp / relobjgap= .05;

			%put Outputting assignments;
		/*This line of code write all assignments to a data set*/
			create data P_assigned_&working_comp from [modeling_dates compos units lins]
					erc_p_assign;
			create data A_assigned_&working_comp from [modeling_dates compos units lins]
					erc_A_assign;
			%put Outputting substitutions;
		/*This line of code write all substitutions to a data set*/
			create data A_subbed_&working_comp from [modeling_dates compos units lins sublins]
					erc_a_subassign;
			create data P_subbed_&working_comp from [modeling_dates compos units lins sublins]
					erc_p_subassign;
		/*These line of code write all transfers if there are valid transfers allowed to a data set*/
		%if %eval(&valid_transfer. > 0) %then %do;
		/*create data from the transfers*/

		%put Outputting Transfers;

			create data P_XFERS_&working_comp from [modeling_dates to_compos from_compos units lins]
					erc_p_xfer;

			create data A_XFERS_&working_comp from [modeling_dates to_compos from_compos units lins]
					erc_A_xfer;

			create data P_SUBXFERS_&working_comp from [modeling_dates to_compos from_compos units lins sublins]
					erc_P_subxfer;

			create data A_SUBXFERS_&working_comp from [modeling_dates to_compos from_compos units lins sublins]
					erc_A_subxfer;


		%end;

		
		%put Outputting shortfalls;
		/*These line of code write all shortages to a data set*/
			create data P_shortage_&working_comp from [modeling_dates compos units lins]
				short_ps ;
			create data A_shortage_&working_comp from [modeling_dates compos units lins]
				short_as ;

		/*This line of code defines a numerical value to store on hand positions across the master
				index sets*/
			num P_onhand{modeling_dates, compos, units, lins} init 0;
			num A_onhand{modeling_dates, compos, units, lins} init 0;
		
				%put Creating aggregate on hand values;
		
		/*This for-loop populates the onhand values to the sum of assignments, transfers, 
			and substitutions*/
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				P_onhand[d,c,u,l] = 
					erc_p_assign[d,c,u,l]
					+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
				
%if %eval(&valid_transfer. > 0) %then %do;	
%put ERC P transfers are adding into the reported on hand amounts;
					+ sum{f in compos diff {c}}(sum{(setof{<date,to_compo,from_compo,unit,lin> in ERC_P_XFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l}
							<date,to_compo,from_compo,unit,lin>)}(erc_p_xfer[d,c,f,u,l]))
					+ sum{f in compos diff {c}, s in sublins diff {l}}(sum{(setof{<date,to_compo,from_compo,unit,lin,sublin> in ERC_P_SUBXFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l and sublin = s}
							<date,to_compo,from_compo,unit,lin,sublin>)}(erc_p_subxfer[d,c,f,u,l,s]))
%end;
			;

			%put outputting on hand values with requirements and shortages;
			create data P_onhand_&working_comp from [modeling_dates compos units lins]
				reqd_P P_OnHand short_ps;

			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				A_onhand[d,c,u,l] = 
					erc_A_assign[d,c,u,l]
					+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_A_subassign[d,c,u,l,s]))
%if %eval(&valid_transfer. > 0) %then %do;	
%put ERC A transfers are adding into the reported on hand amounts;
					+ sum{f in compos diff {c}}(sum{(setof{<date,to_compo,from_compo,unit,lin> in ERC_A_XFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l}
							<date,to_compo,from_compo,unit,lin>)}(erc_a_xfer[d,c,f,u,l]))
					+ sum{f in compos diff {c}, s in sublins diff {l}}(sum{(setof{<date,to_compo,from_compo,unit,lin,sublin> in ERC_A_SUBXFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l and sublin = s}
							<date,to_compo,from_compo,unit,lin,sublin>)}(erc_a_subxfer[d,c,f,u,l,s]))
%end;
			;

			create data A_onhand_&working_comp from [modeling_dates compos units lins]
				reqd_a A_OnHand short_as;

				%if %eval(&fix_flex. = 0) %then %put Outputting the amount of slack used;
/*This line of code creates the infeasbility additions*/
			create data Infe_Adds_&working_comp from [modeling_dates compos lins]
				add_inv;
 			%put Outputting the excess inventory used;
			/*DJE Added to export excess observations*/
			create data excess_&working_comp from [modeling_dates compos lins]
					excess;
		quit;

	OPTIONS NOFULLSTIMER;

		/*This is test data to see if the ERC_P_Assignments are making the correct
			assignments*/

		/*DJE Added to accommodate for new variables index sets 11APR2017*/
		proc sql;
  create table work._assigned_batch as
  select modeling_dates, compos, units, lins,
         'P' length=1 as ercs,
         erc_p_assign as assign
  from P_assigned_&working_comp
  where erc_p_assign > 0
  union all
  select modeling_dates, compos, units, lins,
         'A' length=1 as ercs,
         erc_a_assign as assign
  from A_assigned_&working_comp
  where erc_a_assign > 0
  ;
quit;

proc append base=idm_o.assigned data=work._assigned_batch force; run;

		
		/*DJE Added to accommodate for new variables index sets 11APR2017*/
			proc sql;
  create table work._subbed_batch as
  select modeling_dates, compos, units, lins, sublins,
         'P' length=1 as ercs,
         erc_p_subassign as subbed
  from P_subbed_&working_comp
  where erc_p_subassign > 0
  union all
  select modeling_dates, compos, units, lins, sublins,
         'A' length=1 as ercs,
         erc_a_subassign as subbed
  from A_subbed_&working_comp
  where erc_a_subassign > 0
  ;
quit;

proc append base=idm_o.subbed data=work._subbed_batch force; run;

				
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/

			
			data Infe_Adds_append;
				set Infe_Adds_&working_comp;

				if add_inv > 0;
				component = &working_comp.;

			run;

			
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/

		proc sql;
  create table work._shortage_batch as
  select modeling_dates, compos, units, lins,
         'P' length=1 as ercs,
         Short_Ps as shortage
  from P_shortage_&working_comp
  where Short_Ps > 0
  union all
  select modeling_dates, compos, units, lins,
         'A' length=1 as ercs,
         Short_As as shortage
  from A_shortage_&working_comp
  where Short_As > 0
  ;
quit;

proc append base=idm_o.shortage data=work._shortage_batch force; run;

	
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/
			
		proc sql;
  create table work._invpos_batch as
  select modeling_dates, compos, units, lins,
         'P' length=1 as ercs,
         reqd_p as reqd,
         p_onhand as onhand,
         short_ps as shortages,
         0 as excess
  from P_onhand_&working_comp
  where reqd_p > 0 or short_ps > 0
  union all
  select modeling_dates, compos, units, lins,
         'A' length=1 as ercs,
         reqd_a as reqd,
         a_onhand as onhand,
         short_as as shortages,
         0 as excess
  from A_onhand_&working_comp
  where reqd_a > 0 or short_as > 0
  union all
  select modeling_dates, compos,
         'EXCESS' as units,
         lins,
         'X' length=1 as ercs,
         0 as reqd,
         0 as onhand,
         0 as shortages,
         excess as excess
  from excess_&working_comp
  where excess > 0
  ;
quit;

proc append base=idm_o.inv_positions data=work._invpos_batch force; run;

			
			proc append base = idm_o.Infe_Adds data = Infe_Adds_append;
			run;


			
	%if %eval(&valid_transfer. > 0) %then %do;		
%put Appending the compo transfers to the result sets;

/*append the erc p compo transfers*/
		proc sql;
  create table work._xferred_batch as
  select modeling_dates, to_compos, from_compos, units, lins,
         'P' length=1 as ercs,
         erc_p_xfer as compo_transfer
  from P_xfers_&working_comp
  where erc_p_xfer > 0
  union all
  select modeling_dates, to_compos, from_compos, units, lins,
         'A' length=1 as ercs,
         erc_a_xfer as compo_transfer
  from A_xfers_&working_comp
  where erc_a_xfer > 0
  ;
quit;

proc append base=idm_o.xferred data=work._xferred_batch force; run;

/* ==== SUB_XFERRED (P + A in one batch) ==== */
proc sql;
  create table work._subxferred_batch as
  select modeling_dates, to_compos, from_compos, units, lins, sublins,
         'P' length=1 as ercs,
         erc_p_subxfer as compo_sub_transfer
  from P_subxfers_&working_comp
  where erc_p_subxfer > 0
  union all
  select modeling_dates, to_compos, from_compos, units, lins, sublins,
         'A' length=1 as ercs,
         erc_a_subxfer as compo_sub_transfer
  from A_subxfers_&working_comp
  where erc_a_subxfer > 0
  ;
quit;

proc append base=idm_o.sub_xferred data=work._subxferred_batch force; run;


	%end;

%mend;


/*this line of code envokes the macro defined above*/
%run_opt_clusters;


file name: model_optimization_nosubs.sas

/*The macro defined below contains the optimization and multiple steps to append
the results of the model to the permenant datasets in IDM_O*/
%macro run_opt_model;

OPTIONS FULLSTIMER;
		proc optmodel;


			/*This line of code in the proc-optmodel environment
				creates a numeric data set to store date values*/
			set <number> dates ;
			/*This line of code in the proc-optmodel environment
				creates a numeric data set of modeling dates 
				that spans the first_year and last_year macro variables*/
			set <number> modeling_dates = {&first_year...&last_year.};
			/*This line of code in the proc-optmodel environment
				creates a string based index set for required LINs 
				to be stored after being read into it*/
			set <string> reqd_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for inventory LINs 
				to be stored after being read into it*/
			set <string> inv_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for sub-rules LINs 
				to be stored after being read into it*/
			set <string> sub_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for Units to be
				stored after being read into it*/
			set <string> units ;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for compos to be
				stored after being read into it*/
			set <string> compos ;

	/*DJE Additions That Enable Tightening of Constraints*/

			/*The erc P assign set will take down
			the years, compos, units and lIns where ERC P inventory
			is needed.*/
			set <number,string,string,string> ERC_P_ASSIGN_SET;


			/*The erc P assign set is read in from the data set
			above created in the run opt clusters module.*/

			read data ERC_P_IND_SET into ERC_P_ASSIGN_SET = [dates compos units lins];
			
			/*The erc a assign set will take down
			the years, compos, units and lIns where ERC P inventory
			is needed.*/
			set <number,string,string,string> ERC_A_ASSIGN_SET;

			/*The erc a assign set is read in from the data set
			above created in the run opt clusters module.*/

			read data ERC_A_IND_SET into ERC_A_ASSIGN_SET = [dates compos units lins];

			/*This set is similar to the other erc P assign set but includes
			a slot for sublins.*/
			set <number,string,string,string, string> ERC_P_SUBASSIGN_SET;

			/*The erc P sub-assign set is read in from the data set
			above created in the run opt clusters module.*/
			read data ERC_P_SUBID_SET into ERC_P_SUBASSIGN_SET = [dates compos units lins sublins];
			/*This set is similar to the other erc A assign set but includes
			a slot for sublins.*/
			set <number,string,string,string,string> ERC_A_SUBASSIGN_SET;

			/*The erc A sub-assign set is read in from the data set
			above created in the run opt clusters module.*/
			read data ERC_A_SUBID_SET into ERC_A_SUBASSIGN_SET = [dates compos units lins sublins];
						
			/*The lin/sublin set will capture lin-sublin pairings as needed.*/
			set <string,string> LIN_SUBLIN_SET;

			/*The SUBLIN_SET set is read in from the data set
			above created in the run opt clusters module.*/

			read data SUBLIN_ID_SET into LIN_SUBLIN_SET = [lins sublins];
			
			/*This line of code in the proc-optmodel environment
				creates a numerical set for sub-rule sources that
				are to be ignored*/
			set <number> sources = &sub_ignore_set;

		/*Read data into the sets*/
			
			/*This line of code in the proc-optmodel environment
				reads the dates in the dates input set
				into the numerical index set dates*/
			
			read data idm_i.dates into dates = [dates];
			/*This line of code in the proc-optmodel environment
				reads the required lins in the reqd_lins input set
				into the string index set reqd_lins*/	
			read data reqd_lins into reqd_lins = [lins];	
			/*This line of code in the proc-optmodel environment
				reads the inventory lins in the reqd_lins input set
				into the string index set inv_lins*/	
			read data inv_lins into inv_lins = [lins];
			/*This line of code in the proc-optmodel environment
				reads the sub lins in the lmdb.lins input set
				into the string index set sub_lins*/
			read data lmdb.lins into sub_lins = [lins];
			/*This line of code in the proc-optmodel environment
				reads the units in the unit_compo_number input set
				into the string index set units*/
			read data unit_compo_number into units = [units];
			/*This line of code in the proc-optmodel environment
				reads the compos in the p_compos input set
				into the string index set compos*/
			read data p_compos into compos = [compos];

			/*This line of code creates a master index
			set of all LINs*/
			set <string> lins = (reqd_lins union inv_lins/* union sub_lins*/);  /* added sub_lins JUN2021 - LHB*/
			/*This line of code creates a master index
			set of all LINs for use as sublins*/
			set <string> sublins = (reqd_lins union inv_lins/* union sub_lins*/);  /* added sub_lins JUN2021 - LHB*/			

			/*This line of code creates an index set
			called from_compos based on the compos index set*/
			set <string> from_compos = compos;
			/*This line of code creates an index set
			called to_compos based on the compos index set*/
			set <string> to_compos = compos;
			
			/*An index set of Dates, compos and LINs to fill with
			excess inventory*/
			set<num,string,string> EXCESS_ID_SET = {dates cross compos cross lins};

		/*defines a numeric data value to represent
			the LIN Transfers coming into a unit in the compo*/

			num lin_xfer_add{dates, compos, units, lins} init 0;

		/*reads the incoming lin transfer data into the numeric data element*/
%if %eval(&USE_DST = 1)  %then %do;

%put Reading in DST Transfer In data;
			read data xfers_in into [dates compos units lins]
				lin_xfer_add = col('qty');
%end;
		/*defines a numeric data value to represent
			the LIN Transfers leaving a unit in the compo*/

			num lin_xfer_out{dates, compos, units, lins} init 0;

		/*reads the leaving lin transfer data into the numeric data element*/
%if %eval(&USE_DST = 1)  %then %do;

%put Reading in DST Transfer Out data;
			read data xfers_out into [dates compos units lins]
				lin_xfer_out = col('qty');
%end;
		/*defines a numeric data value to represent
			the mod_levels for the LINs in the component we 
				are processing*/
			num mod_level {lins} init 0;

		/*reads the mod_level data into the numeric data element*/
			read data lins into [lins] 
				mod_level = col('mod_level');

		/*defines the numeric sources for all sublins we use 10 as the initializer so that
				we can direct the model to ignore all substitutions where the source is >= 7*/
			num source{LIN_SUBLIN_SET} init 10;

		/*reads in the source data for the lins/sublins pairings*/
			read data sub_rules into [lins sublins]
				source = col('source');

		/*If two LINs are the same then we don't want to let them 
				substitute for one another*/
			for {<l,s> in LIN_SUBLIN_SET} if l = s then source[l,s] = 10;

		/*defines the numeric data element across the 
			compos, units, lins, and inventory ercs for the 
			data to be stored from the inventory data set.*/
			num inv{compos, units, lins} init 0;
		/*reads in the inventory data from the inventory data set*/
			read data inventory into [compos units lins = lins]
				inv = col('inv');

		/*defines the numeric data element across the 
			dates, compos,lins for procurement data to
				be stored from the procurements data set.*/
			num procs{dates,compos,lins} init 0;

		/*reads in the procurement data from the procurement data set
			into the numerical value*/

		/*Added in a feature to ignore procurements when the NGRER_RUN_TOGGLE is turned on*/
			%if %eval(&NGRER_RUN_TOGGLE ne 1) %then %do;

%put Reading in procurement data;

			read data procurements into [dates compos lins]
				procs = col('qty');
/*				procs = col('procs');*/
			%end;

				
		/*defines the darpl numbers, we use a very large number (100000) 
				to identify values where the DARPL is not observed for 
				a unit entry on a specific date*/
			num darpl{dates, compos, units} init 100000;

		/*reads in the DARPL data across the years, compo, and units*/
			read data darpl into [dates compos units]
				darpl = col('darpl');
/*				darpl = col('priority');*/

		/*defines the numeric data element across the 
			dates, compos,lins for requirement data to
				be stored from the requirements data set.*/
			num reqd_P{ERC_P_ASSIGN_SET} init 0;
			num reqd_A{ERC_A_ASSIGN_SET} init 0;

		/*reads in the requirement data from the requirement data set
			into the numerical value*/
			read data ERC_P_IND_SET into [dates compos units lins]
				reqd_P = col('reqd');
			read data ERC_A_IND_SET into [dates compos units lins]
				reqd_A = col('reqd');


		/*If there are valid intercompo transfer rules we define 
				and read in the valid transfer rules from the 
				compo-transfer data set. We also set intracompo 
				transfers to be permitted*/

		%if %eval(&valid_transfer. > 0) %then %do;	
%put Reading in the Compo Transfer Index Sets;
			set<number, string, string, string, string> ERC_P_XFER_SET;

			read data ERC_P_XFER_IND_SET into ERC_P_XFER_SET = [dates to_compos from_compos units lins];
			
			set<number, string, string, string, string> ERC_A_XFER_SET;

			read data ERC_A_XFER_IND_SET into ERC_A_XFER_SET = [dates to_compos from_compos units lins];

%put Reading in the Compo Substitution Transfer Index Sets;
			set <number, string, string, string, string, string> ERC_P_SUBXFER_SET;
			
			read data ERC_P_SUBXFER_ID_SET into ERC_P_SUBXFER_SET = [dates to_compos from_compos units lins sublins];
			
			set <number, string, string, string, string, string> ERC_A_SUBXFER_SET;
			
			read data ERC_A_SUBXFER_ID_SET into ERC_A_SUBXFER_SET = [dates to_compos from_compos units lins sublins];

		%end;


		/*We define a numerical data element that
			will be used to penalize by lin if modern
			excess is unassigned*/
			num lin_excess_pen{lins} init 0;

			/*this is a for-loop that assigns the mod-5 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 5 then lin_excess_pen[l] = &mod_5_e_pen.;

			/*this is a for-loop that assigns the mod-4 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 4 then lin_excess_pen[l] = &mod_4_e_pen.;

			/*this is a for-loop that assigns the mod-3 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 3 then lin_excess_pen[l] = &mod_3_e_pen.;

			/*this is a for-loop that assigns the mod-2 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 2 then lin_excess_pen[l] = &mod_2_e_pen.;
			/*this is a for-loop that assigns the mod-1 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 1 then lin_excess_pen[l] = &mod_1_e_pen.;

			/*Defines a data element that will store the cummulative procurements
				by year for each LIN and in each Compo.*/
			num lin_procs{dates, compos, lins} init 0;
			/*This for-loop populates the cummulative procurements values
				by year for each LIN and in each Compo.*/
			for {d in dates, c in compos, l in lins} lin_procs[d,c,l] = (sum{v in dates inter {&min_year...d}}(procs[v,c,l]));

			/*Defines a data element that will store the cummulative transfers out
				by year for each LIN, unit, and in each Compo.*/
			num cum_xfers_out{dates, compos, units, lins} init 0;

			/*This for-loop populates the cummulative transfer out values
				by year for each LIN/Unit and in each Compo.*/
			for {d in dates, c in compos, u in units, l in lins} cum_xfers_out[d,c,u,l] 
						= max((sum{v in dates inter {&min_year...d}}(lin_xfer_out[v,c,u,l])),0);


			/*Defines a data element that will store the cummulative transfers in
				by year for each LIN, unit, and in each Compo.*/
			num cum_xfers_in{dates, compos, units, lins} init 0;
			/*This for-loop populates the cummulative transfer out values
				by year for each LIN/Unit and in each Compo.*/
			for {d in dates, c in compos, u in units, l in lins} cum_xfers_in[d,c,u,l] 
						= max((sum{v in dates inter {&min_year...d}}(lin_xfer_add[v,c,u,l])),0);

			num inv_avail{dates, compos, lins} init 0;

			for {d in dates, c in compos, l in lins}
					inv_avail[d,c,l] = 
						max(lin_procs[d,c,l] 
							+ sum{u in units}(inv[c,u,l] + cum_xfers_in[d,c,u,l]  - cum_xfers_out[d,c,u,l]) ,0);

			%put Outputting assignments;
			/*This line of code write lin availability numbers by date, compo, and lin  to a data set*/
			create data lin_avail_&working_comp from [modeling_dates compos lins]
					inv_avail;


%put Defining Non-Substitution Inventory Assignment Decision Variables; 
		/* DJE ADDED TO introduce ERC_P_ASSIGN and ERC_A_ASSIGN decision Variables 07APR2017 1443*/
			var erc_P_assign{ERC_P_ASSIGN_SET} >=0 integer;
			var erc_A_assign{ERC_A_ASSIGN_SET} >=0 integer;

%put Defining Substitution Inventory Assignment Decision Variables;
		/* DJE ADDED TO introduce ERC_P_ASSIGN and ERC_A_ASSIGN decision Variables 10APR2017 1257*/
			var erc_P_subassign{ERC_P_SUBASSIGN_SET} >=0 integer;
			var erc_A_subassign{ERC_A_SUBASSIGN_SET} >=0 integer;


			/*If there are valid intercompo transfer rules we define 
				transfer decision variables and substitution transfer variables*/
			%if %eval(&valid_transfer. > 0) %then %do;
%put Defining Compo Transfer Decision Variables;
			/*Decision Variables for xfers*/
				var erc_p_xfer{ERC_P_XFER_SET} >= 0 integer;
				var erc_a_xfer{ERC_A_XFER_SET} >= 0 integer;
			/*Decision Variables for substitution transfers*/
				var erc_p_subxfer{ERC_P_SUBXFER_SET} >= 0 integer;
				var erc_a_subxfer{ERC_A_SUBXFER_SET} >= 0 integer;

			%end;

			
			/*Defines the non-negative integer decision variable 
					that will store the excess equipment values*/
%put Defining the Aggregate Excess Decision Variables;
			var excess {EXCESS_ID_SET} >= 0 integer;

			/*DJE Adding a break out constraint that places shortage into erc p and erc a sets*/
%put Defining the Shortage Decision Variables;
			var Short_Ps{ERC_P_ASSIGN_SET} >=0 integer;
			var Short_As{ERC_A_ASSIGN_SET} >=0 integer;

			/*Defines the non-negative integer decision variable 
					that will store inventory addition values when 
					we don't have enough equipment to transfer out of a LIN*/
%put Defining an Inventory Relaxation Decision Variables;
			var add_inv {modeling_dates, compos, lins} >= 0 integer;

			%if %eval(&fix_flex. = 1)%then %do;
%put Disabling the Inventory Relaxation Decision Variables;
				for {d in dates, c in compos, l in lins} fix add_inv[d,c,l]=0;
			%end;
			/*The following for-loops fix decision variables that the model will
			not need to solve*/
				/*If a requirement is zero then we fix the shortage value to zero as
				a shortage cannot exist*/
%put Fixing the shortage decision variables to zero when requirement data on a date, compo, unit and lin is zero;
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				if reqd_P[d,c,u,l] = 0 then fix Short_Ps[d,c,u,l] = 0;
			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				if reqd_A[d,c,u,l] = 0 then fix Short_As[d,c,u,l] = 0;	
%put Fixing the assignment decision variables to zero when requirement data on a date, compo, unit and lin is zero;
				/*If a requirement is zero then we fix the assign value to zero as
				a assignment cannot exist*/
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				if reqd_P[d,c,u,l] = 0 then fix erc_p_assign[d,c,u,l] = 0;
			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				if reqd_A[d,c,u,l] = 0 then fix erc_A_assign[d,c,u,l] = 0;
				
		/*If the toggle for modern subs is on then fix the sub_assign to 0 where the mod_Level of a lin is less than or
		equal to the the mod levle of the sub_Lins*/
		%if %eval(&modern_subs. > 0) %then %do;
%put Fixing the substitution decision variables to zero the sublin is less modern than the lin;
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}			
				if mod_level[s]< mod_level[l] then fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				if mod_level[s]< mod_level[l] then fix erc_A_subassign[ d, c, u, l, s] = 0
			;
			%if %eval(&valid_transfer. > 0) %then %do;
			/*fixing the sub transfer rules*/
%put Fixing the Compo transfers through less modern substitutions to zero;

			for {<d,t,f,u,l,s> in ERC_P_SUBXFER_SET}			
				if mod_level[s]< mod_level[l] then fix erc_p_subxfer[ d, t, f, u, l, s] = 0
			;
			for {<d,t,f,u,l,s> in ERC_A_SUBXFER_SET}			
				if mod_level[s]< mod_level[l] then fix erc_a_subxfer[ d, t, f, u, l, s] = 0
			;
			%end;
		%end;

		/*If the toggle for no-subs is on then fix the sub_assign to 0 for all of these decision variables*/
		%if %eval(&subs_allowed. = 0) %then %do;
%put Fixing the substitution decision variables to zero because none are permitted in this run;
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}			
				fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				fix erc_A_subassign[ d, c, u, l, s] = 0
			;
			%if %eval(&valid_transfer. > 0) %then %do;
			/*fixing the sub transfer rules*/
%put Fixing the Compo transfers through substitutions to zero;

				for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET}
					fix erc_p_subxfer[d,c,f,u,l,s] = 0
				;
						
				for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET}
					fix erc_a_subxfer[d,c,f,u,l,s] = 0
				;

			%end;
		%end;

		/*Added in a feature to fix the assignment of inventory to 0 for all ML1 and ML2 LINs when
			the NGRER_RUN_TOGGLE is turned on*/
			%if %eval(&NGRER_RUN_TOGGLE = 1) %then %do;

%put Fixing the assignment of ML1 and ML2 inventory to 0;

				/*Fixing ERC P Assignments*/
					for {<d,c,u,l> in ERC_P_ASSIGN_SET} if mod_level[l] <3 then fix erc_P_assign[d, c, u, l] = 0;
				/*Fixing ERC A Assignments*/
					for {<d,c,u,l> in ERC_A_ASSIGN_SET} if mod_level[l] <3 then fix erc_A_assign[d, c, u, l] = 0;
				/*Fixing ERC P Sub Assignments*/
					for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET} if mod_level[s] <3 then fix erc_p_subassign[ d, c, u, l, s] = 0;
				/*Fixing ERC A Sub Assignments*/
					for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET} if mod_level[s] <3 then fix erc_a_subassign[ d, c, u, l, s] = 0;
				%if %eval(&valid_transfer. > 0) %then %do;
					/*Fixing ERC P Xfer Assignments*/
					for{<d,c,f,u,l> in ERC_P_XFER_SET} if mod_level[l] <3 then fix erc_p_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l> in ERC_A_XFER_SET} if mod_level[l] <3 then fix erc_a_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET} if mod_level[s] <3 then fix erc_P_subxfer[d,c,f,u,l,s] = 0;
					for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET} if mod_level[s] <3 then fix erc_A_subxfer[d,c,f,u,l,s] = 0;

					/*fixing these variables to 0 for years earlier than a user specified CASC_YEAR*/
%put Fixing the cascading to 0 in years before &CASC_YEAR;	
					for{<d,c,f,u,l> in ERC_P_XFER_SET} if d < &CASC_YEAR. then fix erc_p_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l> in ERC_A_XFER_SET} if d < &CASC_YEAR. then fix erc_a_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET} if d < &CASC_YEAR. then fix erc_P_subxfer[d,c,f,u,l,s] = 0;
					for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET} if d < &CASC_YEAR. then fix erc_A_subxfer[d,c,f,u,l,s] = 0;


				%end;
			%end;


			/*If a the source for a sub-rule is greater than or equal to 7 thn we fix
				substitutions assignments to 0*/
%put Fixing the substitution decision variables to zero for in lieu of substutions;	
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}
				if source[l,s] >= 7 then fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				if source[l,s] >= 7 then fix erc_a_subassign[ d, c, u, l, s] = 0
			;
%if %eval(&valid_transfer. > 0) %then %do;	
%put Fixing the substitution transfer decision variables to zero for in lieu of substutions;		
			for {<d,f,c,u,l,s> in ERC_P_SUBXFER_SET}			
				if source[l,s] >= 7 then fix erc_p_subxfer[d,f,c,u,l,s] = 0
			;
			
			for {<d,f,c,u,l,s> in ERC_A_SUBXFER_SET}			
				if source[l,s] >= 7 then fix erc_a_subxfer[d,f,c,u,l,s] = 0
			;
%end;
			/*If we are freezing the first year of inventory to what it is then we 
			set a constraint to make all assignments and excess to the
			inveentory in the first year*/

			%if %eval(&freeze_first_two. = 1) %then %do;
%put Constraint that Fixes the First two years is active;
			Con Freeze_Year_1{ d in modeling_dates inter {&min_year..&year_two.},c in compos, l in lins, u in units}:
					sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,u,l])
						+ sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,u,l])
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,u,s,l]))
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,u,s,l]))
					= 
					inv[c,u,l]+ cum_xfers_in[d,c,u,l] - cum_xfers_out[d,c,u,l];
			%end;

/*This if-then-do statement will define component level fencing constraints that ensure the LIN 
			level inventory balances out with the initial inventory plus procurements allocated
			to each component*/

			%if %eval(&valid_transfer. = 0) %then %do;	
%put We are using the constraints that do not enable compo transfers;		
			/*New inventory constraints to handle the tuple based index sets*/
				CON INV_MGMT_Y1A {d in dates inter {&min_year.}, c in compos, l in lins }:
						sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ excess[d,c,l]	
							= 
							inv_avail[d,c,l]
							+ add_inv[d,c,l];
	
/*New inventory constraints to handle the tuple based index sets*/
				Con INV_MGMT_YNA {d in modeling_dates diff {&min_year.}, c in compos, l in lins}:
					sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ excess[d,c,l]				
					/*total inventory within the component + procurements through the date of the constraint*/
							=
							inv_avail[d,c,l]
							+ (add_inv[d,c,l]);

				/*ERC P Shortage break out*/
				Con Shortage_Value_P {<d,c,u,l> in ERC_P_ASSIGN_SET}:
					Short_Ps[d,c,u,l] + erc_p_assign[d,c,u,l]
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target.  * reqd_P[d,c,u,l])
				;
				/*ERC A Shortage break out*/
				Con Shortage_Value_A {<d,c,u,l> in ERC_A_ASSIGN_SET}:
					Short_As[d,c,u,l] + erc_a_assign[d,c,u,l]						
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l and sublin = s }<date,compo,unit,lin,sublin>)}(erc_a_subassign[d,c,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target.  * reqd_A[d,c,u,l])
				;
			%end;

			%else %do;	

%put We are using the constraints that enable compo transfers;
		%put definining the Year 1 inventory flow constraint;
			/*New inventory constraints to handle the tuple based index sets*/
				CON INV_MGMT_Y1A {d in dates inter {&min_year.}, c in compos, l in lins }:
						sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ (excess[d,c,l])
						+ sum{<date,t,compo,u,lin> in ERC_P_XFER_SET: date = d and compo = c and lin=l}(erc_p_xfer[date,t,compo,u,lin])
						+ sum{<date,t,compo,u,lin> in ERC_A_XFER_SET: date = d and compo = c and lin=l}(erc_A_xfer[date,t,compo,u,lin])
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_P_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_p_subxfer[date,t,compo,u,s,lin]))
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_A_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_a_subxfer[date,t,compo,u,s,lin]))
							= 
							inv_avail[d,c,l] + add_inv[d,c,l]
				;
			/*New inventory constraints to handle the tuple based index sets*/
				%put definining the Year 2 through n inventory flow constraint;
				Con INV_MGMT_YNA {d in modeling_dates diff {&min_year.}, c in compos, l in lins}:
					sum{ v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{ v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{ v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ (excess[d,c,l])						
						+ sum{<date,t,compo,u,lin> in ERC_P_XFER_SET: date = d and compo = c and lin=l}(erc_p_xfer[date,t,compo,u,lin])
						+ sum{<date,t,compo,u,lin> in ERC_A_XFER_SET: date = d and compo = c and lin=l}(erc_A_xfer[date,t,compo,u,lin])
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_P_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_p_subxfer[date,t,compo,u,s,lin]))
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_A_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_a_subxfer[date,t,compo,u,s,lin]))
					/*total inventory within the component + procurements through the date of the constraint*/
							=
							inv_avail[d,c,l] + (add_inv[d,c,l])
				;
				/*ERC P Shortage break out*/
				Con Shortage_Value_P {<d,c,u,l> in ERC_P_ASSIGN_SET}:
					Short_Ps[d,c,u,l] + erc_p_assign[d,c,u,l]
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
						+ sum{f in compos diff {c}}
							(sum{(setof{<date, to, from, unit, lin> in ERC_P_XFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l}
							<date,to,from,unit,lin>)}(erc_p_xfer[d,c,f,u,l]))
						+ sum{f in compos diff {c}, s in sublins diff {l}}
							(sum{(setof{<date, to, from, unit, lin, sublin> in ERC_P_SUBXFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l and sublin = s}
							<date,to,from,unit,lin,sublin>)}(erc_p_subxfer[d,c,f,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target. * reqd_P[d,c,u,l])
				;
				/*ERC A Shortage break out*/
				Con Shortage_Value_A {<d,c,u,l> in ERC_A_ASSIGN_SET}:
					Short_As[d,c,u,l] + erc_a_assign[d,c,u,l]						
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l and sublin = s }<date,compo,unit,lin,sublin>)}(erc_a_subassign[d,c,u,l,s]))
						+ sum{f in compos diff {c}}
							(sum{(setof{<date, to, from, unit, lin> in ERC_A_XFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l}
							<date,to,from,unit,lin>)}(erc_a_xfer[d,c,f,u,l]))
						+ sum{f in compos diff {c}, s in sublins diff {l}}
							(sum{(setof{<date, to, from, unit, lin, sublin> in ERC_A_SUBXFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l and sublin = s}
							<date,to,from,unit,lin,sublin>)}(erc_a_subxfer[d,c,f,u,l,s]))

						= ceil( &fill_target. * reqd_A[d,c,u,l])
				;
			%end;
						
		/*Minimize the objective function value relative to the overall shortages, modern-excess, and transfers that occur*/

%put Setting up the objective function;
		min z = 
		/*Shortage penalties*/
			%put Penalizing ERC P Shortages;
				&p_pri. * sum{<d,c,u,l> in ERC_P_ASSIGN_SET}(
							(100000-darpl[d,c,u]) * Short_Ps[d,c,u,l])
			%put Penalizing ERC A Shortages;
				+ &a_pri. * sum{<d,c,u,l> in ERC_A_ASSIGN_SET}(
							(100000-darpl[d,c,u]) * Short_As[d,c,u,l])
				/*+ &b_pri. * sum{d in modeling_dates, c in compos, u in units, l in reqd_lins, e in reqd_ercs inter {"B"}}(
							(100000-darpl[d,c,u]) * shortage[d,c,u,l,e])
				+ &c_pri. * sum{d in modeling_dates, c in compos, u in units, l in reqd_lins, e in reqd_ercs inter {"C"}}(
							(100000-darpl[d,c,u]) * shortage[d,c,u,l,e])*/
			/*if we have valid transfer rules we slightly penalize transfering equipment across component to
				reduce the possibility of multiple optimal solutions and erroneous transfers*/
			%if %eval(&valid_transfer. > 0) %then %do;

				%if %eval(&trans_pen. <= 0) %then %put Rewarding Compo Transfers;
				%else %put Penalizing Compo Transfers;
				+ &trans_pen. * (
					sum{<d,to,from,u,l> in ERC_P_XFER_SET}(erc_p_xfer[d,to,from,u,l])
					+
					sum{<d,to,from,u,l> in ERC_A_XFER_SET}(erc_a_xfer[d,to,from,u,l])
					+
					sum{<d,to,from,u,l,s> in ERC_P_SUBXFER_SET}(erc_p_subxfer[d,to,from,u,l,s])
					+
					sum{<d,to,from,u,l,s> in ERC_A_SUBXFER_SET}(erc_a_subxfer[d,to,from,u,l,s])
					)
				 
			%end;
			%put Penalizing Unit transfers that move inventory away from where they were originally;
			/*We penalize spurious assignment that while the same as another we want consistent
			inventory assignments over the years and units*/
				+ &unit_yearly_xfer_pen. * 
					(sum{d in modeling_dates inter {&first_year.}}
							sum{<sd,compo,unit,lin> in ERC_P_ASSIGN_SET: sd = d}
						(
						  erc_p_assign[sd,compo,unit,lin]-
						sum {f in modeling_dates diff {&first_year.}}
							sum{<fy,sc,su,sl> in ERC_P_ASSIGN_SET: fy = f and sc = compo and su = unit and sl = lin}
									(erc_p_assign[fy, sc, su, sl])
						)
					+
					sum{d in modeling_dates inter {&first_year.}}
							sum{<sd,compo,unit,lin> in ERC_A_ASSIGN_SET: sd = d}
						(
						  erc_a_assign[sd,compo,unit,lin]-
						sum {f in modeling_dates diff {&first_year.}}
							sum{<fy,sc,su,sl> in ERC_A_ASSIGN_SET: fy = f and sc = compo and su = unit and sl = lin}
									(erc_a_assign[fy, sc, su, sl])
						)
					)
		/*Modern Excess inventory penalties*/
				+ sum{d in modeling_dates, c in compos, l in lins}(lin_excess_pen[l] * excess[d,c,l])
		/*Substitution assignment penalties*/
				+ &sub_assign_pen. * 
					(	  sum{<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}(erc_p_subassign[d,c,u,l,s])
						+ sum{<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}(erc_a_subassign[d,c,u,l,s])
						%if %eval(&valid_transfer. > 0) %then %do;
						+ sum{<d,to,from,u,l,s> in ERC_P_SUBXFER_SET}(erc_p_subxfer[d,to,from,u,l,s])
						+ sum{<d,to,from,u,l,s> in ERC_A_SUBXFER_SET}(erc_a_subxfer[d,to,from,u,l,s])
						%end;
					)
		/*Penalty for giving away inventory that a unit has in a future year*/
		/*Big-M penalty for having to add inventory to make the inventory constraints feasible*/
		%if %eval(&fix_flex. = 0) %then %put Penalizing the use of the slack variable;
				+ 10000000* (sum{d in modeling_dates, c in compos, l in lins}(add_inv[d,c,l]))
		;
		/*This line of code will envoke the solver and as long as we are within 5% of a linear optimum we are good*/
	%put Time to solve this thing!;
			solve with milp / relobjgap= .05;

			%put Outputting assignments;
		/*This line of code write all assignments to a data set*/
			create data P_assigned_&working_comp from [modeling_dates compos units lins]
					erc_p_assign;
			create data A_assigned_&working_comp from [modeling_dates compos units lins]
					erc_A_assign;
			%put Outputting substitutions;
		/*This line of code write all substitutions to a data set*/
			create data A_subbed_&working_comp from [modeling_dates compos units lins sublins]
					erc_a_subassign;
			create data P_subbed_&working_comp from [modeling_dates compos units lins sublins]
					erc_p_subassign;
		/*These line of code write all transfers if there are valid transfers allowed to a data set*/
		%if %eval(&valid_transfer. > 0) %then %do;
		/*create data from the transfers*/

		%put Outputting Transfers;

			create data P_XFERS_&working_comp from [modeling_dates to_compos from_compos units lins]
					erc_p_xfer;

			create data A_XFERS_&working_comp from [modeling_dates to_compos from_compos units lins]
					erc_A_xfer;

			create data P_SUBXFERS_&working_comp from [modeling_dates to_compos from_compos units lins sublins]
					erc_P_subxfer;

			create data A_SUBXFERS_&working_comp from [modeling_dates to_compos from_compos units lins sublins]
					erc_A_subxfer;


		%end;

		
		%put Outputting shortfalls;
		/*These line of code write all shortages to a data set*/
			create data P_shortage_&working_comp from [modeling_dates compos units lins]
				short_ps ;
			create data A_shortage_&working_comp from [modeling_dates compos units lins]
				short_as ;

		/*This line of code defines a numerical value to store on hand positions across the master
				index sets*/
			num P_onhand{modeling_dates, compos, units, lins} init 0;
			num A_onhand{modeling_dates, compos, units, lins} init 0;
		
				%put Creating aggregate on hand values;
		
		/*This for-loop populates the onhand values to the sum of assignments, transfers, 
			and substitutions*/
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				P_onhand[d,c,u,l] = 
					erc_p_assign[d,c,u,l]
					+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
				
%if %eval(&valid_transfer. > 0) %then %do;	
%put ERC P transfers are adding into the reported on hand amounts;
					+ sum{f in compos diff {c}}(sum{(setof{<date,to_compo,from_compo,unit,lin> in ERC_P_XFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l}
							<date,to_compo,from_compo,unit,lin>)}(erc_p_xfer[d,c,f,u,l]))
					+ sum{f in compos diff {c}, s in sublins diff {l}}(sum{(setof{<date,to_compo,from_compo,unit,lin,sublin> in ERC_P_SUBXFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l and sublin = s}
							<date,to_compo,from_compo,unit,lin,sublin>)}(erc_p_subxfer[d,c,f,u,l,s]))
%end;
			;

			%put outputting on hand values with requirements and shortages;
			create data P_onhand_&working_comp from [modeling_dates compos units lins]
				reqd_P P_OnHand short_ps;

			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				A_onhand[d,c,u,l] = 
					erc_A_assign[d,c,u,l]
					+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_A_subassign[d,c,u,l,s]))
%if %eval(&valid_transfer. > 0) %then %do;	
%put ERC A transfers are adding into the reported on hand amounts;
					+ sum{f in compos diff {c}}(sum{(setof{<date,to_compo,from_compo,unit,lin> in ERC_A_XFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l}
							<date,to_compo,from_compo,unit,lin>)}(erc_a_xfer[d,c,f,u,l]))
					+ sum{f in compos diff {c}, s in sublins diff {l}}(sum{(setof{<date,to_compo,from_compo,unit,lin,sublin> in ERC_A_SUBXFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l and sublin = s}
							<date,to_compo,from_compo,unit,lin,sublin>)}(erc_a_subxfer[d,c,f,u,l,s]))
%end;
			;

			create data A_onhand_&working_comp from [modeling_dates compos units lins]
				reqd_a A_OnHand short_as;

				%if %eval(&fix_flex. = 0) %then %put Outputting the amount of slack used;
/*This line of code creates the infeasbility additions*/
			create data Infe_Adds_&working_comp from [modeling_dates compos lins]
				add_inv;
 			%put Outputting the excess inventory used;
			/*DJE Added to export excess observations*/
			create data excess_&working_comp from [modeling_dates compos lins]
					excess;
		quit;

	OPTIONS NOFULLSTIMER;

		/*This is test data to see if the ERC_P_Assignments are making the correct
			assignments*/

		/*DJE Added to accommodate for new variables index sets 11APR2017*/
		proc sql;
			insert into idm_o.assigned
			select
				modeling_dates,
				compos,
				units,
				lins,
				"P" as ercs,
				erc_p_assign as assign
			from P_assigned_&working_comp where erc_p_assign >0;
		quit;

		/*DJE Added to accommodate for new variables index sets 11APR2017*/
		proc sql;
			insert into idm_o.assigned
			select
				modeling_dates,
				compos,
				units,
				lins,
				"A" as ercs,
				erc_A_assign as assign
			from A_assigned_&working_comp where erc_A_assign >0;
		quit;
		
		/*DJE Added to accommodate for new variables index sets 11APR2017*/
			proc sql;
				insert into idm_o.subbed
				select
					modeling_dates,
					compos,
					units,
					lins,
					sublins,
					"P" as ercs,
					erc_p_subassign as subbed
				from P_subbed_&working_comp  /*where erc_p_subassign >0*/;
			quit;
			
		/*DJE Added to accommodate for new variables index sets 11APR2017*/
			proc sql;
				insert into idm_o.subbed
				select
					modeling_dates,
					compos,
					units,
					lins,
					sublins,
					"A" as ercs,
					erc_A_subassign as subbed
				from A_subbed_&working_comp  /*where erc_a_subassign >0*/;
			quit;
				
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/

			
			data Infe_Adds_append;
				set Infe_Adds_&working_comp;

				if add_inv > 0;
				component = &working_comp.;

			run;

			
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/

		proc sql;
			insert into idm_o.shortage
			select
				modeling_dates,
				compos,
				units,
				lins,
				"P" as ercs,
				Short_Ps as shortage
			from P_shortage_&working_comp  where Short_Ps > 0;
		quit;

		
		proc sql;
			insert into idm_o.shortage
			select
				modeling_dates,
				compos,
				units,
				lins,
				"A" as ercs,
				Short_As as shortage
			from A_shortage_&working_comp  where Short_As > 0;
		quit;
			
	
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/
			
		proc sql;
			insert into idm_o.inv_positions
			select
				modeling_dates,
				compos,
				units,
				lins,
				"P" as ercs,
				reqd_p as reqd,
				p_onhand as onhand,
				short_ps as shortages,
				0 as excess
			from P_onhand_&working_comp where reqd_P>0 or short_ps>0;
		quit;
		
		proc sql;
			insert into idm_o.inv_positions
			select
				modeling_dates,
				compos,
				units,
				lins,
				"A" as ercs,
				reqd_a as reqd,
				a_onhand as onhand,
				short_as as shortages,
				0 as excess
			from a_onhand_&working_comp where reqd_a>0 or short_as>0;
		quit;

		
		proc sql;
			insert into idm_o.inv_positions
			select
				modeling_dates,
				compos,
				"EXCESS" as units,
				lins,
				"X" as ercs,
				0 as reqd,
				0 as onhand,
				0 as shortages,
				excess as excess
			from excess_&working_comp where excess>0;
		quit;
			
			proc append base = idm_o.Infe_Adds data = Infe_Adds_append;
			run;


			
	%if %eval(&valid_transfer. > 0) %then %do;		
%put Appending the compo transfers to the result sets;

/*append the erc p compo transfers*/
		proc sql;
			insert into idm_o.xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				"P" as ercs,
				erc_p_xfer as compo_transfer
			from P_xfers_&working_comp where erc_p_xfer > 0 ;
		quit;
/*append the erc a compo transfers*/
		proc sql;
			insert into idm_o.xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				"A" as ercs,
				erc_a_xfer as compo_transfer
			from a_xfers_&working_comp where erc_a_xfer > 0 ;
		quit;
/*append the erc p compo substitution transfers*/
		proc sql;
			insert into idm_o.sub_xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				sublins,
				"P" as ercs,
				erc_p_subxfer as compo_sub_transfer
			from p_subxfers_&working_comp /*where erc_p_subxfer > 0 */;
		quit;
/*append the erc a compo substitution transfers*/
		proc sql;
			insert into idm_o.sub_xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				sublins,
				"A" as ercs,
				erc_a_subxfer as compo_sub_transfer
			from a_subxfers_&working_comp /*where erc_a_subxfer > 0*/ ;
		quit;

	%end;

%mend;


/*this line of code envokes the macro defined above*/
%run_opt_clusters;



file name:  model_optimization.sas

/*The macro defined below contains the optimization and multiple steps to append
the results of the model to the permenant datasets in IDM_O*/

%macro run_opt_model;

OPTIONS FULLSTIMER;

		proc optmodel;


			/*This line of code in the proc-optmodel environment
				creates a numeric data set to store date values*/
			set <number> dates ;
			/*This line of code in the proc-optmodel environment
				creates a numeric data set of modeling dates 
				that spans the first_year and last_year macro variables*/
			set <number> modeling_dates = {&first_year...&last_year.};
			/*This line of code in the proc-optmodel environment
				creates a string based index set for required LINs 
				to be stored after being read into it*/
			set <string> reqd_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for inventory LINs 
				to be stored after being read into it*/
			set <string> inv_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for sub-rules LINs 
				to be stored after being read into it*/
			set <string> sub_lins;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for Units to be
				stored after being read into it*/
			set <string> units ;
			/*This line of code in the proc-optmodel environment
				creates a string based index set for compos to be
				stored after being read into it*/
			set <string> compos ;

	/*DJE Additions That Enable Tightening of Constraints*/

			/*The erc P assign set will take down
			the years, compos, units and lIns where ERC P inventory
			is needed.*/
			set <number,string,string,string> ERC_P_ASSIGN_SET;


			/*The erc P assign set is read in from the data set
			above created in the run opt clusters module.*/

			read data ERC_P_IND_SET into ERC_P_ASSIGN_SET = [dates compos units lins];
			
			/*The erc a assign set will take down
			the years, compos, units and lIns where ERC P inventory
			is needed.*/
			set <number,string,string,string> ERC_A_ASSIGN_SET;

			/*The erc a assign set is read in from the data set
			above created in the run opt clusters module.*/

			read data ERC_A_IND_SET into ERC_A_ASSIGN_SET = [dates compos units lins];

			/*This set is similar to the other erc P assign set but includes
			a slot for sublins.*/
			set <number,string,string,string, string> ERC_P_SUBASSIGN_SET;

			/*The erc P sub-assign set is read in from the data set
			above created in the run opt clusters module.*/
			read data ERC_P_SUBID_SET into ERC_P_SUBASSIGN_SET = [dates compos units lins sublins];
			/*This set is similar to the other erc A assign set but includes
			a slot for sublins.*/
			set <number,string,string,string,string> ERC_A_SUBASSIGN_SET;

			/*The erc A sub-assign set is read in from the data set
			above created in the run opt clusters module.*/
			read data ERC_A_SUBID_SET into ERC_A_SUBASSIGN_SET = [dates compos units lins sublins];
						
			/*The lin/sublin set will capture lin-sublin pairings as needed.*/
			set <string,string> LIN_SUBLIN_SET;

			/*The SUBLIN_SET set is read in from the data set
			above created in the run opt clusters module.*/

			read data SUBLIN_ID_SET into LIN_SUBLIN_SET = [lins sublins];
			
			/*This line of code in the proc-optmodel environment
				creates a numerical set for sub-rule sources that
				are to be ignored*/
			set <number> sources = &sub_ignore_set;

		/*Read data into the sets*/
			
			/*This line of code in the proc-optmodel environment
				reads the dates in the dates input set
				into the numerical index set dates*/
			
			read data idm_i.dates into dates = [dates];
			/*This line of code in the proc-optmodel environment
				reads the required lins in the reqd_lins input set
				into the string index set reqd_lins*/	
			read data reqd_lins into reqd_lins = [lins];	
			/*This line of code in the proc-optmodel environment
				reads the inventory lins in the reqd_lins input set
				into the string index set inv_lins*/	
			read data inv_lins into inv_lins = [lins];
			/*This line of code in the proc-optmodel environment
				reads the sub lins in the lmdb.lins input set
				into the string index set sub_lins*/
			read data lmdb.lins into sub_lins = [lins];
			/*This line of code in the proc-optmodel environment
				reads the units in the unit_compo_number input set
				into the string index set units*/
			read data unit_compo_number into units = [units];
			/*This line of code in the proc-optmodel environment
				reads the compos in the p_compos input set
				into the string index set compos*/
			read data p_compos into compos = [compos];

			/*This line of code creates a master index
			set of all LINs*/
			set <string> lins = (reqd_lins union inv_lins/* union sub_lins*/);  /* added sub_lins JUN2021 - LHB*/
			/*This line of code creates a master index
			set of all LINs for use as sublins*/
			set <string> sublins = (reqd_lins union inv_lins/* union sub_lins*/);  /* added sub_lins JUN2021 - LHB*/			

			/*This line of code creates an index set
			called from_compos based on the compos index set*/
			set <string> from_compos = compos;
			/*This line of code creates an index set
			called to_compos based on the compos index set*/
			set <string> to_compos = compos;
			
			/*An index set of Dates, compos and LINs to fill with
			excess inventory*/
			set<num,string,string> EXCESS_ID_SET = {dates cross compos cross lins};

		/*defines a numeric data value to represent
			the LIN Transfers coming into a unit in the compo*/

			num lin_xfer_add{dates, compos, units, lins} init 0;

		/*reads the incoming lin transfer data into the numeric data element*/
%if %eval(&USE_DST = 1)  %then %do;

%put Reading in DST Transfer In data;
			read data xfers_in into [dates compos units lins]
				lin_xfer_add = col('qty');
%end;
		/*defines a numeric data value to represent
			the LIN Transfers leaving a unit in the compo*/

			num lin_xfer_out{dates, compos, units, lins} init 0;

		/*reads the leaving lin transfer data into the numeric data element*/
%if %eval(&USE_DST = 1)  %then %do;

%put Reading in DST Transfer Out data;
			read data xfers_out into [dates compos units lins]
				lin_xfer_out = col('qty');
%end;
		/*defines a numeric data value to represent
			the mod_levels for the LINs in the component we 
				are processing*/
			num mod_level {lins} init 0;

		/*reads the mod_level data into the numeric data element*/
			read data lins into [lins] 
				mod_level = col('mod_level');

		/*defines the numeric sources for all sublins we use 10 as the initializer so that
				we can direct the model to ignore all substitutions where the source is >= 7*/
			num source{LIN_SUBLIN_SET} init 10;

		/*reads in the source data for the lins/sublins pairings*/
			read data sub_rules into [lins sublins]
				source = col('source');

		/*If two LINs are the same then we don't want to let them 
				substitute for one another*/
			for {<l,s> in LIN_SUBLIN_SET} if l = s then source[l,s] = 10;

		/*defines the numeric data element across the 
			compos, units, lins, and inventory ercs for the 
			data to be stored from the inventory data set.*/
			num inv{compos, units, lins} init 0;
		/*reads in the inventory data from the inventory data set*/
			read data inventory into [compos units lins = lins]
				inv = col('inv');

		/*defines the numeric data element across the 
			dates, compos,lins for procurement data to
				be stored from the procurements data set.*/
			num procs{dates,compos,lins} init 0;

		/*reads in the procurement data from the procurement data set
			into the numerical value*/

		/*Added in a feature to ignore procurements when the NGRER_RUN_TOGGLE is turned on*/
			%if %eval(&NGRER_RUN_TOGGLE ne 1) %then %do;

%put Reading in procurement data;

			read data procurements into [dates compos lins]
				procs = col('qty');
/*				procs = col('procs');*/
			%end;

				
		/*defines the darpl numbers, we use a very large number (100000) 
				to identify values where the DARPL is not observed for 
				a unit entry on a specific date*/
			num darpl{dates, compos, units} init 100000;

		/*reads in the DARPL data across the years, compo, and units*/
			read data darpl into [dates compos units]
				darpl = col('darpl');
/*				darpl = col('priority');*/

		/*defines the numeric data element across the 
			dates, compos,lins for requirement data to
				be stored from the requirements data set.*/
			num reqd_P{ERC_P_ASSIGN_SET} init 0;
			num reqd_A{ERC_A_ASSIGN_SET} init 0;

		/*reads in the requirement data from the requirement data set
			into the numerical value*/
			read data ERC_P_IND_SET into [dates compos units lins]
				reqd_P = col('reqd');
			read data ERC_A_IND_SET into [dates compos units lins]
				reqd_A = col('reqd');


		/*If there are valid intercompo transfer rules we define 
				and read in the valid transfer rules from the 
				compo-transfer data set. We also set intracompo 
				transfers to be permitted*/

		%if %eval(&valid_transfer. > 0) %then %do;	
%put Reading in the Compo Transfer Index Sets;
			set<number, string, string, string, string> ERC_P_XFER_SET;

			read data ERC_P_XFER_IND_SET into ERC_P_XFER_SET = [dates to_compos from_compos units lins];
			
			set<number, string, string, string, string> ERC_A_XFER_SET;

			read data ERC_A_XFER_IND_SET into ERC_A_XFER_SET = [dates to_compos from_compos units lins];

%put Reading in the Compo Substitution Transfer Index Sets;
			set <number, string, string, string, string, string> ERC_P_SUBXFER_SET;
			
			read data ERC_P_SUBXFER_ID_SET into ERC_P_SUBXFER_SET = [dates to_compos from_compos units lins sublins];
			
			set <number, string, string, string, string, string> ERC_A_SUBXFER_SET;
			
			read data ERC_A_SUBXFER_ID_SET into ERC_A_SUBXFER_SET = [dates to_compos from_compos units lins sublins];

		%end;


		/*We define a numerical data element that
			will be used to penalize by lin if modern
			excess is unassigned*/
			num lin_excess_pen{lins} init 0;

			/*this is a for-loop that assigns the mod-5 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 5 then lin_excess_pen[l] = &mod_5_e_pen.;

			/*this is a for-loop that assigns the mod-4 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 4 then lin_excess_pen[l] = &mod_4_e_pen.;

			/*this is a for-loop that assigns the mod-3 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 3 then lin_excess_pen[l] = &mod_3_e_pen.;

			/*this is a for-loop that assigns the mod-2 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 2 then lin_excess_pen[l] = &mod_2_e_pen.;
			/*this is a for-loop that assigns the mod-1 excess penalty
			for all applicable LINs*/
			for {l in lins}
				if mod_level[l] = 1 then lin_excess_pen[l] = &mod_1_e_pen.;

			/*Defines a data element that will store the cummulative procurements
				by year for each LIN and in each Compo.*/
			num lin_procs{dates, compos, lins} init 0;
			/*This for-loop populates the cummulative procurements values
				by year for each LIN and in each Compo.*/
			for {d in dates, c in compos, l in lins} lin_procs[d,c,l] = (sum{v in dates inter {&min_year...d}}(procs[v,c,l]));

			/*Defines a data element that will store the cummulative transfers out
				by year for each LIN, unit, and in each Compo.*/
			num cum_xfers_out{dates, compos, units, lins} init 0;

			/*This for-loop populates the cummulative transfer out values
				by year for each LIN/Unit and in each Compo.*/
			for {d in dates, c in compos, u in units, l in lins} cum_xfers_out[d,c,u,l] 
						= max((sum{v in dates inter {&min_year...d}}(lin_xfer_out[v,c,u,l])),0);


			/*Defines a data element that will store the cummulative transfers in
				by year for each LIN, unit, and in each Compo.*/
			num cum_xfers_in{dates, compos, units, lins} init 0;
			/*This for-loop populates the cummulative transfer out values
				by year for each LIN/Unit and in each Compo.*/
			for {d in dates, c in compos, u in units, l in lins} cum_xfers_in[d,c,u,l] 
						= max((sum{v in dates inter {&min_year...d}}(lin_xfer_add[v,c,u,l])),0);

			num inv_avail{dates, compos, lins} init 0;

			for {d in dates, c in compos, l in lins}
					inv_avail[d,c,l] = 
						max(lin_procs[d,c,l] 
							+ sum{u in units}(inv[c,u,l] + cum_xfers_in[d,c,u,l]  - cum_xfers_out[d,c,u,l]) ,0);

			%put Outputting assignments;
			/*This line of code write lin availability numbers by date, compo, and lin  to a data set*/
			create data lin_avail_&working_comp from [modeling_dates compos lins]
					inv_avail;


%put Defining Non-Substitution Inventory Assignment Decision Variables; 
		/* DJE ADDED TO introduce ERC_P_ASSIGN and ERC_A_ASSIGN decision Variables 07APR2017 1443*/
			var erc_P_assign{ERC_P_ASSIGN_SET} >=0 integer;
			var erc_A_assign{ERC_A_ASSIGN_SET} >=0 integer;

%put Defining Substitution Inventory Assignment Decision Variables;
		/* DJE ADDED TO introduce ERC_P_ASSIGN and ERC_A_ASSIGN decision Variables 10APR2017 1257*/
			var erc_P_subassign{ERC_P_SUBASSIGN_SET} >=0 integer;
			var erc_A_subassign{ERC_A_SUBASSIGN_SET} >=0 integer;


			/*If there are valid intercompo transfer rules we define 
				transfer decision variables and substitution transfer variables*/
			%if %eval(&valid_transfer. > 0) %then %do;
%put Defining Compo Transfer Decision Variables;
			/*Decision Variables for xfers*/
				var erc_p_xfer{ERC_P_XFER_SET} >= 0 integer;
				var erc_a_xfer{ERC_A_XFER_SET} >= 0 integer;
			/*Decision Variables for substitution transfers*/
				var erc_p_subxfer{ERC_P_SUBXFER_SET} >= 0 integer;
				var erc_a_subxfer{ERC_A_SUBXFER_SET} >= 0 integer;

			%end;

			
			/*Defines the non-negative integer decision variable 
					that will store the excess equipment values*/
%put Defining the Aggregate Excess Decision Variables;
			var excess {EXCESS_ID_SET} >= 0 integer;

			/*DJE Adding a break out constraint that places shortage into erc p and erc a sets*/
%put Defining the Shortage Decision Variables;
			var Short_Ps{ERC_P_ASSIGN_SET} >=0 integer;
			var Short_As{ERC_A_ASSIGN_SET} >=0 integer;

			/*Defines the non-negative integer decision variable 
					that will store inventory addition values when 
					we don't have enough equipment to transfer out of a LIN*/
%put Defining an Inventory Relaxation Decision Variables;
			var add_inv {modeling_dates, compos, lins} >= 0 integer;

			%if %eval(&fix_flex. = 1)%then %do;
%put Disabling the Inventory Relaxation Decision Variables;
				for {d in dates, c in compos, l in lins} fix add_inv[d,c,l]=0;
			%end;
			/*The following for-loops fix decision variables that the model will
			not need to solve*/
				/*If a requirement is zero then we fix the shortage value to zero as
				a shortage cannot exist*/
%put Fixing the shortage decision variables to zero when requirement data on a date, compo, unit and lin is zero;
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				if reqd_P[d,c,u,l] = 0 then fix Short_Ps[d,c,u,l] = 0;
			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				if reqd_A[d,c,u,l] = 0 then fix Short_As[d,c,u,l] = 0;	
%put Fixing the assignment decision variables to zero when requirement data on a date, compo, unit and lin is zero;
				/*If a requirement is zero then we fix the assign value to zero as
				a assignment cannot exist*/
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				if reqd_P[d,c,u,l] = 0 then fix erc_p_assign[d,c,u,l] = 0;
			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				if reqd_A[d,c,u,l] = 0 then fix erc_A_assign[d,c,u,l] = 0;
				
		/*If the toggle for modern subs is on then fix the sub_assign to 0 where the mod_Level of a lin is less than or
		equal to the the mod levle of the sub_Lins*/
		%if %eval(&modern_subs. > 0) %then %do;
%put Fixing the substitution decision variables to zero the sublin is less modern than the lin;
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}			
				if mod_level[s]< mod_level[l] then fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				if mod_level[s]< mod_level[l] then fix erc_A_subassign[ d, c, u, l, s] = 0
			;
			%if %eval(&valid_transfer. > 0) %then %do;
			/*fixing the sub transfer rules*/
%put Fixing the Compo transfers through less modern substitutions to zero;

			for {<d,t,f,u,l,s> in ERC_P_SUBXFER_SET}			
				if mod_level[s]< mod_level[l] then fix erc_p_subxfer[ d, t, f, u, l, s] = 0
			;
			for {<d,t,f,u,l,s> in ERC_A_SUBXFER_SET}			
				if mod_level[s]< mod_level[l] then fix erc_a_subxfer[ d, t, f, u, l, s] = 0
			;
			%end;
		%end;

		/*If the toggle for no-subs is on then fix the sub_assign to 0 for all of these decision variables*/
		%if %eval(&subs_allowed. = 0) %then %do;
%put Fixing the substitution decision variables to zero because none are permitted in this run;
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}			
				fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				fix erc_A_subassign[ d, c, u, l, s] = 0
			;
			%if %eval(&valid_transfer. > 0) %then %do;
			/*fixing the sub transfer rules*/
%put Fixing the Compo transfers through substitutions to zero;

				for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET}
					fix erc_p_subxfer[d,c,f,u,l,s] = 0
				;
						
				for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET}
					fix erc_a_subxfer[d,c,f,u,l,s] = 0
				;

			%end;
		%end;

		/*Added in a feature to fix the assignment of inventory to 0 for all ML1 and ML2 LINs when
			the NGRER_RUN_TOGGLE is turned on*/
			%if %eval(&NGRER_RUN_TOGGLE = 1) %then %do;

%put Fixing the assignment of ML1 and ML2 inventory to 0;

				/*Fixing ERC P Assignments*/
					for {<d,c,u,l> in ERC_P_ASSIGN_SET} if mod_level[l] <3 then fix erc_P_assign[d, c, u, l] = 0;
				/*Fixing ERC A Assignments*/
					for {<d,c,u,l> in ERC_A_ASSIGN_SET} if mod_level[l] <3 then fix erc_A_assign[d, c, u, l] = 0;
				/*Fixing ERC P Sub Assignments*/
					for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET} if mod_level[s] <3 then fix erc_p_subassign[ d, c, u, l, s] = 0;
				/*Fixing ERC A Sub Assignments*/
					for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET} if mod_level[s] <3 then fix erc_a_subassign[ d, c, u, l, s] = 0;
				%if %eval(&valid_transfer. > 0) %then %do;
					/*Fixing ERC P Xfer Assignments*/
					for{<d,c,f,u,l> in ERC_P_XFER_SET} if mod_level[l] <3 then fix erc_p_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l> in ERC_A_XFER_SET} if mod_level[l] <3 then fix erc_a_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET} if mod_level[s] <3 then fix erc_P_subxfer[d,c,f,u,l,s] = 0;
					for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET} if mod_level[s] <3 then fix erc_A_subxfer[d,c,f,u,l,s] = 0;

					/*fixing these variables to 0 for years earlier than a user specified CASC_YEAR*/
%put Fixing the cascading to 0 in years before &CASC_YEAR;	
					for{<d,c,f,u,l> in ERC_P_XFER_SET} if d < &CASC_YEAR. then fix erc_p_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l> in ERC_A_XFER_SET} if d < &CASC_YEAR. then fix erc_a_xfer[d,c,f,u,l] = 0;
					for{<d,c,f,u,l,s> in ERC_P_SUBXFER_SET} if d < &CASC_YEAR. then fix erc_P_subxfer[d,c,f,u,l,s] = 0;
					for{<d,c,f,u,l,s> in ERC_A_SUBXFER_SET} if d < &CASC_YEAR. then fix erc_A_subxfer[d,c,f,u,l,s] = 0;


				%end;
			%end;


			/*If a the source for a sub-rule is greater than or equal to 7 thn we fix
				substitutions assignments to 0*/
%put Fixing the substitution decision variables to zero for in lieu of substutions;	
			for {<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}
				if source[l,s] >= 7 then fix erc_p_subassign[ d, c, u, l, s] = 0
			;
			for {<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}			
				if source[l,s] >= 7 then fix erc_a_subassign[ d, c, u, l, s] = 0
			;
%if %eval(&valid_transfer. > 0) %then %do;	
%put Fixing the substitution transfer decision variables to zero for in lieu of substutions;		
			for {<d,f,c,u,l,s> in ERC_P_SUBXFER_SET}			
				if source[l,s] >= 7 then fix erc_p_subxfer[d,f,c,u,l,s] = 0
			;
			
			for {<d,f,c,u,l,s> in ERC_A_SUBXFER_SET}			
				if source[l,s] >= 7 then fix erc_a_subxfer[d,f,c,u,l,s] = 0
			;
%end;
			/*If we are freezing the first year of inventory to what it is then we 
			set a constraint to make all assignments and excess to the
			inveentory in the first year*/

			%if %eval(&freeze_first_two. = 1) %then %do;
%put Constraint that Fixes the First two years is active;
			Con Freeze_Year_1{ d in modeling_dates inter {&min_year..&year_two.},c in compos, l in lins, u in units}:
					sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,u,l])
						+ sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,u,l])
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,u,s,l]))
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,u,s,l]))
					= 
					inv[c,u,l]+ cum_xfers_in[d,c,u,l] - cum_xfers_out[d,c,u,l];
			%end;

/*This if-then-do statement will define component level fencing constraints that ensure the LIN 
			level inventory balances out with the initial inventory plus procurements allocated
			to each component*/

			%if %eval(&valid_transfer. = 0) %then %do;	
%put We are using the constraints that do not enable compo transfers;		
			/*New inventory constraints to handle the tuple based index sets*/
				CON INV_MGMT_Y1A {d in dates inter {&min_year.}, c in compos, l in lins }:
						sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ excess[d,c,l]	
							= 
							inv_avail[d,c,l]
							+ add_inv[d,c,l];
	
/*New inventory constraints to handle the tuple based index sets*/
				Con INV_MGMT_YNA {d in modeling_dates diff {&min_year.}, c in compos, l in lins}:
					sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ excess[d,c,l]				
					/*total inventory within the component + procurements through the date of the constraint*/
							=
							inv_avail[d,c,l]
							+ (add_inv[d,c,l]);

				/*ERC P Shortage break out*/
				Con Shortage_Value_P {<d,c,u,l> in ERC_P_ASSIGN_SET}:
					Short_Ps[d,c,u,l] + erc_p_assign[d,c,u,l]
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target.  * reqd_P[d,c,u,l])
				;
				/*ERC A Shortage break out*/
				Con Shortage_Value_A {<d,c,u,l> in ERC_A_ASSIGN_SET}:
					Short_As[d,c,u,l] + erc_a_assign[d,c,u,l]						
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l and sublin = s }<date,compo,unit,lin,sublin>)}(erc_a_subassign[d,c,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target.  * reqd_A[d,c,u,l])
				;
			%end;

			%else %do;	

%put We are using the constraints that enable compo transfers;
		%put definining the Year 1 inventory flow constraint;
			/*New inventory constraints to handle the tuple based index sets*/
				CON INV_MGMT_Y1A {d in dates inter {&min_year.}, c in compos, l in lins }:
						sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ (excess[d,c,l])
						+ sum{<date,t,compo,u,lin> in ERC_P_XFER_SET: date = d and compo = c and lin=l}(erc_p_xfer[date,t,compo,u,lin])
						+ sum{<date,t,compo,u,lin> in ERC_A_XFER_SET: date = d and compo = c and lin=l}(erc_A_xfer[date,t,compo,u,lin])
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_P_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_p_subxfer[date,t,compo,u,s,lin]))
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_A_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_a_subxfer[date,t,compo,u,s,lin]))
							= 
							inv_avail[d,c,l] + add_inv[d,c,l]
				;
			/*New inventory constraints to handle the tuple based index sets*/
				%put definining the Year 2 through n inventory flow constraint;
				Con INV_MGMT_YNA {d in modeling_dates diff {&min_year.}, c in compos, l in lins}:
					sum{ v in units}(sum{(setof{<date,compo,unit,lin> in ERC_P_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_p_assign[d,c,v,l]))
						+ sum{ v in units}(sum{(setof{<date,compo,unit,lin> in ERC_A_ASSIGN_SET: 
							date = d and compo = c and unit = v and lin = l}<date,compo,unit,lin>)}(erc_a_assign[d,c,v,l]))
						+ sum{ v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s  and lin = l }<date,compo,unit,sublin,lin>)}(erc_p_subassign[d,c,v,s,l]))
						+ sum{v in units,s in sublins diff {l}}(sum{(setof{<date,compo,unit,sublin,lin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = v and sublin = s and lin = l }<date,compo,unit,sublin,lin>)}(erc_a_subassign[d,c,v,s,l]))
						+ (excess[d,c,l])						
						+ sum{<date,t,compo,u,lin> in ERC_P_XFER_SET: date = d and compo = c and lin=l}(erc_p_xfer[date,t,compo,u,lin])
						+ sum{<date,t,compo,u,lin> in ERC_A_XFER_SET: date = d and compo = c and lin=l}(erc_A_xfer[date,t,compo,u,lin])
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_P_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_p_subxfer[date,t,compo,u,s,lin]))
						+ sum{s in sublins diff {l}}(sum{<date,t,compo,u,sublin,lin> in ERC_A_SUBXFER_SET: date = d and compo = c and sublin = s and lin=l}
								(erc_a_subxfer[date,t,compo,u,s,lin]))
					/*total inventory within the component + procurements through the date of the constraint*/
							=
							inv_avail[d,c,l] + (add_inv[d,c,l])
				;
				/*ERC P Shortage break out*/
				Con Shortage_Value_P {<d,c,u,l> in ERC_P_ASSIGN_SET}:
					Short_Ps[d,c,u,l] + erc_p_assign[d,c,u,l]
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
						+ sum{f in compos diff {c}}
							(sum{(setof{<date, to, from, unit, lin> in ERC_P_XFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l}
							<date,to,from,unit,lin>)}(erc_p_xfer[d,c,f,u,l]))
						+ sum{f in compos diff {c}, s in sublins diff {l}}
							(sum{(setof{<date, to, from, unit, lin, sublin> in ERC_P_SUBXFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l and sublin = s}
							<date,to,from,unit,lin,sublin>)}(erc_p_subxfer[d,c,f,u,l,s]))
						/*Updated the floor function to a Ceiling Function*/
						= ceil( &fill_target. * reqd_P[d,c,u,l])
				;
				/*ERC A Shortage break out*/
				Con Shortage_Value_A {<d,c,u,l> in ERC_A_ASSIGN_SET}:
					Short_As[d,c,u,l] + erc_a_assign[d,c,u,l]						
						+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l and sublin = s }<date,compo,unit,lin,sublin>)}(erc_a_subassign[d,c,u,l,s]))
						+ sum{f in compos diff {c}}
							(sum{(setof{<date, to, from, unit, lin> in ERC_A_XFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l}
							<date,to,from,unit,lin>)}(erc_a_xfer[d,c,f,u,l]))
						+ sum{f in compos diff {c}, s in sublins diff {l}}
							(sum{(setof{<date, to, from, unit, lin, sublin> in ERC_A_SUBXFER_SET: 
							date = d and to = c and from = f and unit = u and lin = l and sublin = s}
							<date,to,from,unit,lin,sublin>)}(erc_a_subxfer[d,c,f,u,l,s]))

						= ceil( &fill_target. * reqd_A[d,c,u,l])
				;
			%end;
						
		/*Minimize the objective function value relative to the overall shortages, modern-excess, and transfers that occur*/

%put Setting up the objective function;
		min z = 
		/*Shortage penalties*/
			%put Penalizing ERC P Shortages;
				&p_pri. * sum{<d,c,u,l> in ERC_P_ASSIGN_SET}(
							(100000-darpl[d,c,u]) * Short_Ps[d,c,u,l])
			%put Penalizing ERC A Shortages;
				+ &a_pri. * sum{<d,c,u,l> in ERC_A_ASSIGN_SET}(
							(100000-darpl[d,c,u]) * Short_As[d,c,u,l])
				/*+ &b_pri. * sum{d in modeling_dates, c in compos, u in units, l in reqd_lins, e in reqd_ercs inter {"B"}}(
							(100000-darpl[d,c,u]) * shortage[d,c,u,l,e])
				+ &c_pri. * sum{d in modeling_dates, c in compos, u in units, l in reqd_lins, e in reqd_ercs inter {"C"}}(
							(100000-darpl[d,c,u]) * shortage[d,c,u,l,e])*/
			/*if we have valid transfer rules we slightly penalize transfering equipment across component to
				reduce the possibility of multiple optimal solutions and erroneous transfers*/
			%if %eval(&valid_transfer. > 0) %then %do;

				%if %eval(&trans_pen. <= 0) %then %put Rewarding Compo Transfers;
				%else %put Penalizing Compo Transfers;
				+ &trans_pen. * (
					sum{<d,to,from,u,l> in ERC_P_XFER_SET}(erc_p_xfer[d,to,from,u,l])
					+
					sum{<d,to,from,u,l> in ERC_A_XFER_SET}(erc_a_xfer[d,to,from,u,l])
					+
					sum{<d,to,from,u,l,s> in ERC_P_SUBXFER_SET}(erc_p_subxfer[d,to,from,u,l,s])
					+
					sum{<d,to,from,u,l,s> in ERC_A_SUBXFER_SET}(erc_a_subxfer[d,to,from,u,l,s])
					)
				 
			%end;
			%put Penalizing Unit transfers that move inventory away from where they were originally;
			/*We penalize spurious assignment that while the same as another we want consistent
			inventory assignments over the years and units*/
				+ &unit_yearly_xfer_pen. * 
					(sum{d in modeling_dates inter {&first_year.}}
							sum{<sd,compo,unit,lin> in ERC_P_ASSIGN_SET: sd = d}
						(
						  erc_p_assign[sd,compo,unit,lin]-
						sum {f in modeling_dates diff {&first_year.}}
							sum{<fy,sc,su,sl> in ERC_P_ASSIGN_SET: fy = f and sc = compo and su = unit and sl = lin}
									(erc_p_assign[fy, sc, su, sl])
						)
					+
					sum{d in modeling_dates inter {&first_year.}}
							sum{<sd,compo,unit,lin> in ERC_A_ASSIGN_SET: sd = d}
						(
						  erc_a_assign[sd,compo,unit,lin]-
						sum {f in modeling_dates diff {&first_year.}}
							sum{<fy,sc,su,sl> in ERC_A_ASSIGN_SET: fy = f and sc = compo and su = unit and sl = lin}
									(erc_a_assign[fy, sc, su, sl])
						)
					)
		/*Modern Excess inventory penalties*/
				+ sum{d in modeling_dates, c in compos, l in lins}(lin_excess_pen[l] * excess[d,c,l])
		/*Substitution assignment penalties*/
				+ &sub_assign_pen. * 
					(	  sum{<d,c,u,l,s> in ERC_P_SUBASSIGN_SET}(erc_p_subassign[d,c,u,l,s])
						+ sum{<d,c,u,l,s> in ERC_A_SUBASSIGN_SET}(erc_a_subassign[d,c,u,l,s])
						%if %eval(&valid_transfer. > 0) %then %do;
						+ sum{<d,to,from,u,l,s> in ERC_P_SUBXFER_SET}(erc_p_subxfer[d,to,from,u,l,s])
						+ sum{<d,to,from,u,l,s> in ERC_A_SUBXFER_SET}(erc_a_subxfer[d,to,from,u,l,s])
						%end;
					)
		/*Penalty for giving away inventory that a unit has in a future year*/
		/*Big-M penalty for having to add inventory to make the inventory constraints feasible*/
		%if %eval(&fix_flex. = 0) %then %put Penalizing the use of the slack variable;
				+ 10000000* (sum{d in modeling_dates, c in compos, l in lins}(add_inv[d,c,l]))
		;
		/*This line of code will envoke the solver and as long as we are within 5% of a linear optimum we are good*/
	%put Time to solve this thing!;
			solve with milp / relobjgap= .05;

			%put Outputting assignments;
		/*This line of code write all assignments to a data set*/
			create data P_assigned_&working_comp from [modeling_dates compos units lins]
					erc_p_assign;
			create data A_assigned_&working_comp from [modeling_dates compos units lins]
					erc_A_assign;
			%put Outputting substitutions;
		/*This line of code write all substitutions to a data set*/
			create data A_subbed_&working_comp from [modeling_dates compos units lins sublins]
					erc_a_subassign;
			create data P_subbed_&working_comp from [modeling_dates compos units lins sublins]
					erc_p_subassign;
		/*These line of code write all transfers if there are valid transfers allowed to a data set*/
		%if %eval(&valid_transfer. > 0) %then %do;
		/*create data from the transfers*/

		%put Outputting Transfers;

			create data P_XFERS_&working_comp from [modeling_dates to_compos from_compos units lins]
					erc_p_xfer;

			create data A_XFERS_&working_comp from [modeling_dates to_compos from_compos units lins]
					erc_A_xfer;

			create data P_SUBXFERS_&working_comp from [modeling_dates to_compos from_compos units lins sublins]
					erc_P_subxfer;

			create data A_SUBXFERS_&working_comp from [modeling_dates to_compos from_compos units lins sublins]
					erc_A_subxfer;


		%end;

		
		%put Outputting shortfalls;
		/*These line of code write all shortages to a data set*/
			create data P_shortage_&working_comp from [modeling_dates compos units lins]
				short_ps ;
			create data A_shortage_&working_comp from [modeling_dates compos units lins]
				short_as ;

		/*This line of code defines a numerical value to store on hand positions across the master
				index sets*/
			num P_onhand{modeling_dates, compos, units, lins} init 0;
			num A_onhand{modeling_dates, compos, units, lins} init 0;
		
				%put Creating aggregate on hand values;
		
		/*This for-loop populates the onhand values to the sum of assignments, transfers, 
			and substitutions*/
			for {<d,c,u,l> in ERC_P_ASSIGN_SET}
				P_onhand[d,c,u,l] = 
					erc_p_assign[d,c,u,l]
					+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_P_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_p_subassign[d,c,u,l,s]))
				
%if %eval(&valid_transfer. > 0) %then %do;	
%put ERC P transfers are adding into the reported on hand amounts;
					+ sum{f in compos diff {c}}(sum{(setof{<date,to_compo,from_compo,unit,lin> in ERC_P_XFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l}
							<date,to_compo,from_compo,unit,lin>)}(erc_p_xfer[d,c,f,u,l]))
					+ sum{f in compos diff {c}, s in sublins diff {l}}(sum{(setof{<date,to_compo,from_compo,unit,lin,sublin> in ERC_P_SUBXFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l and sublin = s}
							<date,to_compo,from_compo,unit,lin,sublin>)}(erc_p_subxfer[d,c,f,u,l,s]))
%end;
			;

			%put outputting on hand values with requirements and shortages;
			create data P_onhand_&working_comp from [modeling_dates compos units lins]
				reqd_P P_OnHand short_ps;

			for {<d,c,u,l> in ERC_A_ASSIGN_SET}
				A_onhand[d,c,u,l] = 
					erc_A_assign[d,c,u,l]
					+ sum{s in sublins diff {l}}(sum{(setof{<date,compo,unit,lin,sublin> in ERC_A_SUBASSIGN_SET: 
							date = d and compo = c and unit = u and lin = l  and sublin = s }<date,compo,unit,lin,sublin>)}(erc_A_subassign[d,c,u,l,s]))
%if %eval(&valid_transfer. > 0) %then %do;	
%put ERC A transfers are adding into the reported on hand amounts;
					+ sum{f in compos diff {c}}(sum{(setof{<date,to_compo,from_compo,unit,lin> in ERC_A_XFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l}
							<date,to_compo,from_compo,unit,lin>)}(erc_a_xfer[d,c,f,u,l]))
					+ sum{f in compos diff {c}, s in sublins diff {l}}(sum{(setof{<date,to_compo,from_compo,unit,lin,sublin> in ERC_A_SUBXFER_SET: 
							date = d and to_compo = c and from_compo = f and unit = u and lin= l and sublin = s}
							<date,to_compo,from_compo,unit,lin,sublin>)}(erc_a_subxfer[d,c,f,u,l,s]))
%end;
			;

			create data A_onhand_&working_comp from [modeling_dates compos units lins]
				reqd_a A_OnHand short_as;

				%if %eval(&fix_flex. = 0) %then %put Outputting the amount of slack used;
/*This line of code creates the infeasbility additions*/
			create data Infe_Adds_&working_comp from [modeling_dates compos lins]
				add_inv;
 			%put Outputting the excess inventory used;
			/*DJE Added to export excess observations*/
			create data excess_&working_comp from [modeling_dates compos lins]
					excess;
		quit;

	OPTIONS NOFULLSTIMER;

		/*This is test data to see if the ERC_P_Assignments are making the correct
			assignments*/

		/*DJE Added to accommodate for new variables index sets 11APR2017*/
		proc sql;
			insert into idm_o.assigned
			select
				modeling_dates,
				compos,
				units,
				lins,
				"P" as ercs,
				erc_p_assign as assign
			from P_assigned_&working_comp where erc_p_assign >0;
		quit;

		/*DJE Added to accommodate for new variables index sets 11APR2017*/
		proc sql;
			insert into idm_o.assigned
			select
				modeling_dates,
				compos,
				units,
				lins,
				"A" as ercs,
				erc_A_assign as assign
			from A_assigned_&working_comp where erc_A_assign >0;
		quit;
		
		/*DJE Added to accommodate for new variables index sets 11APR2017*/
			proc sql;
				insert into idm_o.subbed
				select
					modeling_dates,
					compos,
					units,
					lins,
					sublins,
					"P" as ercs,
					erc_p_subassign as subbed
				from P_subbed_&working_comp  where erc_p_subassign >0;
			quit;
			
		/*DJE Added to accommodate for new variables index sets 11APR2017*/
			proc sql;
				insert into idm_o.subbed
				select
					modeling_dates,
					compos,
					units,
					lins,
					sublins,
					"A" as ercs,
					erc_A_subassign as subbed
				from A_subbed_&working_comp  where erc_a_subassign >0;
			quit;
				
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/

			
			data Infe_Adds_append;
				set Infe_Adds_&working_comp;

				if add_inv > 0;
				component = &working_comp.;

			run;

			
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/

		proc sql;
			insert into idm_o.shortage
			select
				modeling_dates,
				compos,
				units,
				lins,
				"P" as ercs,
				Short_Ps as shortage
			from P_shortage_&working_comp  where Short_Ps > 0;
		quit;

		
		proc sql;
			insert into idm_o.shortage
			select
				modeling_dates,
				compos,
				units,
				lins,
				"A" as ercs,
				Short_As as shortage
			from A_shortage_&working_comp  where Short_As > 0;
		quit;
			
	
		/*These lines of code drop values where they are equal to 0 before 
		they are appended*/
			
		proc sql;
			insert into idm_o.inv_positions
			select
				modeling_dates,
				compos,
				units,
				lins,
				"P" as ercs,
				reqd_p as reqd,
				p_onhand as onhand,
				short_ps as shortages,
				0 as excess
			from P_onhand_&working_comp where reqd_P>0 or short_ps>0;
		quit;
		
		proc sql;
			insert into idm_o.inv_positions
			select
				modeling_dates,
				compos,
				units,
				lins,
				"A" as ercs,
				reqd_a as reqd,
				a_onhand as onhand,
				short_as as shortages,
				0 as excess
			from a_onhand_&working_comp where reqd_a>0 or short_as>0;
		quit;

		
		proc sql;
			insert into idm_o.inv_positions
			select
				modeling_dates,
				compos,
				"EXCESS" as units,
				lins,
				"X" as ercs,
				0 as reqd,
				0 as onhand,
				0 as shortages,
				excess as excess
			from excess_&working_comp where excess>0;
		quit;
			
			proc append base = idm_o.Infe_Adds data = Infe_Adds_append;
			run;


			
	%if %eval(&valid_transfer. > 0) %then %do;		
%put Appending the compo transfers to the result sets;

/*append the erc p compo transfers*/
		proc sql;
			insert into idm_o.xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				"P" as ercs,
				erc_p_xfer as compo_transfer
			from P_xfers_&working_comp where erc_p_xfer > 0 ;
		quit;
/*append the erc a compo transfers*/
		proc sql;
			insert into idm_o.xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				"A" as ercs,
				erc_a_xfer as compo_transfer
			from a_xfers_&working_comp where erc_a_xfer > 0 ;
		quit;
/*append the erc p compo substitution transfers*/
		proc sql;
			insert into idm_o.sub_xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				sublins,
				"P" as ercs,
				erc_p_subxfer as compo_sub_transfer
			from p_subxfers_&working_comp where erc_p_subxfer > 0 ;
		quit;
/*append the erc a compo substitution transfers*/
		proc sql;
			insert into idm_o.sub_xferred
			select
				modeling_dates,
				to_compos,
				from_compos,
				units,
				lins,
				sublins,
				"A" as ercs,
				erc_a_subxfer as compo_sub_transfer
			from a_subxfers_&working_comp where erc_a_subxfer > 0 ;
		quit;

	%end;

%mend;


/*this line of code envokes the macro defined above*/
%run_opt_clusters;


file name:  make_sub_ignore set.sas

%macro make_sub_ignore_set();

	%let i = 1 ;
	%let end = ;

	/*This counts the number of sub-rule sources to ignore and is the number
	that represent the terminating condition of the loop*/
	proc sql noprint;
		select
			count(source_num) into :end
		from sub_set;
	quit;

	/*This is a do-loop that will terminate when the number of rules to ignore
	is done*/
	%do %while (%eval (&i. <= &end.));
		%let add_value = ;

		/*this is a null datastep that assigns a value to the macro variable
		"add_value"*/
		data _null_;
			set sub_set(firstobs = &i. obs = &i.);

			call symputx('add_value',source_num);
		run;

	/*This will print a line to the log*/
	%put The source to ignore is &add_value;

	/*This defines the listing initially with the proper bracket*/
	%if %eval(&i. < &end.) %then %do;
		%let sub_ignore_set = &sub_ignore_set &add_value,;
	%end;
	/*This adds item to  the listing initially without a bracket*/
	%else %do;
		%let sub_ignore_set = &sub_ignore_set &add_value;
	%end;
		%let i = %eval(&i + 1);
	%end;
/*This closes the listing with the proper bracket*/
	%let sub_ignore_set = &sub_ignore_set };
%mend;

/*This dataset will number to the sub-rules to ignore data set*/
data sub_set;
	set idm_i.subs_to_ignore;
	length source_num 8;
	source_num = input(substrn(source,1,1), 8.);	
/*	if c_lin ne "" or s_lin ne "";*/
run;

%let sub_ignore_set = {;
/*This envokes the macro defined above*/
%make_sub_ignore_set();

%put &sub_ignore_set;




file name:  MAKE_INDEX_SETS_v2.sas

/*%IF &SSO_update = 1 %then */
/*  %do;*/
/*    %include "&code_path\Parity_sys_Lin_proc_chg_v2.sas";*/
/*	%include "&code_path\Parity_sys_Lin_req_chg_v2_final.sas";*/
/*%end;*/

data compo.procurements;
   set compo._fdiis_lqa_prt1;
run;



/*Code to make the LIN Listing*/
%macro make_lin_index;
proc sql;
	create table lins as
	select distinct
		lin as LINs
	from lmdb.lmdb_&lmdb_month;
quit;

/*Trent thinks subrules should be third with 1000 to 2000 LINS*/
proc sql;
	insert into lins
	select distinct
		lin as LINs
	from lmdb.subrules_final;
quit;

proc sql;
	insert into lins
	select distinct
		sublin as LINs
	from lmdb.subrules_final;
quit;

/*Trent thinks procurements should be second with 442 LINS*/
proc sql;
	insert into lins
	select distinct
		lin as LINs
	from compo.procurements;
quit;

proc sql;
	insert into lins
	select distinct
		lin as LINs
	from compo.inventory_by_uic;
quit;

/*Trent thinks requirements should be base with 2306 LINS*/
proc sql;
	insert into lins
	select distinct
		lin as LINs
	from compo.all_lin_reqs;
quit;


/*PROC IMPORT DATAFILE = "&Data_Input_Path.\SLAMIS_LIN_LIST_&slamis_dt..csv" OUT = compo.slamis_lins*/
/*	DBMS = CSV REPLACE;*/
/*	GETNAMES = YES;*/
/*     DATAROW=2; */
/*RUN;*/

/*data compo.slamis_lins;*/
/*	length */
/*		lin $ 6;*/
/*	infile "&Data_Input_Path\SLAMIS_LIN_LIST_&slamis_dt..txt"*/
/*		firstobs = 2*/
/*		missover*/
/*		DLM='09'x*/
/*		dsd;*/
/*	input*/
/*		lin $;*/
/*run;*/


/*proc sql;*/
/*	insert into lins*/
/*	select distinct*/
/*		lin as LINs*/
/*	from compo.slamis_lins;*/
/*quit;*/


/*proc sql;*/
/*	create table distinct_lins as*/
/*	select distinct*/
/*		upcase(lins) as lins*/
/*	from lins*/
/*    order by lins;*/
/*quit;*/


/*proc sql;*/
/*	create table lmdb.lins as*/
/*	select distinct*/
/*		a.lins, b.mod_level*/
/*	from distinct_lins as a left join lmdb.lmdb_&lmdb_month as b*/
/*	on a.lins = upcase(b.lin);*/
/*quit;*/

proc sql;
	create table lmdb.lins as
	select distinct
		lin as lins, mod_level
	from lmdb.lmdb_&lmdb_month;
quit;

/*data lmdb.lins;*/
/*	set lmdb.lins;*/
/*	if mod_level = . then mod_level = 2;*/
/*	if mod_level = 0 then mod_level = 3;*/
/*run;*/

%mend;

%make_lin_index;


/*Code to make the units*/

%macro make_unit_index(typco_list);

proc sql;
	create table units as
	select
		uic,
		compo
/*	from darpl.darpl_forecast_pre&current_fy where typco in &typco_list;*/
		from compo.uic_header_details  where typco in &typco_list;
quit;

proc sql;
	create table units_1 as
	select distinct
		uic,
		compo
	from compo.all_lin_reqs;
quit;

data c_num;
	set units_1;
	length c_num 8;
	c_num = compo;
run;

proc sql;
	insert into units
	select
		uic,
		compo
	from c_num;
quit;

proc sql;
	create table compo.units as
	select distinct
		uic,
		compo
	from units ;
quit;

%mend;
%make_unit_index (('1','2'));

proc sql;
	create table compo.compos as
	select distinct
		compo as compos
	from compo.all_lin_reqs;
quit;


proc sql;
	create table compo.ercs as
	select distinct
		erc as ercs
	from compo.all_lin_reqs;
quit;




file name:  Make_Clusters_Optmodel_with_LINs.sas

options symbolgen MLOGIC MLOGICNEST mprint mlogic MPRINTNEST MAUTOSOURCE SYMBOLGEN SPOOL FULLSTIMER minoperator mindelimiter=',';
OPTIONS FORMCHAR="|----|+|---+=|-/\<>*";

/*Read in the sub-rules into a data set*/
data sub_rules;
set idm_i.sub_rules;
run;

/*read the LIN data into a set called nodes and create a numeric key for the LINs*/
data nodes;
set idm_i.lins;
	nodes = _N_;
run;


proc sql;
	create table arcs_1 as
	select
		b.nodes as lins,
		a.sublins
	from sub_rules as a inner join nodes as b
	on a.lins = b.lins;
quit;



proc sql;
	create table arcs_2 as
	select
		a.lins,
		b.nodes as sublins
	from arcs_1 as a inner join nodes as b
	on a.sublins = b.lins;
quit;

proc sql;
	create table arcs as
	select distinct
		lins, sublins
	from arcs_2;
quit;

proc sql;
	insert into arcs
	select
		sublins as lins,
		lins as sublins
	from arcs_2;
quit;

proc sort data = arcs nodupkey; by lins sublins; run;

data run_time;	
	length run_start 8 run_end 8 total_time 8;

	run_start = time();
run;

option fullstimer;


proc optmodel;
	/*initialize the sets needed to make the mapping*/
	set<num> nodes ;
	set<num,num> arcs;
	set<num> marked;
	set<num> need_search;
	set<num,num> current_arcs;
	set<num> all_nodes;

	/*initialize the numerical values needed to make the mapping*/
	num comp init 1;
	num working_node init 1;
	num nodes_card init 0;
	num search_card init 0;
	num current_arc_size init 0;

	/*populate the node set, this will be used to track the nodes left to search*/
	read data nodes into nodes = [nodes];

	/*populate the all nodes set, this will be used to store the component for
	each node*/
	read data nodes into all_nodes = [nodes];
	
	/*populate the arc set, this will be used search over the LIN-SUBLIN relationships*/
	read data arcs into arcs = [lins sublins];

	/*initialize the component numbers*/
	num component{all_nodes} init 0;

	num search_set{need_search} init 0;

	/*enter the do loop that will search across all nodes until there
	are none left to search from*/

	do while (card(nodes) > 0);

		working_node = (min{i in nodes} i);
		

		*put "The first working node is" working_node;

*put "0 - The working node is " working_node "and we are assigning items to component " comp;
		/*initialize the need search set*/
		need_search = {working_node};
		search_card =  card(need_search);
		search_set[working_node] = working_node;	

*put "1 - There are " search_card " nodes to search from";

		/*enter the loop that searches from the working node
			across the arc emanating from it then nodes and arcs
			that are traversable to it*/
		
		do while (search_card >0);	

		working_node = (min{i in need_search} i);
			
*put "3 - The working node is " working_node;

			/*populate the current arc set to search from the working node*/
			current_arcs = {setof{<j,k> in arcs: j = working_node}<j,k>};
			/*get the Order of the working node by counting the number of arcs off of it*/
			current_arc_size = card(current_arcs);

*put "4 - The order of " working_node " is " current_arc_size;

			/*if the order of the node is over zero then add the head nodes
			into the search queue*/
			if current_arc_size > 0 then do;
					for{<j,k> in current_arcs} if component[k] = 0 then need_search = {need_search union {k}};
*put "5 - There are now " (card(need_search)) " nodes left to search in the set " need_search;
				/*update the component for the working node*/
					component[working_node] = comp;
				/*remove the working node to from the nodes left to search set*/
					nodes = {nodes diff {working_node}};

if (card(nodes)/card(all_nodes)>=.1995 and card(nodes)/card(all_nodes)<=.2005) 
		or
	(card(nodes)/card(all_nodes)>=.3995 and card(nodes)/card(all_nodes)<=.4005)
		or
	(card(nodes)/card(all_nodes)>=.5995 and card(nodes)/card(all_nodes)<=.6005) 
		or
	(card(nodes)/card(all_nodes)>=.7995 and card(nodes)/card(all_nodes)<=.8005) 
		or
	(card(nodes)/card(all_nodes)>=.9995) then
put "6 - There are now " (card(nodes)) " left to search from in the set of " (card(all_nodes)) " nodes";	
				/*remove the working node to from the nodes current search set*/
					need_search = {need_search diff {working_node}};
					search_card = card(need_search);

*put "7A - There are now " (card(need_search)) " nodes left to search in the set " need_search " after removing " working_node;

			end;
			/*if the order of the node is zero then add the head nodes
			into the search queue*/
			else do;
				need_search = {need_search diff {working_node}};
				

if (card(nodes)/card(all_nodes)>=.19995 and card(nodes)/card(all_nodes)<=.20005) 
		or
	(card(nodes)/card(all_nodes)>=.39995 and card(nodes)/card(all_nodes)<=.40005)
		or
	(card(nodes)/card(all_nodes)>=.59995 and card(nodes)/card(all_nodes)<=.60005) 
		or
	(card(nodes)/card(all_nodes)>=.79995 and card(nodes)/card(all_nodes)<=.80005) 
		or
	(card(nodes)/card(all_nodes)>=.99995) then
put "6 - There are now " (card(nodes)) " left to search from in the set of " (card(all_nodes)) " nodes";	
				nodes = {nodes diff {working_node}};
				search_card = card(need_search);
				*put "The component number is " comp;
				
*put "7B - There are now " (card(need_search)) " nodes left to search in the set " need_search " after removing " working_node;
				
				search_card = card(need_search);
				component[working_node] = comp;

			end;
			
			/*get the next working node which will be the first thing in the set of
			search nodes*/

		end;

*put "8 - We have left the search loop and are moving to another node";

*put " ";

		comp = comp + 1;
		
				
	end;
	
	create data components from [nodes]
		component;
quit;

option nofullstimer;

data run_time;	
	set run_time;

	run_end = time();

	total_time = run_end - run_start;

	format run_start time10.;
	format run_end time10.;

run;


proc sql;
	create table clusters as
	select
		a.*,
		b.component
	from nodes as a inner join components as b
	on a.nodes = b.nodes;
quit;

data idm_i.clusters;
	set clusters;

	drop nodes;
run;




file name:  lin_family.sas

proc summary data=OSD.taedp_erc1 nway missing;
where lin_family ne  '' and year in (&Y2,&Y3,&Y4,&Y5) and compo_cat='ARNG';
class lin_family nomen lin mod year;
var total_OH;
output out=OSD.ARNG_lin_fam (drop=_type_ _freq_)sum=;
run;

proc transpose data = OSD.ARNG_lin_fam out = OSD.ARNG_lin_fam1(rename=(COL1=OH_&Y2 COL2=OH_&Y3 COL3=OH_&Y4 COL4=OH_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by lin_family nomen lin mod;
/*	id value;*/
	var total_OH;
run;


/*** Read in Replaces Info ***************/
/*** if Lin matches and "replaces higher or replaces same then flag ***/
/**  write proc import and bring in dataset rollup flags only divide by total OH ***/
PROC IMPORT OUT= replaces
    DATAFILE= "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\NGRER\Cycle\FY24\Godzilla\OSD\Mockup_Table1B_forPPT_v2.xlsx" 
    DBMS=xlsx REPLACE;
	Sheet= "ReplacesInfo";
    GETNAMES=YES;
    DATAROW=2; 
RUN;


proc summary data=OSD.taedp_erc1 nway missing;
where lin_family ne  '' and year in (&Y5) and compo_cat='ARNG';
class lin_family year;
var total_OH;
output out=OSD.ARNG_lin_fam_only (drop=_type_ _freq_)sum=;
run;

proc transpose data = OSD.ARNG_lin_fam_only out = OSD.ARNG_lin_fam_only1(rename=(COL1=REQ_&Y5) drop=_NAME_) /* _LABEL_=FY*/ /*drop=Year*/ ;
	by lin_family;
/*	id value;*/
	var total_OH;
run;

data OSD.ARNG_cap_OH;
  merge OSD.ARNG_lin_fam1 (in=a)
        OSD.ARNG_lin_fam_only1 (in=b);
		by lin_family;
run;
      



file name:  generate_reports_subs.sas

/*This was the start of Module 1 of the original ASRA code*/
/* This is the second of four modules needed to process the authoritative data for the ASRA */
/* This module takes the substitute and primary inventories and formats each by Year, COMPO, LIN, ERC, MOD_LEVEL. */

/*libname Results "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\ASRA\Bucket_Pour\Q2FY21\Model Output Results\16MAR2021_ASRA_Analysis_SUBS";*/
/*libname compo "O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\ASRA\Bucket_Pour\Q2FY21\SAS Data\26MAR2021_StudyData";*/


/*Summate the subbed inventory to the Year, COMPO, LIN, ERC, MOD_LEVEL level*/
data darpl.all_darpl_forecast2;
	set darpl.all_darpl_forecast;
   if SUBLIN_ML = . THEN SUBLIN_ML = 1;
   if SUBLIN_ML = 0 THEN SUBLIN_ML = 5;
run;


proc sql;
	create table sum_sub_to_lin_ml as
	select distinct
		FY as year,
		compo as compo,
		lin as lin,
		erc as erc,
		SUBLIN_ML as mod_level,
		sum(SUB_HELP) as subbed_in
	from darpl.all_darpl_forecast2
	group by year, compo, lin, erc, mod_level;
quit;

proc sort data=sum_sub_to_lin_ml;
	by year compo lin erc mod_level;
run;


proc transpose data = sum_sub_to_lin_ml out = subbed_xtab_ml;
	by year compo lin erc;
	id mod_level;
	var subbed_in;
run;

/*Merge the inventory position data with mod-levels*/

proc sql;
	create table add_ml_to_inv as
	select
		a.*,
		b.mod_level
	from darpl.all_darpl_forecast2 as a left join lmdb.lins as b
	on a.lin = b.lins where a.FY in &date_list;
quit;

/*Summate the subbed inventory to the Year, COMPO, LIN, ERC, MOD_LEVEL level*/

proc sql;
	create table sum_inv_to_lin_ml as
	select distinct
		FY as year,
		compo as compo,
		lin as lin,
		erc as erc,
		max(mod_level) as mod_level,
		sum(req) as req,
		sum(E_OH) as on_hand,
		sum(short2) as shortage
/*		sum(excess) as excess*/
	from add_ml_to_inv
	group by FY, compo, lin, erc;
quit;

/*Transpose the OH data onto the Mod-Level values*/

proc transpose data = sum_inv_to_lin_ml out = onhand_xtab_ml;
	by year compo lin erc;
	id mod_level;
	var on_hand;
run;

/*Join in the onhand data by ML to the primary OH data*/

proc sql;
	create table join_r_n_s_to_Oh as
	select
		a.*,
		b._1 as ML1_OH,
		b._2 as ML2_OH,
		b._3 as ML3_OH,
		b._4 as ML4_OH,
		b._5 as ML5_OH
	from sum_inv_to_lin_ml as a left join onhand_xtab_ml as b
	on a.year = b.year and a.compo = b.compo and a.lin = b.lin and a.erc = b.erc;
quit;

/*Join in the subbed data by ML to the primary OH data*/
proc sql;
	create table join_OH_to_Subbed as
	select
		a.*,
/*		0 as ML1_Subbed,*/
/*		0 as ML2_Subbed,*/
		b._1 as ML1_Subbed,
		b._2 as ML2_Subbed,
		b._3 as ML3_Subbed,	
		b._4 as ML4_Subbed,
		b._5 as ML5_Subbed
	from join_r_n_s_to_Oh as a left join subbed_xtab_ml as b
	on a.year = b.year and a.compo = b.compo and a.lin = b.lin and a.erc = b.erc;
quit;


data make_oh_assigned_data;
	set join_OH_to_Subbed;

	array subbed{*} ML1_Subbed ML2_Subbed ML3_Subbed ML4_Subbed ML5_Subbed;
	array OH{*} ML1_OH ML2_OH ML3_OH ML4_OH ML5_OH;

	i = 1;
	total_subbed = 0;
	total_OH = 0;
	do i = 1 to 5;
		/*re-writing the nulls to 0*/
		if subbed[i]= . then subbed[i] = 0;
		/*updating the total subbed on hand values*/
		total_subbed = total_subbed + subbed[i];
		/*re-writing the nulls to 0*/
		if oh[i]= . then oh[i] = 0;
		/*update the total oh value*/
		total_oh = total_oh + oh[i];
		/*zeroing out the oh[i] elements for reassignment later*/
		oh[i] = 0;
	end;

	/*assignment of the real on hand,or on hand no subs, value*/
	roh = total_oh - total_subbed;

	/*Now we can properly align the ml#_onhand values*/
	do i = 1 to 5;
		/*if the mod level is the same as the i-counter then the the 
		on hand no subs is that mod level plus whatever is subbed in of
		the same mod_level*/
		if mod_level = i then do;
			oh[i] = roh + subbed[i];
		end;
		/*if the mod-level of a lin does not equal the i counter
		then the oh[i] is equal to whatever is subbing in of 
		that mod-level*/
		else do;
			oh[i] = oh[i] + subbed[i];
		end;

	end;

	/*overwrite null reqd/ on_hand/ shortage and excess data*/

	if req = . then req = 0;
	if on_hand = . then on_hand = 0;
	if shortage = . then shortage = 0;
	if excess = . then excess = 0;

run;


data compo.ASRA_FORMAT_DATA&version;
	set make_oh_assigned_data;
run;


proc sql;
	create table sum_req_asra as
	select distinct
		year,
		compo,
		sum(req) as req
	from compo.asra_format_data&version
	group by year,compo;
quit;


/*This is the start of Module 3 of the original ASRA code*/
/*Assignment of global macro variables that are used to reference input data*/
/*Where the TAEDP data is pulled from*/

/*the name of the exempt LIN file*/
%let exempt_lin_file = exempt_lins_15NOV2016;


/*
proc export data = asra.inv_positions&version outfile = "&path\inv_positions.csv"
	dbms = csv replace;
run;*/

/*Read in exempt LINs to tag as we assess ERC P Shortages*/
data exempt_lins;
	length
		lin $ 6
		TA $ 1
		AC $ 1
		ARNG $ 1
		USAR $ 1
		APS $ 1;
	infile "&Data_Input_Path\&exempt_lin_file..csv"
		firstobs = 2
		missover
		dlm=','
		dsd;
	input
		lin $
		TA $
		AC $ 
		ARNG $ 
		USAR $
		APS	$ ;
	transvar = 1;
run;

proc sort data = exempt_lins; by lin; run;

proc transpose data = exempt_lins out = lin_list;
by lin;
id transvar;
var ac arng usar;
run;

data results.f_lin_list;
	set lin_list;
	if upcase(_1) = "X";

	if _name_ = "AC" then compo = '11';
	else if _name_ = "ARNG" then compo = '21';
	else if _name_ = "TA" then compo = "T";
	else if _name_ = "APS" then compo = '61';
	else compo = "31";
	drop _name_ ;
run;


/*Sum up the FDIIS LQA data to the component-lin level for years 2017-2021*/
proc sql;
	create table fdiis_lqa_sum as
	select distinct
		compo||'1' as compo,
		lin_out AS lin,
		fy,
		sum(qty) as qty
	from compo.fdiis_lqa where fy in &date_range
	group by compo,lin_out,fy;
quit;

/*Transpose the data so that the years expand out into columns*/
proc transpose data = fdiis_lqa_sum out = compo.fdiis_lqa_xtab_year;
	by compo lin;
	id fy;
	var qty;
run;

/*Read down the TAEDP output file for ERC P Analysis*/
data results.taedp_set;
	set compo.ASRA_FORMAT_DATA&version;
run;

proc sql;
	create table results.join_lin_data as
	select
		a.*, b.nomenclature, b.major_capability, b.lin_family
	from results.taedp_set as a left join lmdb.lmdb_&lmdb_month as b
	on a.lin = b.lin;
quit;


/*Add columns to the TAEDP set to enable calculations and easier analysis of the 
final data
The LIN level EOH percentage is calculated here since we are mainly concerned
with the ERC P LIN EOH and not the aggregate component level EOH*/
data results.TAEDP_ERC1;
	length COMPO_CAT $4;
	set results.join_lin_data;

	FY = year;
	if substrn(COMPO,1,1) = '1' then COMPO_CAT = "AC";
	else if substrn(COMPO,1,1) = '2' then COMPO_CAT = "ARNG";
	else if substrn(COMPO,1,1) = '3' then COMPO_CAT = "USAR";
	else if COMPO = 'T' then COMPO_CAT = "TPE";
	else if COMPO = 'S' then COMPO_CAT = "DEP";
	else if substrn(COMPO,1,1) = '6' then COMPO_CAT = "APS";


	if TYPCO in ('1' '2') then TYPCO_CAT = "MTOE";
/*	if substrn(COMPO,2,1) in ('1' '2') then TYPCO_CAT = "MTOE";*/
	else TYPCO_CAT = "TDA";

	OH_CAPPED = min(REQ, On_hand);
	if REQ = 0 then EOH = 1;
	else EOH = OH_CAPPED/REQ;
	length RATING $5;
	/*Assignment of LINs that have an equipment rating of 1*/
	if EOH >= .895 then RATING = "1";
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH >= .795 then RATING = "2";
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else RATING = "Below";
run;

/*Filtering the full Component level TAEDP set down to only the ERC P entries*/
data results.PROJ_YEARS;
	set results.TAEDP_ERC1 ;
	
	if FY in &date_range;
	if ERC = "P";
run;


/*Intermediate table to summarize the LIN counts by the 
rating they were given in the previous data steps*/
proc sql;
	create table results.f_COMPO_LIN_COUNT as
	select distinct
		FY,
		COMPO,
		RATING,
		count(LIN) as LIN_COUNT
	from results.PROJ_YEARS
	group by FY,COMPO,RATING
	order by FY,COMPO;
quit;

proc sql;
	create table results.f_RATING_BY_LIN_COMPO as
	select distinct
		FY,
		LIN,
		NOMENCLATURE,
		COMPO,
		RATING
	from results.PROJ_YEARS
/*	group by FY,COMPO,RATING*/
	order by LIN,COMPO,FY;
quit;
/*Cross tabbing the rating values by FY and COMPO to 
calculate the percentages*/
proc transpose data=results.f_COMPO_LIN_COUNT
	out = results.f_COMPO_LIN_COUNT_TRANS;
	by FY COMPO;
	id RATING;
	var LIN_COUNT;
run;

proc transpose data=results.f_RATING_BY_LIN_COMPO
	out = results.f_RATING_BY_LIN_COMPO_xtab;
	by LIN NOMENCLATURE COMPO;
	id FY;
	var RATING;
run;

/*Final table showing the Total LINs and the various 
percentages for the Component ERC P ASRA Chart*/
data results.f_COMPO_LIN_COUNT_P;
	set results.f_COMPO_LIN_COUNT_TRANS;
	length P_ABOVE_90 8 P_ABOVE_80 8 P_GREEN 8 P_BELOW_80 8;
	
	if _1 = . then _1 = 0;
	if _2 = . then _2 = 0;
	if Below = . then Below = 0;
	
	total_lins = _1 + _2 + Below;
	drop _name_;

	P_ABOVE_90 = _1/(_1+_2+Below);
	P_ABOVE_80 = _2/(_1+_2+Below);
	P_GREEN = (_1+_2)/(_1+_2+Below);
	P_BELOW_80 = BELOW/(_1+_2+Below);
run;

/*Here we summarize the on hand by LIN at the Total Army Level
by erc to calculate the Total Army Level metrics*/
proc sql;
	create table results.sum_TA_ERC_P as
	select distinct
		FY,
		LIN,
		Nomenclature,
		Major_capability,
		ERC,
		sum(req) as req,
		sum(on_hand) as oh
	from results.TAEDP_ERC1
	group by FY,LIN,ERC;
quit;

/*Now we go through and calculate the ratings for
each of the LINs in the table*/
data results.TAEDP_TA_ERC1;
	set results.sum_TA_ERC_P;

	OH_CAPPED = min(REQ, OH);
	if REQ = 0 then EOH = 1;
	else EOH = OH_CAPPED/REQ;
	length RATING $5;

	/*Assignment of LINs that have an equipment rating of 1*/
	if EOH >= .895 then RATING = "1";
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH >= .795 then RATING = "2";
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else RATING = "Below";
run;
/*Filter the exempt LIN list down to only the total army LINs that are exempt*/
data total_army_exempt_lins;
	set exempt_lins;

	if TA ne "";
run;

/*Filtering the full Total Army TAEDP set down to only the ERC P entries*/
data results.PROJ_YEARS_TA;
	set results.TAEDP_TA_ERC1 ;
	
	if FY in &date_range;
	if ERC = "P";
run;

/*join in the exempt data column to the lin level detail so that we can quickly sum up the
erc P calculation based on non-exempt lins*/

proc sql;
	create table results.proj_years_with_exempt as
	select
		a.*,b.ta as exempt
	from results.proj_years_ta as a left join total_army_exempt_lins as b on  a.lin = b.lin;
quit;

/*Intermediate table to summarize the LIN counts by the 
rating they were given in the previous data steps*/
proc sql;
	create table results.f_LIN_COUNT_TA as
	select distinct
		FY,
		RATING,
		count(LIN) as LIN_COUNT
	from results.PROJ_YEARS_TA
	group by FY,RATING
	order by FY,RATING;
quit;

/*Intermediate table to summarize the LIN counts by the 
rating they were given in the previous data steps*/
proc sql;
	create table results.f_LIN_COUNT_TA_E as
	select distinct
		FY,
		RATING,
		count(LIN) as LIN_COUNT
	from results.proj_years_with_exempt where exempt = ""
	group by FY,RATING
	order by FY,RATING;
quit;

/*Cross tabbing the rating values by FY and COMPO to 
calculate the percentages*/
proc transpose data=results.f_LIN_COUNT_TA
	out = results.f_LIN_COUNT_TRANS_TA;
	by FY ;
	id RATING;
	var LIN_COUNT;
run;
proc transpose data=results.f_LIN_COUNT_TA_E
	out = results.f_LIN_COUNT_TRANS_TA_E;
	by FY ;
	id RATING;
	var LIN_COUNT;
run;


/*Final table showing the Total LINs and the various 
percentages for the Total Army ASRA Chart*/
data results.f_LIN_COUNT_P_TA;
	set results.f_LIN_COUNT_TRANS_TA;
	length P_ABOVE_90 8 P_ABOVE_80 8 P_GREEN 8 P_BELOW_80 8;
	
	if _1 = . then _1 = 0;
	if _2 = . then _2 = 0;
	if Below = . then Below = 0;
	
	total_lins = _1 + _2 + Below;
	drop _name_;

	P_ABOVE_90 = _1/(_1+_2+Below);
	P_ABOVE_80 = _2/(_1+_2+Below);
	P_GREEN = (_1+_2)/(_1+_2+Below);
	P_BELOW_80 = BELOW/(_1+_2+Below);
run;
data results.f_LIN_COUNT_P_TA_E;
	set results.f_LIN_COUNT_TRANS_TA_E;
	length P_ABOVE_90 8 P_ABOVE_80 8 P_GREEN 8 P_BELOW_80 8;
	
	if _1 = . then _1 = 0;
	if _2 = . then _2 = 0;
	if Below = . then Below = 0;
	
	total_lins = _1 + _2 + Below;
	drop _name_;

	P_ABOVE_90 = _1/(_1+_2+Below);
	P_ABOVE_80 = _2/(_1+_2+Below);
	P_GREEN = (_1+_2)/(_1+_2+Below);
	P_BELOW_80 = BELOW/(_1+_2+Below);
run;

/*Sort step to prepare for a transpose*/
proc sort data = results.proj_years; by compo lin fy;run;

/*Transpose step that enables multiyear rating comparison*/
proc transpose data = results.proj_years out = results.proj_years_xtab_year;
by compo lin;
id fy;
var rating;
run;
/*Here we are marking the LINs that cross the 80% threshold 
in the reporting period and the LINs that stay red across the reporting
period*/
data results.filter_changes;
	set results.proj_years_xtab_year;

	array years{*} _&Y1 _&Y2 _&Y3 _&Y4 _&Y5 _&Y6 _&Y7;

	array early_years{*} _&Y1 _&Y2 _&Y3;
		
		length rating_points 8 num_null 8 num_S1S2 8 num_below 8 
		FY&Y3._rating_points 8 FY&Y3._num_null 8 FY&Y3._num_S1S2 8 FY&Y3._num_below 8;

		if (years[1] in ('1','2') and years[2] = 'Below') or (years[2] in ('1','2') and years[1] = 'Below') then 
			change = 1;
		else if years[2] in ('1','2') and years[3] = 'Below' or (years[3] in ('1','2') and years[2] = 'Below')then 
			change = 1;
		else if years[3] in ('1','2') and years[4] = 'Below' or (years[4] in ('1','2') and years[3] = 'Below')then 
			change = 1;
		else if years[4] in ('1','2') and years[5] = 'Below' or (years[5] in ('1','2') and years[4] = 'Below')then 
			change = 1;
		else if years[5] in ('1','2') and years[6] = 'Below' or (years[6] in ('1','2') and years[5] = 'Below')then 
			change = 1;
		else if years[6] in ('1','2') and years[7] = 'Below' or (years[7] in ('1','2') and years[6] = 'Below')then 
			change = 1;
		else change = 0;

		i = 1;
		num_null = 0;
		num_s1s2 = 0;
		num_below = 0;
		rating_points = 0;

		do while (i <=7);
			
			if years[i] in ('1','2') then do;
				num_null = num_null + 0;
				num_s1s2 = num_s1s2 + 1;
				num_below = num_below +0;
				rating_points = rating_points  + 100;
			end;
			else if years[i] ='Below' then do;
				num_null = num_null + 0;
				num_s1s2 = num_s1s2 + 0;
				num_below = num_below +1;
				rating_points = rating_points  + 10;
			end;
			else do;
				num_null = num_null + 1;
				num_s1s2 = num_s1s2 + 0;
				num_below = num_below +0;
				rating_points = rating_points  + 1;
			end;

			i = i + 1;
		end;

		i = 1;
		FY&Y3._rating_points = 0;
		FY&Y3._num_null = 0;
		FY&Y3._num_S1S2 = 0;
		FY&Y3._num_below = 0;
		do while (i <=3);
			
			if early_years[i] in ('1','2') then do;
				FY&Y3._num_null = FY&Y3._num_null + 0;
				FY&Y3._num_s1s2 = FY&Y3._num_s1s2 + 1;
				FY&Y3._num_below = FY&Y3._num_below +0;
				FY&Y3._rating_points = FY&Y3._rating_points  + 100;
			end;
			else if early_years[i] ='Below' then do;
				FY&Y3._num_null = FY&Y3._num_null + 0;
				FY&Y3._num_s1s2 = FY&Y3._num_s1s2 + 0;
				FY&Y3._num_below = FY&Y3._num_below +1;
				FY&Y3._rating_points = FY&Y3._rating_points  + 10;
			end;
			else do;
				FY&Y3._num_null = FY&Y3._num_null + 1;
				FY&Y3._num_s1s2 = FY&Y3._num_s1s2 + 0;
				FY&Y3._num_below = FY&Y3._num_below +0;
				FY&Y3._rating_points = FY&Y3._rating_points  + 1;
			end;

			i = i + 1;
		end;

	/*Code added to identify where LINs are not present in all years of the reporting period*/
	if num_null > 0 then reduction = 1;
	else reduction = 0;

	i = 0;
	do while (i <= 6);
		if num_null = i and (7-num_null)*10 + num_null * 1 = rating_points  then stays_red = 1;
		if num_null = i and (7-num_null)*100 + num_null * 1 = rating_points  then stays_green = 1;
		i = i + 1;
	end;

	
	i = 0;
	do while (i <= 2);
		if FY&Y3._num_null = i and (3-FY&Y3._num_null)*10 + FY&Y3._num_null * 1 = FY&Y3._rating_points  then FY&Y3._stays_red = 1;
		if FY&Y3._num_null = i and (3-FY&Y3._num_null)*100 + FY&Y3._num_null * 1 = FY&Y3._rating_points  then FY&Y3._stays_green = 1;
		i = i + 1;
	end;
run;

%macro make_lin_stats();
%let i = &Y1;

	%do %while (%eval(&i <= &Y7.));
		

		/*Now we are collecting the ith year in the loop. stats to merge back to the changes table*/
		proc sql;
			create table results.lin_stats_&i as
			select distinct
				compo,
				lin,
				sum(on_hand) as oh,
				sum(req) as req,
				sum(eoh) as eoh
			from results.proj_years where fy = &i.
			group by 1,2;
		quit;

		data results.lin_stats_&i;
		  set results.lin_stats_&i;
		  IF req GT 0 then eoh = oh/req;
		  ELSE eoh = .;
        run; 
	%let i = %eval(&i +1);
	%end;
%mend;
%make_lin_stats();

%macro join_stats();

	%let i = &Y1;

		%do %while (%eval(&i <= &Y7.));
			
		%if %eval(&i = &Y1.) %then %do;
			proc sql;
				create table results.final_changes as	
				select	
				a.*,
				 b.oh as oh_&i, b.req as req_&i,b.eoh as eoh_&i
				from results.filter_changes as a left join results.lin_stats_&i as b
				on a.compo = b.compo and a.lin = b.lin;
			quit;
		%end;
		%else %do;
			proc sql;
				create table results.final_changes as	
				select	
				a.*,
				 b.oh as oh_&i, b.req as req_&i,b.eoh as eoh_&i
				from results.final_changes as a left join results.lin_stats_&i as b
				on a.compo = b.compo and a.lin = b.lin;
			quit;
		%end;
		
	%let i = %eval(&i + 1);
	%end;
%mend;

%join_stats();


/*To mark the LINs that are being procured in early years we merge in the FDIIS LQA totals
pulled earlier in the code*/
proc sql;
	create table results.final_changes_with_lqa as
	select	
	a.*,
	b._&Y2 as proc_&Y2, b._&Y3 as proc_&Y3, b._&Y4 as proc_&Y4, b._&Y5 as proc_&Y5, b._&Y6 as proc_&Y6
	from results.final_changes as a left join compo.Fdiis_lqa_xtab_year as b
	on a.compo = b.compo and a.lin = b.lin;
quit;

/*Now we're overwriting zeros and marking the LINs that are procured in FY17-21 with a '* '*/
data results.p_erc_P_lin_table;
	set results.final_changes_with_lqa;

	if proc_&Y2 = . then proc_&Y2 = 0;
	if proc_&Y3 = . then proc_&Y3 = 0;
	if proc_&Y4 = . then proc_&Y4 = 0;
	if proc_&Y5 = . then proc_&Y5 = 0;
	if proc_&Y6 = . then proc_&Y6 = 0;
	/*if proc_2023 = . then proc_2023 = 0;*/

	if proc_&Y2 + proc_&Y3 + proc_&Y4 + proc_&Y5 + proc_&Y6 > 0 then lin_label = lin||"*";
	else lin_label = lin;

run;

/*Now we are merging the LIN name, major capability and aba code to 
identify which LINs are AWCF funded*/
proc sql;
	create table results.join_erc_p_to_lmdb as
	select 
		a.*, b.nomenclature, b.major_capability, b.aba
	from results.p_erc_P_lin_table as a left join lmdb.lmdb_&lmdb_month as b 
	on a.lin = b.lin;
quit;

/*Now we mark the final table with whether or not the LINs are AWCF funded and 
this is the final component-lin level data table*/
data results.f_COMPO_ERC_P_TABLE;
retain compo lin_label nomenclature major_capability 
	oh_&Y1 req_&Y1 eoh_&Y1 
	oh_&Y2 req_&Y2 eoh_&Y2 
	oh_&Y3 req_&Y3 eoh_&Y3
	oh_&Y4 req_&Y4 eoh_&Y4
	oh_&Y5 req_&Y5 eoh_&Y5
	oh_&Y6 req_&Y6 eoh_&Y6
	oh_&Y7 req_&Y7 eoh_&Y7
	change stays_red fy&Y3._stays_red reduction 
	lin _&Y1 _&Y2 _&Y3 _&Y4 _&Y5 _&Y6 _&Y7 ;

	set results.join_erc_p_to_lmdb;

	if aba = '2' then AWCF_FUNDED = "Yes";

	drop _name_;
run;

proc sql;
	create table results.f_COMPO_ERC_P_TABLE as
	select a.*,
	b._1 as exempt
	from results.f_COMPO_ERC_P_TABLE as a left join results.f_lin_list as b 
	on a.lin = b.lin and a.compo = b.compo;
quit;


/*DJE added to make the processing of the data in excel easier 12FEB2016*/
proc sort data = results.f_COMPO_ERC_P_TABLE; by compo lin; run;


/*Here we are doing the same steps for the TOTAL Army LIN set except for bringing in the FDIIS LQA*/

/*Sort step to prepare for a transpose*/
proc sort data = results.proj_years_ta; by lin FY; run;

/*Transpose step that enables multiyear rating comparison*/
proc transpose data = results.proj_years_TA out = results.proj_years_TA_xtab_year;
by lin;
id fy;
var rating;
run;

/*Here we are marking the LINs that cross the 80% threshold 
in the reporting period and the LINs that stay red across the reporting
period*/
data results.filter_changes_TA;
	set results.proj_years_TA_xtab_year;

	array years{*} _&Y1 _&Y2 _&Y3 _&Y4 _&Y5 _&Y6 _&Y7 ;

	array early_years{*} _&Y1 _&Y2 _&Y3;
		
		length rating_points 8 num_null 8 num_S1S2 8 num_below 8 
		FY&Y3._rating_points 8 FY&Y3._num_null 8 FY&Y3._num_S1S2 8 FY&Y3._num_below 8;

		if (years[1] in ('1','2') and years[2] = 'Below') or (years[2] in ('1','2') and years[1] = 'Below') then 
			change = 1;
		else if years[2] in ('1','2') and years[3] = 'Below' or (years[3] in ('1','2') and years[2] = 'Below')then 
			change = 1;
		else if years[3] in ('1','2') and years[4] = 'Below' or (years[4] in ('1','2') and years[3] = 'Below')then 
			change = 1;
		else if years[4] in ('1','2') and years[5] = 'Below' or (years[5] in ('1','2') and years[4] = 'Below')then 
			change = 1;
		else if years[5] in ('1','2') and years[6] = 'Below' or (years[6] in ('1','2') and years[5] = 'Below')then 
			change = 1;
		else if years[6] in ('1','2') and years[7] = 'Below' or (years[7] in ('1','2') and years[6] = 'Below')then 
			change = 1;
		else change = 0;

		i = 1;
		num_null = 0;
		num_s1s2 = 0;
		num_below = 0;
		rating_points = 0;

		do while (i <=7);
			
			if years[i] in ('1','2') then do;
				num_null = num_null + 0;
				num_s1s2 = num_s1s2 + 1;
				num_below = num_below +0;
				rating_points = rating_points  + 100;
			end;
			else if years[i] ='Below' then do;
				num_null = num_null + 0;
				num_s1s2 = num_s1s2 + 0;
				num_below = num_below +1;
				rating_points = rating_points  + 10;
			end;
			else do;
				num_null = num_null + 1;
				num_s1s2 = num_s1s2 + 0;
				num_below = num_below +0;
				rating_points = rating_points  + 1;
			end;

			i = i + 1;
		end;

		i = 1;
		FY&Y3._rating_points = 0;
		FY&Y3._num_null = 0;
		FY&Y3._num_S1S2 = 0;
		FY&Y3._num_below = 0;
		do while (i <=3);
			
			if early_years[i] in ('1','2') then do;
				FY&Y3._num_null = FY&Y3._num_null + 0;
				FY&Y3._num_s1s2 = FY&Y3._num_s1s2 + 1;
				FY&Y3._num_below = FY&Y3._num_below +0;
				FY&Y3._rating_points = FY&Y3._rating_points  + 100;
			end;
			else if early_years[i] ='Below' then do;
				FY&Y3._num_null = FY&Y3._num_null + 0;
				FY&Y3._num_s1s2 = FY&Y3._num_s1s2 + 0;
				FY&Y3._num_below = FY&Y3._num_below +1;
				FY&Y3._rating_points = FY&Y3._rating_points  + 10;
			end;
			else do;
				FY&Y3._num_null = FY&Y3._num_null + 1;
				FY&Y3._num_s1s2 = FY&Y3._num_s1s2 + 0;
				FY&Y3._num_below = FY&Y3._num_below +0;
				FY&Y3._rating_points = FY&Y3._rating_points  + 1;
			end;

			i = i + 1;
		end;

	/*Code added to identify where LINs are not present in all years of the reporting period*/
	if num_null > 0 then reduction = 1;
	else reduction = 0;

	i = 0;
	do while (i <= 6);
		if num_null = i and (7-num_null)*10 + num_null * 1 = rating_points  then stays_red = 1;
		if num_null = i and (7-num_null)*100 + num_null * 1 = rating_points  then stays_green = 1;
		i = i + 1;
	end;

	
	i = 0;
	do while (i <= 2);
		if FY&Y3._num_null = i and (7-FY&Y3._num_null)*10 + FY&Y3._num_null * 1 = FY&Y3._rating_points  then FY&Y3._stays_red = 1;
		if FY&Y3._num_null = i and (7-FY&Y3._num_null)*100 + FY&Y3._num_null * 1 = FY&Y3._rating_points  then FY&Y3._stays_green = 1;
		i = i + 1;
	end;
run;


%macro TA_make_lin_stats();
%let i = &Y1;

	%do %while (%eval(&i <= &Y7.));
		

		/*Now we are collecting the ith year in the loop. stats to merge back to the changes table*/
		proc sql;
			create table results.lin_stats_TA_&i as
			select distinct
		
				lin,
				sum(oh) as oh,
				sum(req) as req,
				sum(eoh) as eoh
			from results.proj_years_TA where fy = &i.
			group by LIN;
		quit;
	%let i = %eval(&i +1);
	%end;
%mend;
%TA_make_lin_stats();

%macro TA_join_stats();

%let i = &Y1;

	%do %while (%eval(&i <= &Y7.));
			
		%if %eval(&i = &Y1.) %then %do;
			proc sql;
				create table results.final_changes_TA as	
				select	
				a.*,
				 b.oh as oh_&i, b.req as req_&i,b.eoh as eoh_&i
				from results.filter_changes_TA as a left join results.lin_stats_TA_&i as b
				on  a.lin = b.lin;
			quit;
		%end;
		%else %do;
			proc sql;
				create table results.final_changes_TA as	
				select	
				a.*,
				 b.oh as oh_&i, b.req as req_&i,b.eoh as eoh_&i
				from results.final_changes_TA as a left join results.lin_stats_TA_&i as b
				on  a.lin = b.lin;
			quit;
		%end;
		
	%let i = %eval(&i + 1);
	%end;
%mend;

%TA_join_stats();

/*Update the code to create the LIN Health ratings*/
data results.create_s_rates;
	set results.final_changes_TA;
	
	length 
	lh_rating_&Y1 8
	lh_rating_&Y2 8
	lh_rating_&Y3 8
	lh_rating_&Y4 8
	lh_rating_&Y5 8
	lh_rating_&Y6 8
	lh_rating_&Y7 8;


	if EOH_&Y1 >= .895 then lh_rating_&Y1 = 1;
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH_&Y1 >= .795 then lh_rating_&Y1 = 2;
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else if .795 > EOH_&Y1 >=.65 then lh_rating_&Y1 = 3;
	else if EOH_&Y1 = . then lh_rating_&Y1 = 0;
	else lh_rating_&Y1 = 4;

	if EOH_&Y2 >= .895 then lh_rating_&Y2 = 1;
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH_&Y2 >= .795 then lh_rating_&Y2 = 2;
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else if .795 > EOH_&Y2 >=.65 then lh_rating_&Y2 = 3;
	else if EOH_&Y2 = . then lh_rating_&Y2 = 0;
	else lh_rating_&Y2 = 4;

	if EOH_&Y3 >= .895 then lh_rating_&Y3 = 1;
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH_&Y3 >= .795 then lh_rating_&Y3 = 2;
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else if .795 > EOH_&Y3 >=.65 then lh_rating_&Y3 = 3;
	else if EOH_&Y3 = . then lh_rating_&Y3 = 0;
	else lh_rating_&Y3 = 4;

if EOH_&Y4 >= .895 then lh_rating_&Y4 = 1;
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH_&Y4 >= .795 then lh_rating_&Y4 = 2;
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else if .795 > EOH_&Y4 >=.65 then lh_rating_&Y4 = 3;
	else if EOH_&Y4 = . then lh_rating_&Y4 = 0;
	else lh_rating_&Y4 = 4;

if EOH_&Y5 >= .895 then lh_rating_&Y5 = 1;
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH_&Y5 >= .795 then lh_rating_&Y5 = 2;
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else if .795 > EOH_&Y5 >=.65 then lh_rating_&Y5 = 3;
	else if EOH_&Y5 = . then lh_rating_&Y5 = 0;
	else lh_rating_&Y5 = 4;

if EOH_&Y6 >= .895 then lh_rating_&Y6 = 1;
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH_&Y6 >= .795 then lh_rating_&Y6 = 2;
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else if .795 > EOH_&Y6 >=.65 then lh_rating_&Y6 = 3;
	else if EOH_&Y6 = . then lh_rating_&Y6 = 0;
	else lh_rating_&Y6 = 4;

if EOH_&Y7 >= .895 then lh_rating_&Y7 = 1;
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH_&Y7 >= .795 then lh_rating_&Y7 = 2;
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else if .795 > EOH_&Y7 >=.65 then lh_rating_&Y7 = 3;
	else if EOH_&Y7 = . then lh_rating_&Y7 = 0;
	else lh_rating_&Y7 = 4;

	/*Code added to flag LINs where the rating is a 4 in at least 1 year*/
	if lh_rating_&Y1 = 4 or lh_rating_&Y2 = 4 or lh_rating_&Y3 = 4
		or lh_rating_&Y4 = 4 or lh_rating_&Y5 = 4 or lh_rating_&Y6 = 4 or lh_rating_&Y7 = 4 then s4_lin = 1;
	else s4_lin = 0;

run;

/*data check for synchronization of the LH ratings and the Ratings for the S1/S2 chart
if any records are in the bad_records set investigate why there are discrepancies between the
calculations*/
data results.bad_records results.good_records;
	set results.create_s_rates;

	if (_&Y1 = '1' and lh_rating_&Y1 ne 1) or (_&Y1 = '2' and lh_rating_&Y1 ne 2) or (_&Y1 = 'Below' and lh_rating_&Y1 notin (3, 4) )then output results.bad_records;
	else if (_&Y2 = '1' and lh_rating_&Y2 ne 1) or (_&Y2 = '2' and lh_rating_&Y2 ne 2) or (_&Y2 = 'Below' and lh_rating_&Y2 notin (3, 4) )then output results.bad_records;
	else if (_&Y3 = '1' and lh_rating_&Y3 ne 1) or (_&Y3 = '2' and lh_rating_&Y3 ne 2) or (_&Y3 = 'Below' and lh_rating_&Y3 notin (3, 4) )then output results.bad_records;
	else if (_&Y4 = '1' and lh_rating_&Y4 ne 1) or (_&Y4 = '2' and lh_rating_&Y4 ne 2) or (_&Y4 = 'Below' and lh_rating_&Y4 notin (3, 4) )then output results.bad_records;
	else if (_&Y5 = '1' and lh_rating_&Y5 ne 1) or (_&Y5 = '2' and lh_rating_&Y5 ne 2) or (_&Y5 = 'Below' and lh_rating_&Y5 notin (3, 4) )then output results.bad_records;
	else if (_&Y6 = '1' and lh_rating_&Y6 ne 1) or (_&Y6 = '2' and lh_rating_&Y6 ne 2) or (_&Y6 = 'Below' and lh_rating_&Y6 notin (3, 4) )then output results.bad_records;
	else if (_&Y7 = '1' and lh_rating_&Y7 ne 1) or (_&Y7 = '2' and lh_rating_&Y7 ne 2) or (_&Y7 = 'Below' and lh_rating_&Y7 notin (3, 4) )then output results.bad_records;

	else
		output results.good_records;
run;

/*Construction of the lin count table for the LH Rating: This matches the Q1FY23 data (manually created)*/
proc sql;
	create table results.TA_LH_Counts as
	select
		a.LH_RATING,
		a.FY&Y1 as FY&Y1,
		b.FY&Y2 as FY&Y2,
		c.FY&Y3 as FY&Y3,
		d.FY&Y4 as FY&Y4,
		e.FY&Y5 as FY&Y5,
		f.FY&Y6 as FY&Y6,
		g.FY&Y7 as FY&Y7
	from ((((((select distinct lh_rating_&Y1 as LH_RATING, count(lin) as FY&Y1 from results.good_records where lh_rating_&Y1 ne 0 group by 1) as a left join 
		 (select distinct lh_rating_&Y2 as LH_RATING, count(lin) as FY&Y2 from results.good_records where lh_rating_&Y2 ne 0 group by 1) as b on a.lh_rating = b.lh_rating)
		 left join (select distinct lh_rating_&Y3 as LH_RATING, count(lin) as FY&Y3 from results.good_records where lh_rating_&Y3 ne 0 group by 1) as c on a.lh_rating = c.lh_rating)
		 left join (select distinct lh_rating_&Y4 as LH_RATING, count(lin) as FY&Y4 from results.good_records where lh_rating_&Y4 ne 0 group by 1) as d on a.lh_rating = d.lh_rating)
		 left join (select distinct lh_rating_&Y5 as LH_RATING, count(lin) as FY&Y5 from results.good_records where lh_rating_&Y5 ne 0 group by 1) as e on a.lh_rating = e.lh_rating)
		 left join (select distinct lh_rating_&Y6 as LH_RATING, count(lin) as FY&Y6 from results.good_records where lh_rating_&Y6 ne 0 group by 1) as f on a.lh_rating = f.lh_rating)
		 left join (select distinct lh_rating_&Y7 as LH_RATING, count(lin) as FY&Y7 from results.good_records where lh_rating_&Y7 ne 0 group by 1) as g on a.lh_rating = g.lh_rating


	order by 1 desc;		
quit;


/*Now we are merging the LIN name, major capability and aba code to 
identify which LINs are AWCF funded*/
proc sql;
	create table results.f_TA_ERC_P_TABLE as
	select 
		a.*, b.nomenclature, b.major_capability, b.aba
	from results.good_records as a left join lmdb.lmdb_&lmdb_month as b 
	on a.lin = b.lin;
quit;

data results.f_TA_ERC_P_TABLE;
retain lin nomenclature major_capability 
		oh_&Y1 req_&Y1 eoh_&Y1 lh_rating_&Y1
	oh_&Y2 req_&Y2 eoh_&Y2 lh_rating_&Y2
	oh_&Y3 req_&Y3 eoh_&Y3 lh_rating_&Y3
	oh_&Y4 req_&Y4 eoh_&Y4 lh_rating_&Y4
	oh_&Y5 req_&Y5 eoh_&Y5 lh_rating_&Y5
	oh_&Y6 req_&Y6 eoh_&Y6 lh_rating_&Y6
	oh_&Y7 req_&Y7 eoh_&Y7 lh_rating_&Y7
	change stays_red fy&Y3._stays_red reduction s4_lin
	_&Y1 _&Y2 _&Y3 _&Y4 _&Y5 _&Y6 _&Y7 ;

	set results.f_TA_ERC_P_TABLE;
	
	if aba = '2' then AWCF_FUNDED = "Yes";

	drop _name_;

	
run;


proc sql;
	create table results.f_TA_ERC_P_W_EXEMPT as
	select 
	a.*,
	b.ta as Exempt
	from results.f_TA_ERC_P_TABLE as a left join total_army_exempt_lins as b 
	on a.lin = b.lin;
quit;
	

/*DJE added to make the processing of the data in excel easier 12FEB2016*/
proc sort data = results.f_TA_ERC_P_TABLE; by lin; run;


data results.flag_lin_reductions;
	set results.f_compo_erc_p_table;

	length drop_fy&Y1._fy&Y2 8 drop_fy&Y2._fy&Y3 8 add_fy&Y1._fy&Y2 8  add_fy&Y2._fy&Y3 8  ;

	if req_&Y1 >= 0 and req_&Y2 = . then drop_fy&Y1._fy&Y2 = 1;
	else if req_&Y1 = . and req_&Y2 >= 0 then add_fy&Y1._fy&Y2 = 1;

	if req_&Y2 >= 0 and req_&Y3 = . then drop_fy&Y2._fy&Y3 = 1;
	else if req_&Y2 = . and req_&Y3 >= 0 then add_fy&Y2._fy&Y3 = 1;


	if major_capability = '' then major_capability = "OTHER SYSTEMS";

run;

proc sql;
	create table results.compo_lin_req_changes as
	select distinct
		compo,
		major_capability,
		sum(drop_fy&Y1._fy&Y2) as drop_FY&Y1._fy&Y2,
		sum(add_FY&Y1._fy&Y2) as add_fy&Y1._fy&Y2,
		sum(drop_fy&Y2._fy&Y3) as drop_fy&Y2._fy&Y3,
		sum(add_fy&Y2._fy&Y3) as add_fy&Y2._fy&Y3
	from results.flag_lin_reductions
	group by compo,major_capability;
quit;

proc sql;
	create table results.avg_eoh_drop1 as
	select distinct
		compo,		
		major_capability,
		avg(eoh_&Y1) as drop_fy&Y1._fy&Y2._avg_eoh
	from results.flag_lin_reductions where drop_fy&Y1._fy&Y2 = 1
	group by compo,major_capability;
quit;

proc sql;
	create table results.avg_eoh_add1 as
	select distinct
		compo,
		major_capability,
		avg(eoh_&Y2) as add_fy&Y1._fy&Y2._avg_eoh
	from results.flag_lin_reductions where add_fy&Y1._fy&Y2 = 1
	group by compo,major_capability;
quit;



proc sql;
	create table results.avg_eoh_drop2 as
	select distinct
		compo,
		major_capability,
		avg(eoh_&Y2) as drop_fy&Y2._fy&Y3._avg_eoh
	from results.flag_lin_reductions where drop_fy&Y2._fy&Y3. = 1
	group by 1,2;
quit;

proc sql;
	create table results.avg_eoh_add2 as
	select distinct
		compo,
		major_capability,
		avg(eoh_&Y3) as add_fy&Y2._fy&Y3._avg_eoh
	from results.flag_lin_reductions where add_fy&Y2._fy&Y3. = 1
	group by 1,2;
quit;

proc sql;
	create table results.join_change_data1 as
	select
		a.*,
		b.drop_fy&Y1._fy&Y2._avg_eoh
	from results.compo_lin_req_changes as a left join results.avg_eoh_drop1 as b
	on a.compo =b.compo and a.major_capability = b.major_capability;
quit;

proc sql;
	create table results.join_change_data2 as
	select
		a.*,
		b.add_fy&Y1._fy&Y2._avg_eoh
	from results.join_change_data1 as a left join results.avg_eoh_add1 as b
	on a.compo =b.compo and a.major_capability = b.major_capability;
quit;
proc sql;
	create table results.join_change_data3 as
	select
		a.*,
		b.drop_fy&Y2._fy&Y3._avg_eoh
	from results.join_change_data2 as a left join results.avg_eoh_drop2 as b
	on a.compo =b.compo and a.major_capability = b.major_capability;
quit;

proc sql;
	create table results.join_change_data4 as
	select
		a.*,
		b.add_fy&Y2._fy&Y3._avg_eoh
	from results.join_change_data3 as a left join results.avg_eoh_add2 as b
	on a.compo =b.compo and a.major_capability = b.major_capability;
quit;

data results.pacing_lin_changes;
	set results.join_change_data4;

	array numbers{*} drop_fy&Y1._fy&Y2  add_fy&Y1._fy&Y2 drop_fy&Y2._fy&Y3 add_fy&Y2._fy&Y3
		drop_fy&Y1._fy&Y2._avg_eoh add_fy&Y1._fy&Y2._avg_eoh drop_fy&Y2._fy&Y3._avg_eoh add_fy&Y2._fy&Y3._avg_eoh;
	i = 1;
	total_change = 0;
	do while (i <= 8);
		if numbers[i] = . then numbers[i] = 0;

		if i <= 4 then total_change = total_change + numbers[i];
		i = i + 1;
	end;

	if numbers[1] + numbers[2] + numbers[3] + numbers[4] ne 0;

	drop i;
run;

data results.AC_pacing_lin_changes;
  set results.pacing_lin_changes;
   if compo=1;
run;


data results.NG_pacing_lin_changes;
  set results.pacing_lin_changes;
   if compo=2;
run;


data results.AR_pacing_lin_changes;
  set results.pacing_lin_changes;
   if compo=3;
run;


data results.APS_pacing_lin_changes;
  set results.pacing_lin_changes;
   if compo=6;
run;


data results.TA_flag_lin_reductions;
	set results.f_ta_erc_p_table;

	length drop_fy&Y1._fy&Y2 8 drop_FY&Y2._fy&Y3 8 add_fy&Y1._fy&Y2 8 add_FY&Y2._fy&Y3 8;

	if req_&Y1 > 0 and req_&Y2 = . then drop_fy&Y1._fy&Y2 = 1;
	else if req_&Y1 = . and req_&Y2 > 0 then add_fy&Y1._fy&Y2 = 1;

	if req_&Y2 > 0 and req_&Y3 = . then drop_FY&Y2._fy&Y3 = 1;
	else if req_&Y2 = . and req_&Y3 > 0 then add_FY&Y2._fy&Y3 = 1;

	if major_capability = '' then major_capability = "OTHER SYSTEMS";

run;

proc sql;
	create table results.TA_lin_req_changes as
	select distinct
		/*compo,*/
		major_capability,
		sum(drop_fy&Y1._fy&Y2) as drop_fy&Y1._fy&Y2,
		sum(add_fy&Y1._fy&Y2) as add_fy&Y1._fy&Y2,
		sum(drop_fy&Y2._fy&Y3) as drop_fy&Y2._fy&Y3,
		sum(add_fy&Y2._fy&Y3) as add_fy&Y2._fy&Y3
	from results.TA_flag_lin_reductions
	group by 1;
quit;

proc sql;
	create table results.TA_avg_eoh_drop1 as
	select distinct
		/*compo,		*/
		major_capability,
		avg(eoh_&Y2) as drop_fy&Y1._fy&Y2._avg_eoh
	from results.TA_flag_lin_reductions where drop_fy&Y1._fy&Y2 = 1
	group by 1;
quit;

proc sql;
	create table results.TA_avg_eoh_add1 as
	select distinct
		/*compo,*/
		major_capability,
		avg(eoh_&Y2) as add_fy&Y1._fy&Y2._avg_eoh
	from results.TA_flag_lin_reductions where add_fy&Y1._fy&Y2 = 1
	group by 1;
quit;



proc sql;
	create table results.TA_avg_eoh_drop2 as
	select distinct
		/*compo,*/
		major_capability,
		avg(eoh_&Y2) as drop_fy&Y2._fy&Y3._avg_eoh
	from results.TA_flag_lin_reductions where drop_fy&Y2._fy&Y3 = 1
	group by 1;
quit;

proc sql;
	create table results.TA_avg_eoh_add2 as
	select distinct
		/*compo,*/
		major_capability,
		avg(eoh_&Y3) as add_fy&Y2._fy&Y3._avg_eoh
	from results.TA_flag_lin_reductions where add_fy&Y2._fy&Y3 = 1
	group by 1;
quit;

proc sql;
	create table results.TA_join_change_data1 as
	select
		a.*,
		b.drop_fy&Y1._fy&Y2._avg_eoh
	from results.TA_lin_req_changes as a left join results.TA_avg_eoh_drop1 as b
	on /*a.compo =b.compo and*/ a.major_capability = b.major_capability;
quit;

proc sql;
	create table results.TA_join_change_data2 as
	select
		a.*,
		b.add_fy&Y1._fy&Y2._avg_eoh
	from results.TA_join_change_data1 as a left join results.TA_avg_eoh_add1 as b
	on /*a.compo =b.compo and */ a.major_capability = b.major_capability;
quit;
proc sql;
	create table results.TA_join_change_data3 as
	select
		a.*,
		b.drop_fy&Y2._fy&Y3._avg_eoh
	from results.TA_join_change_data2 as a left join results.TA_avg_eoh_drop2 as b
	on /*a.compo =b.compo and*/ a.major_capability = b.major_capability;
quit;

proc sql;
	create table results.TA_join_change_data4 as
	select
		a.*,
		b.add_fy&Y2._fy&Y3._avg_eoh
	from results.TA_join_change_data3 as a left join results.TA_avg_eoh_add2 as b
	on /*a.compo =b.compo and*/ a.major_capability = b.major_capability;
quit;

data results.TA_pacing_lin_changes;
	set results.TA_join_change_data4;

	array numbers{*} drop_fy&Y1._fy&Y2 add_fy&Y1._fy&Y2 drop_fy&Y2._fy&Y3 add_fy&Y2._fy&Y3
		drop_fy&Y1._fy&Y2._avg_eoh add_fy&Y1._fy&Y2._avg_eoh drop_fy&Y2._fy&Y3._avg_eoh add_fy&Y2._fy&Y3._avg_eoh;
	i = 1;
	total_change = 0;
	do while (i <= 8);
		if numbers[i] = . then numbers[i] = 0;

		if i <= 4 then total_change = total_change + numbers[i];
		i = i + 1;
	end;

	if numbers[1] + numbers[2] + numbers[3] + numbers[4] ne 0;

	drop i;
run;

data results.Requirements_FY_All;
	set results.TAEDP_ERC1 ;
	if REQ > 0;
	if FY in &date_range;
	if ERC IN  ("A","P");
run;

proc sql;
  create table results.REQ_FY_All as
    select distinct
	  FY,
	  sum(REQ) as REQ
	from results.Requirements_FY_All
	group by FY
	order by FY;
quit;

proc sql;
  create table results.REQ_FY_All_MINMAX as
    select distinct
	  a.FY,
	  a.REQ,
	  MIN(b.REQ) as MIN_REQ,
	  MAX(b.REQ) as MAX_REQ
	from results.REQ_FY_All as a
    left join results.REQ_FY_All as b on a.FY=b.FY;
quit;

proc transpose data = results.REQ_FY_All_MINMAX out = results.REQ_FY_All_xtab Prefix=FY;
	id FY;
run;


data results.Requirements_FY_ERCP;
	set results.TAEDP_ERC1 ;
	if REQ > 0;
	if FY in &date_range;
	if ERC ="P";
run;

proc sql;
  create table results.REQ_FY_ERCP as
    select distinct
	  FY,
	  sum(REQ) as REQ
	from results.Requirements_FY_ERCP
	group by FY
	order by FY;
quit;

proc sql;
  create table results.REQ_FY_ERCP_MINMAX as
    select distinct
	  a.FY,
	  a.REQ,
	  MIN(b.REQ) as MIN_REQ,
	  MAX(b.REQ) as MAX_REQ
	from results.REQ_FY_ERCP as a
    left join results.REQ_FY_ERCP as b on a.FY=b.FY;
quit;

proc transpose data = results.REQ_FY_ERCP_MINMAX out = results.REQ_FY_ERCP_xtab Prefix=FY;
	id FY;
run;


data results.Requirements_FY_ERCA;
	set results.TAEDP_ERC1 ;
	if REQ > 0;
	if FY in &date_range;
	if ERC ="A";
run;

proc sql;
  create table results.REQ_FY_ERCA as
    select distinct
	  FY,
	  sum(REQ) as REQ
	from results.Requirements_FY_ERCA
	group by FY
	order by FY;
quit;

proc sql;
  create table results.REQ_FY_ERCA_MINMAX as
    select distinct
	  a.FY,
	  a.REQ,
	  MIN(b.REQ) as MIN_REQ,
	  MAX(b.REQ) as MAX_REQ
	from results.REQ_FY_ERCA as a
    left join results.REQ_FY_ERCA as b on a.FY=b.FY;
quit;

proc transpose data = results.REQ_FY_ERCA_MINMAX out = results.REQ_FY_ERCA_xtab Prefix=FY;
	id FY;
run;

data results.s4_pacing_lins(keep= LIN nomenclature major_capability oh_&Y1 req_&Y1 eoh_&Y1 oh_&Y2 req_&Y2 eoh_&Y2 oh_&Y3 req_&Y3 eoh_&Y3);
  set results.f_TA_ERC_P_TABLE;
  if s4_lin = 1;
  if oh_&Y1 = . then oh_&Y1 = 0;
  if req_&Y1 = . then req_&Y1 = 0;
  if eoh_&Y1 = . then eoh_&Y1 = 0;
  if oh_&Y2 = . then oh_&Y2 = 0;
  if req_&Y2 = . then req_&Y2 = 0;
  if eoh_&Y2 = . then eoh_&Y2 = 0;
  if oh_&Y3 = . then oh_&Y3 = 0;
  if req_&Y3 = . then req_&Y3 = 0;
  if eoh_&Y3 = . then eoh_&Y3 = 0;
run;

proc sort data=results.s4_pacing_lins;
  by major_capability;
run;
;;
data _null_;
  set results.s4_pacing_lins nobs=obs;
  call symputx('num_S4_lins',obs);
run;
%put &num_S4_lins;
%let S4_size = %eval(&num_S4_lins / 2);
%put &S4_size;

data results.s4_pacing_lins_pt1;
  set results.s4_pacing_lins;
  IF _N_ LE &S4_size then output;
run;

data results.s4_pacing_lins_pt2;
  set results.s4_pacing_lins;
  IF _N_ GT &S4_size then output;
run;

data results.lin_health(keep= LIN nomenclature major_capability lh_rating_&Y1 lh_rating_&Y2 lh_rating_&Y3 lh_rating_&Y4 lh_rating_&Y5 lh_rating_&Y6 lh_rating_&Y7);
  set results.F_ta_erc_p_table;
  IF Change = 1;
run;

proc sort data=results.lin_health;
  by major_capability;
run;

data results.cross_threshold_lins(keep= COMPO LIN_LABEL nomenclature major_capability oh_&Y1 req_&Y1 eoh_&Y1 oh_&Y2 req_&Y2 eoh_&Y2 oh_&Y3 req_&Y3 eoh_&Y3);
  set results.f_COMPO_ERC_P_TABLE;
  if change = 1;
  if oh_&Y1 = . then oh_&Y1 = 0;
  if req_&Y1 = . then req_&Y1 = 0;
  if eoh_&Y1 = . then eoh_&Y1 = 0;
  if oh_&Y2 = . then oh_&Y2 = 0;
  if req_&Y2 = . then req_&Y2 = 0;
  if eoh_&Y2 = . then eoh_&Y2 = 0;
  if oh_&Y3 = . then oh_&Y3 = 0;
  if req_&Y3 = . then req_&Y3 = 0;
  if eoh_&Y3 = . then eoh_&Y3 = 0;
run;

proc sort data=results.cross_threshold_lins;
  by COMPO major_capability;
run;

data results.AC_cross_threshold_lins;
   set results.cross_threshold_lins;
   IF compo = 1;
run;

data results.NG_cross_threshold_lins;
   set results.cross_threshold_lins;
   IF compo = 2;
run;

data results.AR_cross_threshold_lins;
   set results.cross_threshold_lins;
   IF compo = 3;
run;

data results.APS_cross_threshold_lins;
   set results.cross_threshold_lins;
   IF compo = 6;
run;

data results.stay_below_80_lins(keep= COMPO LIN_LABEL nomenclature major_capability oh_&Y1 req_&Y1 eoh_&Y1 oh_&Y2 req_&Y2 eoh_&Y2 oh_&Y3 req_&Y3 eoh_&Y3);
  set results.f_COMPO_ERC_P_TABLE;;
  if FY&Y3._stays_red = 1;
  if oh_&Y1 = . then oh_&Y1 = 0;
  if req_&Y1 = . then req_&Y1 = 0;
  if eoh_&Y1 = . then eoh_&Y1 = 0;
  if oh_&Y2 = . then oh_&Y2 = 0;
  if req_&Y2 = . then req_&Y2 = 0;
  if eoh_&Y2 = . then eoh_&Y2 = 0;
  if oh_&Y3 = . then oh_&Y3 = 0;
  if req_&Y3 = . then req_&Y3 = 0;
  if eoh_&Y3 = . then eoh_&Y3 = 0;
run;

proc sort data=results.stay_below_80_lins;
  by COMPO major_capability;
run;

data results.AC_stay_below_80_lins;
   set results.stay_below_80_lins;
   IF compo = 1;
run;

data results.NG_stay_below_80_lins;
   set results.stay_below_80_lins;
   IF compo = 2;
run;

data results.AR_stay_below_80_lins;
   set results.stay_below_80_lins;
   IF compo = 3;
run;

data results.APS_stay_below_80_lins;
   set results.stay_below_80_lins;
   IF compo = 6;
run;

data _null_;
  set results.APS_stay_below_80_lins nobs=obs;
  call symputx('num_APSL',obs);
run;
%put &num_APSL;
%let APSL_size = %eval(&num_APSL / 2);
%put &APSL_size;

data results.APS_stay_below_80_lins_pt1;
  set results.APS_stay_below_80_lins;
  IF _N_ LE &APSL_size + 1 then output;
run;

data results.APS_stay_below_80_lins_pt2;
  set results.APS_stay_below_80_lins;
  IF _N_ GT &APSL_size + 1 then output;
run;


%include "&code_path\Module4.sas";




file name:  generate_reports_NGRER_new.sas

/* NOTES */ 
/* This is the second of four modules needed to process the authoritative data for the ASRA */
/* This module takes the substitute and primary inventories and formats each by Year, COMPO, LIN, ERC, MOD_LEVEL. */

/*%let inpath = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\Parham\ASRA\SAS_Created_Inputs;*/
/*%let outpath = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\Parham\ASRA\Module_Outputs;*/

libname in "&idm_input";
libname out "&ASRA_Reports_Path";

%let version =;

proc sql;
  create table idm_o.subbed&version as
     select 
		a.*,
		b.TYPCO_CAT
	 from idm_o.subbed&version as a
	 left join compo.uic_typco as b on a.units=b.uic;
quit;

/*Merge the substitution data with mod-levels*/

proc sql;
	create table add_ml_to_subs as
	select
		a.*,
		b.mod_level
	from idm_o.subbed&version as a left join in.lins as b
	on a.sublins = b.lins where a.modeling_dates in &date_list;
quit;


/*Summate the subbed inventory to the Year, COMPO, LIN, ERC, MOD_LEVEL level*/

proc sql;
	create table sum_sub_to_lin_ml as
	select distinct
		modeling_dates as year,
		compos as compo,
		typco_cat,
		lins as lin,
		ercs as erc,
		mod_level as mod_level,
		sum(sub_assign) as subbed_in
	from add_ml_to_subs
	group by modeling_dates, compos, typco_cat, lins, erc, mod_level;
quit;

proc transpose data = sum_sub_to_lin_ml out = subbed_xtab_ml;
	by year compo typco_cat lin erc;
	id mod_level;
	var subbed_in;
run;


proc sql;
  create table idm_o.Inv_positions&version as
     select 
		a.*,
		b.TYPCO_CAT
	 from idm_o.Inv_positions&version as a
	 left join compo.uic_typco as b on a.units=b.uic;
quit;
	     


/*Merge the inventory position data with mod-levels*/
proc sql;
	create table add_ml_to_inv as
	select
		a.*,
		b.mod_level
	from idm_o.Inv_positions&version as a left join in.lins as b
	on a.lins = b.lins where a.modeling_dates in &date_list;
quit;


/*Summate the subbed inventory to the Year, COMPO, LIN, ERC, MOD_LEVEL level*/

proc sql;
	create table sum_inv_to_lin_ml as
	select distinct
		modeling_dates as year,
		compos as compo,
		TYPCO_CAT,
		lins as lin,
		ercs as erc,
		mod_level as mod_level,
		sum(reqd) as req,
		sum(onhand) as on_hand,
		sum(shortages) as shortage,
		sum(total_excess) as excess
	from add_ml_to_inv
	group by modeling_dates, compos, TYPCO_CAT, lins, erc, mod_level;
quit;


/*Transpose the OH data onto the Mod-Level values*/

proc transpose data = sum_inv_to_lin_ml out = onhand_xtab_ml;
	by year compo TYPCO_CAT lin erc;
	id mod_level;
	var on_hand;
run;

/*Join in the onhand data by ML to the primary OH data*/

proc sql;
	create table join_r_n_s_to_Oh as
	select
		a.*,
 
/*		b._1 as ML1_OH,*/
/* */
		b._2 as ML2_OH,
		b._3 as ML3_OH,
		b._4 as ML4_OH,
		b._5 as ML5_OH
	from sum_inv_to_lin_ml as a left join onhand_xtab_ml as b
	on a.year = b.year and a.compo = b.compo and a.TYPCO_CAT = b.TYPCO_CAT and a.lin = b.lin and a.erc = b.erc;
quit;

/*Join in the subbed data by ML to the primary OH data*/
proc sql;
	create table join_OH_to_Subbed as
	select
		a.*,
  
/*		b._1 as ML1_Subbed,*/
/*  */
/*		b._2 as ML2_Subbed,*/
		b._3 as ML3_Subbed,
		b._4 as ML4_Subbed,
		b._5 as ML5_Subbed
	from join_r_n_s_to_Oh as a left join subbed_xtab_ml as b
	on a.year = b.year and a.compo = b.compo and a.TYPCO_CAT = b.TYPCO_CAT and a.lin = b.lin and a.erc = b.erc;
quit;


data make_oh_assigned_data;
	set join_OH_to_Subbed;

	array subbed{*} ML1_Subbed ML2_Subbed ML3_Subbed ML4_Subbed ML5_Subbed;
	array OH{*} ML1_OH ML2_OH ML3_OH ML4_OH ML5_OH;

	i = 1;
	total_subbed = 0;
	total_OH = 0;
	do i = 1 to 5;
		/*re-writing the nulls to 0*/
		if subbed[i]= . then subbed[i] = 0;
		/*updating the total subbed on hand values*/
		total_subbed = total_subbed + subbed[i];
		/*re-writing the nulls to 0*/
		if oh[i]= . then oh[i] = 0;
		/*update the total oh value*/
		total_oh = total_oh + oh[i];
		/*zeroing out the oh[i] elements for reassignment later*/
		oh[i] = 0;
	end;

	/*assignment of the real on hand,or on hand no subs, value*/
	roh = total_oh - total_subbed;

	/*Now we can properly align the ml#_onhand values*/
	do i = 1 to 5;
		/*if the mod level is the same as the i-counter then the the 
		on hand no subs is that mod level plus whatever is subbed in of
		the same mod_level*/
		if mod_level = i then do;
			oh[i] = roh + subbed[i];
		end;
		/*if the mod-level of a lin does not equal the i counter
		then the oh[i] is equal to whatever is subbing in of 
		that mod-level*/
		else do;
			oh[i] = oh[i] + subbed[i];
		end;

	end;

	/*overwrite null reqd/ on_hand/ shortage and excess data*/

	if req = . then req = 0;
	if on_hand = . then on_hand = 0;
	if shortage = . then shortage = 0;
	if excess = . then excess = 0;

run;


data out.ASRA_FORMAT_DATA&version;
	set make_oh_assigned_data;
run;

/*
proc datasets kill;
run;
quit;
*/

proc sql;
	create table sum_req_asra as
	select distinct
		year,
		compo,
		typco_cat,
		sum(req) as req
	from out.asra_format_data&version
	group by 1,2,3;
quit;







/*Assignment of global macro variables that are used to reference input data*/
/*Where the TAEDP data is pulled from*/

/* %let path =   C:\Users\FDA_01\Documents\IDM\2-ASRA\Q2FY18\ASRA_Q2FY18_BETA; */
%let version = ;

/*the name of the Financial Management Report File*/


/*Assignment of Libraries where output o1 input files will be put or read from.*/
libname ASRA "&Data_Output_Path";
libname LMDB "&Data_Input_Path";


/*
proc export data = asra.inv_positions&version outfile = "&path\inv_positions.csv"
	dbms = csv replace;
run;*/

/*Read in exempt LINs to tag as we assess ERC P Shortages*/
/*data exempt_lins;*/
/*	length*/
/*		lin $ 6*/
/*		TA $ 1*/
/*		AC $ 1*/
/*		ARNG $ 1*/
/*		USAR $ 1*/
/*		APS $ 1;*/
/*	infile "&Data_Input_Path\&exempt_lin_file..csv"*/
/*		firstobs = 2*/
/*		missover*/
/*		dlm=','*/
/*		dsd;*/
/*	input*/
/*		lin $*/
/*		TA $*/
/*		AC $ */
/*		ARNG $ */
/*		USAR $*/
/*		APS	$ ;*/
/*	transvar = 1;*/
/*run;*/
/**/
/*proc sort data = exempt_lins; by lin; run;*/
/**/
/*proc transpose data = exempt_lins out = lin_list;*/
/*by lin;*/
/*id transvar;*/
/*var ac arng usar;*/
/*run;*/
/**/
/*data f_lin_list;*/
/*	set lin_list;*/
/*	if upcase(_1) = "X";*/
/**/
/*	if _name_ = "AC" then compo = '11';*/
/*	else if _name_ = "ARNG" then compo = '21';*/
/*	else if _name_ = "TA" then compo = "T";*/
/*	else if _name_ = "APS" then compo = '61';*/
/*	else compo = "31";*/
/*	drop _name_ ;*/
/*	*/
/*run;*/


/*Read down the most recent FDIIS LQA file*/
/*data fdiis_lqa;*/
/*	length*/
/*		lin $ 6*/
/*		lin_in $ 6*/
/*		proc_fy 8*/
/*		compo $ 1*/
/*		qty 8;*/
/*	infile "&path.\&lqa_file..csv"*/
/*		firstobs = 2*/
/*		missover*/
/*		dlm=','*/
/*		dsd;*/
/*	input*/
/*		lin $*/
/*		lin_in $*/
/*		proc_fy */
/*		compo $*/
/*		qty;*/
/**/
/*run;*/

/*Sum up the FDIIS LQA data to the component-lin level for years 2017-2021*/

proc sql;
	create table fdiis_lqa_sum as
	select distinct
		compo||'1' as compo,
		lin,
		FY as proc_fy,
		sum(qty) as qty
	from compo._fdiis_lqa_prt1 where proc_fy in &date_range
	group by 1,2,3;
quit;

/*Transpose the data so that the years expand out into columns*/
proc transpose data = fdiis_lqa_sum out = fdiis_lqa_xtab_year;
	by compo lin;
	id proc_fy;
	var qty;
run;

/*Read down the TAEDP output file for ERC P Analysis*/
data taedp_set;
	set out.asra_format_data&version;
/*
	length
		status_dt 8  lin $ 6 erc $ 1 nomenclature $ 255 major_capability $ 30 lin_family $ 30
		lin_sub_family $ 30 current_puc 8 compo $ 1 typco $ 1 auth 8 req 8 oh 8
		roh 8 undist 8 subs_out 8 mod_level 8 ml5_qty 8	ml4_qty 8 ml3_qty 8
		ml2_qty 8 ml1_qty 8	no_ml_qty 8;
	infile "&path\&taedp_file..csv"
		dsd dlm=',' missover firstobs = 2;
	informat
		status_dt mmddyy10.;
	format
		status_dt mmddyy10.;
	input
		status_dt lin $ erc $ nomenclature $ major_capability $ lin_family $ lin_sub_family $ 
		current_puc compo $ typco $	auth req oh roh undist subs_out mod_level ml5_qty ml4_qty 
		ml3_qty ml2_qty ml1_qty no_ml_qty ;

*/
run;

proc sql;
	create table join_lin_data as
	select
		a.*, b.nomen as nomenclature, b.MAJOR_CAPABILITY_NAME as major_capability, b.LIN_FAMILY_NAME as lin_family, b.puc as current_puc
	from taedp_set as a left join lmdb.lmdb_&lmdb_month as b
	on a.lin = b.lin;
quit;


/*Add columns to the TAEDP set to enable calculations and easier analysis of the 
final data
The LIN level EOH percentage is calculated here since we are mainly concerned
with the ERC P LIN EOH and not the aggregate component level EOH*/
data TAEDP_ERC1;
	length COMPO_CAT $4;
	set join_lin_data;

	FY = year;
	if substrn(COMPO,1,1) = '1' then COMPO_CAT = "AC";
	else if substrn(COMPO,1,1) = '2' then COMPO_CAT = "ARNG";
	else if substrn(COMPO,1,1) = '3' then COMPO_CAT = "USAR";
	else if COMPO = 'T' then COMPO_CAT = "TPE";
	else if COMPO = 'S' then COMPO_CAT = "DEP";
	else if substrn(COMPO,1,1) = '6' then COMPO_CAT = "APS";


/*	if substrn(COMPO,2,1) in ('1' '2') then TYPCO_CAT = "MTOE";*/
/*	else TYPCO_CAT = "TDA";*/

	OH_CAPPED = min(REQ, On_hand);
	if REQ = 0 then EOH = 1;
	else EOH = OH_CAPPED/REQ;
	length RATING $5;
	/*Assignment of LINs that have an equipment rating of 1*/
	if EOH >= .895 then RATING = "1";
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH >= .795 then RATING = "2";
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else RATING = "Below";
run;

data idm_o.taedp_erc1;
   set taedp_erc1;
run;


/*Filtering the full Component level TAEDP set down to only the ERC P entries*/




file name:  generate_reports_NGRER_calc.sas

/* NOTES */ 
/* This is the second of four modules needed to process the authoritative data for the ASRA */
/* This module takes the substitute and primary inventories and formats each by Year, COMPO, LIN, ERC, MOD_LEVEL. */

/*%let inpath = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\Parham\ASRA\SAS_Created_Inputs;*/
/*%let outpath = O:\G8_DATA\FD\17 FDA (Warfighting Analysis)\Parham\ASRA\Module_Outputs;*/

libname in "&idm_input";
libname out "&ASRA_Reports_Path";

%let version =;

proc sql;
  create table idm_o.subbed&version as
     select 
		a.*,
		b.TYPCO_CAT
	 from idm_o.subbed&version as a
	 left join compo.uic_typco as b on a.units=b.uic;
quit;

/*Merge the substitution data with mod-levels*/

proc sql;
	create table add_ml_to_subs as
	select
		a.*,
		b.mod_level
	from idm_o.subbed&version as a left join in.lins as b
	on a.sublins = b.lins where a.modeling_dates in &date_list;
quit;


/*Summate the subbed inventory to the Year, COMPO, LIN, ERC, MOD_LEVEL level*/

proc sql;
	create table sum_sub_to_lin_ml as
	select distinct
		modeling_dates as year,
		compos as compo,
		typco_cat,
		lins as lin,
		ercs as erc,
		mod_level as mod_level,
		sum(sub_assign) as subbed_in
	from add_ml_to_subs
	group by modeling_dates, compos, typco_cat, lins, erc, mod_level;
quit;

proc transpose data = sum_sub_to_lin_ml out = subbed_xtab_ml;
	by year compo typco_cat lin erc;
	id mod_level;
	var subbed_in;
run;


proc sql;
  create table idm_o.Inv_positions&version as
     select 
		a.*,
		b.TYPCO_CAT
	 from idm_o.Inv_positions&version as a
	 left join compo.uic_typco as b on a.units=b.uic;
quit;
	     


/*Merge the inventory position data with mod-levels*/
proc sql;
	create table add_ml_to_inv as
	select
		a.*,
		b.mod_level
	from idm_o.Inv_positions&version as a left join in.lins as b
	on a.lins = b.lins where a.modeling_dates in &date_list;
quit;


/*Summate the subbed inventory to the Year, COMPO, LIN, ERC, MOD_LEVEL level*/

proc sql;
	create table sum_inv_to_lin_ml as
	select distinct
		modeling_dates as year,
		compos as compo,
		TYPCO_CAT,
		lins as lin,
		ercs as erc,
		mod_level as mod_level,
		sum(reqd) as req,
		sum(onhand) as on_hand,
		sum(shortages) as shortage,
		sum(total_excess) as excess
	from add_ml_to_inv
	group by modeling_dates, compos, TYPCO_CAT, lins, erc, mod_level;
quit;


/*Transpose the OH data onto the Mod-Level values*/

proc transpose data = sum_inv_to_lin_ml out = onhand_xtab_ml;
	by year compo TYPCO_CAT lin erc;
	id mod_level;
	var on_hand;
run;

/*Join in the onhand data by ML to the primary OH data*/

proc sql;
	create table join_r_n_s_to_Oh as
	select
		a.*,
 
/*		b._1 as ML1_OH,*/
/* */
		b._2 as ML2_OH,
		b._3 as ML3_OH,
		b._4 as ML4_OH,
		b._5 as ML5_OH
	from sum_inv_to_lin_ml as a left join onhand_xtab_ml as b
	on a.year = b.year and a.compo = b.compo and a.TYPCO_CAT = b.TYPCO_CAT and a.lin = b.lin and a.erc = b.erc;
quit;

/*Join in the subbed data by ML to the primary OH data*/
proc sql;
	create table join_OH_to_Subbed as
	select
		a.*,
  
/*		b._1 as ML1_Subbed,*/
/*  */
/*		b._2 as ML2_Subbed,*/
		b._3 as ML3_Subbed,
		b._4 as ML4_Subbed,
		b._5 as ML5_Subbed
	from join_r_n_s_to_Oh as a left join subbed_xtab_ml as b
	on a.year = b.year and a.compo = b.compo and a.TYPCO_CAT = b.TYPCO_CAT and a.lin = b.lin and a.erc = b.erc;
quit;


data make_oh_assigned_data;
	set join_OH_to_Subbed;

	array subbed{*} ML1_Subbed ML2_Subbed ML3_Subbed ML4_Subbed ML5_Subbed;
	array OH{*} ML1_OH ML2_OH ML3_OH ML4_OH ML5_OH;

	i = 1;
	total_subbed = 0;
	total_OH = 0;
	do i = 1 to 5;
		/*re-writing the nulls to 0*/
		if subbed[i]= . then subbed[i] = 0;
		/*updating the total subbed on hand values*/
		total_subbed = total_subbed + subbed[i];
		/*re-writing the nulls to 0*/
		if oh[i]= . then oh[i] = 0;
		/*update the total oh value*/
		total_oh = total_oh + oh[i];
		/*zeroing out the oh[i] elements for reassignment later*/
		oh[i] = 0;
	end;

	/*assignment of the real on hand,or on hand no subs, value*/
	roh = total_oh - total_subbed;

	/*Now we can properly align the ml#_onhand values*/
	do i = 1 to 5;
		/*if the mod level is the same as the i-counter then the the 
		on hand no subs is that mod level plus whatever is subbed in of
		the same mod_level*/
		if mod_level = i then do;
			oh[i] = roh + subbed[i];
		end;
		/*if the mod-level of a lin does not equal the i counter
		then the oh[i] is equal to whatever is subbing in of 
		that mod-level*/
		else do;
			oh[i] = oh[i] + subbed[i];
		end;

	end;

	/*overwrite null reqd/ on_hand/ shortage and excess data*/

	if req = . then req = 0;
	if on_hand = . then on_hand = 0;
	if shortage = . then shortage = 0;
	if excess = . then excess = 0;

run;


data out.ASRA_FORMAT_DATA&version;
	set make_oh_assigned_data;
run;

/*
proc datasets kill;
run;
quit;
*/

proc sql;
	create table sum_req_asra as
	select distinct
		year,
		compo,
		typco_cat,
		sum(req) as req
	from out.asra_format_data&version
	group by 1,2,3;
quit;







/*Assignment of global macro variables that are used to reference input data*/
/*Where the TAEDP data is pulled from*/

/* %let path =   C:\Users\FDA_01\Documents\IDM\2-ASRA\Q2FY18\ASRA_Q2FY18_BETA; */
%let version = ;

/*the name of the Financial Management Report File*/


/*Assignment of Libraries where output o1 input files will be put or read from.*/
libname ASRA "&Data_Output_Path";
libname LMDB "&Data_Input_Path";


/*
proc export data = asra.inv_positions&version outfile = "&path\inv_positions.csv"
	dbms = csv replace;
run;*/

/*Read in exempt LINs to tag as we assess ERC P Shortages*/
/*data exempt_lins;*/
/*	length*/
/*		lin $ 6*/
/*		TA $ 1*/
/*		AC $ 1*/
/*		ARNG $ 1*/
/*		USAR $ 1*/
/*		APS $ 1;*/
/*	infile "&Data_Input_Path\&exempt_lin_file..csv"*/
/*		firstobs = 2*/
/*		missover*/
/*		dlm=','*/
/*		dsd;*/
/*	input*/
/*		lin $*/
/*		TA $*/
/*		AC $ */
/*		ARNG $ */
/*		USAR $*/
/*		APS	$ ;*/
/*	transvar = 1;*/
/*run;*/
/**/
/*proc sort data = exempt_lins; by lin; run;*/
/**/
/*proc transpose data = exempt_lins out = lin_list;*/
/*by lin;*/
/*id transvar;*/
/*var ac arng usar;*/
/*run;*/
/**/
/*data f_lin_list;*/
/*	set lin_list;*/
/*	if upcase(_1) = "X";*/
/**/
/*	if _name_ = "AC" then compo = '11';*/
/*	else if _name_ = "ARNG" then compo = '21';*/
/*	else if _name_ = "TA" then compo = "T";*/
/*	else if _name_ = "APS" then compo = '61';*/
/*	else compo = "31";*/
/*	drop _name_ ;*/
/*	*/
/*run;*/


/*Read down the most recent FDIIS LQA file*/
/*data fdiis_lqa;*/
/*	length*/
/*		lin $ 6*/
/*		lin_in $ 6*/
/*		proc_fy 8*/
/*		compo $ 1*/
/*		qty 8;*/
/*	infile "&path.\&lqa_file..csv"*/
/*		firstobs = 2*/
/*		missover*/
/*		dlm=','*/
/*		dsd;*/
/*	input*/
/*		lin $*/
/*		lin_in $*/
/*		proc_fy */
/*		compo $*/
/*		qty;*/
/**/
/*run;*/

/*Sum up the FDIIS LQA data to the component-lin level for years 2017-2021*/

proc sql;
	create table fdiis_lqa_sum as
	select distinct
		compo||'1' as compo,
		lin,
		FY as proc_fy,
		sum(qty) as qty
	from compo._fdiis_lqa_prt1 where proc_fy in &date_range
	group by 1,2,3;
quit;

/*Transpose the data so that the years expand out into columns*/
proc transpose data = fdiis_lqa_sum out = fdiis_lqa_xtab_year;
	by compo lin;
	id proc_fy;
	var qty;
run;

/*Read down the TAEDP output file for ERC P Analysis*/
data taedp_set;
	set out.asra_format_data&version;
/*
	length
		status_dt 8  lin $ 6 erc $ 1 nomenclature $ 255 major_capability $ 30 lin_family $ 30
		lin_sub_family $ 30 current_puc 8 compo $ 1 typco $ 1 auth 8 req 8 oh 8
		roh 8 undist 8 subs_out 8 mod_level 8 ml5_qty 8	ml4_qty 8 ml3_qty 8
		ml2_qty 8 ml1_qty 8	no_ml_qty 8;
	infile "&path\&taedp_file..csv"
		dsd dlm=',' missover firstobs = 2;
	informat
		status_dt mmddyy10.;
	format
		status_dt mmddyy10.;
	input
		status_dt lin $ erc $ nomenclature $ major_capability $ lin_family $ lin_sub_family $ 
		current_puc compo $ typco $	auth req oh roh undist subs_out mod_level ml5_qty ml4_qty 
		ml3_qty ml2_qty ml1_qty no_ml_qty ;

*/
run;

proc sql;
	create table join_lin_data as
	select
		a.*, b.nomen as nomenclature, b.MAJOR_CAPABILITY_NAME as major_capability, b.LIN_FAMILY_NAME as lin_family, b.puc as current_puc
	from taedp_set as a left join lmdb.lmdb_&lmdb_month as b
	on a.lin = b.lin;
quit;


/*Add columns to the TAEDP set to enable calculations and easier analysis of the 
final data
The LIN level EOH percentage is calculated here since we are mainly concerned
with the ERC P LIN EOH and not the aggregate component level EOH*/
data TAEDP_ERC1;
	length COMPO_CAT $4;
	set join_lin_data;

	FY = year;
	if substrn(COMPO,1,1) = '1' then COMPO_CAT = "AC";
	else if substrn(COMPO,1,1) = '2' then COMPO_CAT = "ARNG";
	else if substrn(COMPO,1,1) = '3' then COMPO_CAT = "USAR";
	else if COMPO = 'T' then COMPO_CAT = "TPE";
	else if COMPO = 'S' then COMPO_CAT = "DEP";
	else if substrn(COMPO,1,1) = '6' then COMPO_CAT = "APS";


/*	if substrn(COMPO,2,1) in ('1' '2') then TYPCO_CAT = "MTOE";*/
/*	else TYPCO_CAT = "TDA";*/

	OH_CAPPED = min(REQ, On_hand);
	if REQ = 0 then EOH = 1;
	else EOH = OH_CAPPED/REQ;
	length RATING $5;
	/*Assignment of LINs that have an equipment rating of 1*/
	if EOH >= .895 then RATING = "1";
	/*Assignment of LINs that have an equipment rating of 2*/
	else if .895 > EOH >= .795 then RATING = "2";
	/*Assignment of LINs that have an equipment rating of 3 or 4*/
	else RATING = "Below";
run;

data idm_o.taedp_erc1;
   set taedp_erc1;
run;


/*Filtering the full Component level TAEDP set down to only the ERC P entries*/



file name: generate_opt_model_inputs_nocascadeTEST.sas

	data idm_i.i_end_time;

		call symputx("end_time", put(time(),time8.0));
		obs = 1;
		i_end_time = time();
	run;

	%put &end_time;
	data idm_i.stats;
		merge idm_i.i_start_time idm_i.i_end_time;
		by obs;

		i_run_time = i_end_time - i_start_time;

		format i_run_time time8.0;

		format i_start_time time8.0;
		format i_end_time time8.0;

	run;


	data c_start_time;
		obs = 1;
		c_start_time = time();
	run;


%macro make_other_inputs();

	%macro write_inputs();

	data idm_i.Darpl;
		set compo.Darpl_priority1;
		length dates 8;
		dates = FY;

		rename uic = units;
		rename compo = compos;

		drop FY;
	run;

%IF &SSO_update = 1 %then 
  %do;
    data idm_i.requirements;
		set compo.sacs_uic2;
/*		length dates 8;*/
/*		dates = FY;*/
/*		rename uic = units;*/
/*		rename compo = compos;*/
/*		rename lin = lins;*/
/*		rename erc = ercs;*/
/*		rename req = reqd;*/


/*		drop FY typco auth;*/
	run;
%end;
%else %do;
	data idm_i.requirements;
		set compo.sacs_uic;
		length dates 8;
		dates = FY;
		rename uic = units;
		rename compo = compos;
		rename lin = lins;
		rename erc = ercs;
		rename req = reqd;


		drop FY typco auth;
	run;
%end;

 	data idm_i.procurements;
		set compo._fdiis_lqa_prt1;

		rename FY = dates;	
		rename compo = compos;
		rename lin = lins;

	run;

	data idm_i.inventory;

		set compo.inventory_by_uic;
		dates = &current_fy;

		
		rename compo = compos;
		rename lin = lins;	
		rename uic = units;
		rename qty = inv;
/*		rename erc = ercs;*/

/*		drop status_dt;*/

	run;


    data idm_i.LMI_XFER_REMOVE;
		set compo.LMI_XFER_REMOVE;
	run;

	data idm_i.LMI_XFER_ADD;
		set compo.LMI_XFER_ADD;
	run;

	data idm_i.units_compo_number;
		set compo.units;
		rename uic = units;
		rename compo = compos;
	run;

	data idm_i.units;
		set compo.units;
		rename uic = units;
		keep uic;
	run;

	data idm_i.compos;
		set compo.compos;
	run;

	data idm_i.ercs;
		set compo.ercs;
	run;


    data idm_i.lins(rename=lin=lins);
/*		set reqd_lin;*/
		set lmdb.lins;

	run;
/*** Replaced distinct LINs with new dataset per Aria 9/23/22 to only include lins in SACs   *****/
/*	data idm_i.lins;*/
/*		set lmdb.lins;*/
/*	run;*/
/*******     END Changes                                                                     *****/


	data idm_i.sub_rules;
		set lmdb.subrules_final;

		length sources 8;

		rename lin = lins;
		rename sublin = sublins;

		sources = substrn(source,1,1);

		drop run_id start_dt source;
		
		rename sources = source;
	run;

	proc sql;
		create table date_i as
		select distinct
			dates
		from idm_i.inventory;
	quit;


	proc sql;
		insert into date_i
		select distinct
			dates
		from idm_i.procurements;
	quit;



	proc sql;
		insert into date_i
		select distinct
			dates
		from idm_i.requirements;
	quit;

	proc sql;
		create table idm_i.dates as
		select distinct
			dates as dates
		from date_i 
        where dates <= &MAX_DATE.;
	quit;

	proc sql;
		create table idm_i.study_timeframe as
		select distinct
			min(dates) as first_year,
			max(dates) as last_year
		from idm_i.dates;
	quit;

	proc sql;
		create table idm_i.compo_transfer as
		select
			compos as to_compos,
			compos as from_compos,
			1 as valid
		from idm_i.compos;
	quit;

	%mend;
	%write_inputs;



	%if %eval(&run_cluster = 1) %then %include "&code_path\Make_Clusters_Optmodel_with_LINs.sas";

	%mend;
	%make_other_inputs();

	data c_end_time;
		obs = 1;
		c_end_time = time();
	run;

	data idm_i.stats;
		merge idm_i.stats c_start_time c_end_time;
		by obs;

		c_run_time = c_end_time - c_start_time;

		format c_run_time time8.0;

		format c_start_time time8.0;
		format c_end_time time8.0;
	run;
/*%end;*/
/*%mend;*/

	/*write inputs to idm_model library*/


	data idm_i.fill_target;
		length 
			target_percentage 8;
		input
			target_percentage;
		datalines;
	1.0
	;
	run;


	data idm_i.subs_to_ignore;
		length 
			source $ 4;
		input
			source $ ;
		datalines;
	3-
	4-
	5-
	6-
	7-IN
	8-   
	9-
	;
	run;

	data idm_i.xfer_additions;
		 infile datalines delimiter=','; 
		length 
			to_compos $ 1 from_compos $ 1 valid 8;
		input
			to_compos $ from_compos $ valid;
		datalines;
2,2,1
3,3,1
/*2,6,1*/
/*3,6,1*/
/***RR changed the from_compos from 1 to 2 and 3 AND commented out the last 2 rows***/
	;
	run;

proc append base = idm_i.compo_transfer data = idm_i.xfer_additions;
run;


data m_start_time;
	obs = 1;
	m_start_time = time();
run;




file name: generate_opt_model_inputs.sas

	data idm_i.i_end_time;

		call symputx("end_time", put(time(),time8.0));
		obs = 1;
		i_end_time = time();
	run;

	%put &end_time;
	data idm_i.stats;
		merge idm_i.i_start_time idm_i.i_end_time;
		by obs;

		i_run_time = i_end_time - i_start_time;

		format i_run_time time8.0;

		format i_start_time time8.0;
		format i_end_time time8.0;

	run;


	data c_start_time;
		obs = 1;
		c_start_time = time();
	run;


%macro make_other_inputs();

	%macro write_inputs();

	data idm_i.Darpl;
		set compo.Darpl_priority1;
		length dates 8;
		dates = FY;

		rename uic = units;
		rename compo = compos;

		drop FY;
	run;

%IF &SSO_update = 1 %then 
  %do;
    data idm_i.requirements;
		set compo.sacs_uic2;
/*		length dates 8;*/
/*		dates = FY;*/
/*		rename uic = units;*/
/*		rename compo = compos;*/
/*		rename lin = lins;*/
/*		rename erc = ercs;*/
/*		rename req = reqd;*/


/*		drop FY typco auth;*/
	run;
%end;
%else %do;
	data idm_i.requirements;
		set compo.sacs_uic;
		length dates 8;
		dates = FY;
		rename uic = units;
		rename compo = compos;
		rename lin = lins;
		rename erc = ercs;
		rename req = reqd;


		drop FY typco auth;
	run;
%end;

 	data idm_i.procurements;
		set compo._fdiis_lqa_prt1;

		rename FY = dates;	
		rename compo = compos;
		rename lin = lins;

	run;

	data idm_i.inventory;

		set compo.inventory_by_uic;
		dates = &current_fy;

		
		rename compo = compos;
		rename lin = lins;	
		rename uic = units;
		rename qty = inv;
/*		rename erc = ercs;*/

/*		drop status_dt;*/

	run;


    data idm_i.LMI_XFER_REMOVE;
		set compo.LMI_XFER_REMOVE;
	run;

	data idm_i.LMI_XFER_ADD;
		set compo.LMI_XFER_ADD;
	run;

	data idm_i.units_compo_number;
		set compo.units;
		rename uic = units;
		rename compo = compos;
	run;

	data idm_i.units;
		set compo.units;
		rename uic = units;
		keep uic;
	run;

	data idm_i.compos;
		set compo.compos;
	run;

	data idm_i.ercs;
		set compo.ercs;
	run;


    data idm_i.lins(rename=lin=lins);
/*		set reqd_lin;*/
		set lmdb.lins;

	run;
/*** Replaced distinct LINs with new dataset per Aria 9/23/22 to only include lins in SACs   *****/
/*	data idm_i.lins;*/
/*		set lmdb.lins;*/
/*	run;*/
/*******     END Changes                                                                     *****/


	data idm_i.sub_rules;
		set lmdb.subrules_final;

		length sources 8;

		rename lin = lins;
		rename sublin = sublins;

		sources = substrn(source,1,1);

		drop run_id start_dt source;
		
		rename sources = source;
	run;

	proc sql;
		create table date_i as
		select distinct
			dates
		from idm_i.inventory;
	quit;


	proc sql;
		insert into date_i
		select distinct
			dates
		from idm_i.procurements;
	quit;



	proc sql;
		insert into date_i
		select distinct
			dates
		from idm_i.requirements;
	quit;

	proc sql;
		create table idm_i.dates as
		select distinct
			dates as dates
		from date_i 
        where dates <= &MAX_DATE.;
	quit;

	proc sql;
		create table idm_i.study_timeframe as
		select distinct
			min(dates) as first_year,
			max(dates) as last_year
		from idm_i.dates;
	quit;

	proc sql;
		create table idm_i.compo_transfer as
		select
			compos as to_compos,
			compos as from_compos,
			1 as valid
		from idm_i.compos;
	quit;

	%mend;
	%write_inputs;



	%if %eval(&run_cluster = 1) %then %include "&code_path\Make_Clusters_Optmodel_with_LINs.sas";

	%mend;
	%make_other_inputs();

	data c_end_time;
		obs = 1;
		c_end_time = time();
	run;

	data idm_i.stats;
		merge idm_i.stats c_start_time c_end_time;
		by obs;

		c_run_time = c_end_time - c_start_time;

		format c_run_time time8.0;

		format c_start_time time8.0;
		format c_end_time time8.0;
	run;
/*%end;*/
/*%mend;*/

	/*write inputs to idm_model library*/


	data idm_i.fill_target;
		length 
			target_percentage 8;
		input
			target_percentage;
		datalines;
	1.0
	;
	run;


	data idm_i.subs_to_ignore;
		length 
			source $ 4;
		input
			source $ ;
		datalines;
	3-
	4-
	5-
	6-
	7-IN
	8-   
	9-
	;
	run;

	data idm_i.xfer_additions;
		 infile datalines delimiter=','; 
		length 
			to_compos $ 1 from_compos $ 1 valid 8;
		input
			to_compos $ from_compos $ valid;
		datalines;
2,1,1
3,1,1
2,6,1
3,6,1
	;
	run;

proc append base = idm_i.compo_transfer data = idm_i.xfer_additions;
run;


data m_start_time;
	obs = 1;
	m_start_time = time();
run;




file name: generate_clusters.sas

/*The macro defined below will remove all components that do not have any inventory data associated to them
inventory data is defined as a requirement, items in the inventory, procurements, or transfers*/
%macro get_relevant_clusters();


/*This sql step will summarize all of the DST removals for a LIN in any year and
add a label that will later be transposed on*/
		proc sql;
			create table all_inv_table as
			
			select distinct
				lins,
				sum(qty) as value,
				"xfer_out " as label
			from idm_i.Lmi_xfer_remove
			group by lins;
		quit;

/*This sql step inserts into the table defined above the summarized inventory for a LIN in any year and
add a label that will later be transposed on*/
	proc sql;
		insert into all_inv_table
		select
			lins,
			sum(inv) as value,
			"inv     " as label
		from idm_i.inventory
		group by lins;
	quit;

	

/*This sql step inserts into the table defined above the summarized total required for a LIN in any year and
add a label that will later be transposed on*/
	proc sql;
		insert into all_inv_table
		select
			lins,
			sum(reqd) as value,
			"reqd     " as label
		from idm_i.requirements
		group by lins;
	quit;
	
/*This sql step inserts into the table defined above the summarized procurements for a LIN in any year and
add a label that will later be transposed on*/
	proc sql;
		insert into all_inv_table
		select
			lins,
/*			sum(procs) as value,*/
			sum(qty) as value,
			"procs " as label
		from idm_i.procurements
		group by lins;
	quit;

	
	
/*This sql step inserts into the table defined above summarized DST adds for a LIN in any year and
add a label that will later be transposed on*/
		proc sql;
			insert into all_inv_table
			select distinct
				lins,
				sum(qty) as value,
				"xfer_in " as label
			from idm_i.Lmi_xfer_add
			group by lins;
		quit;
		
	proc sort data = all_inv_table; by lins label; run;

/*This procedure transposes the data by lin for all of the values and onto the labels*/
	proc transpose data = all_inv_table out = inv_xtab_value;
		by lins;
		id label;
		var value;
	run;

/*This data step evaluates whether or not a LIN has inventory data*/
	data lins_inv;
		set inv_xtab_value;

		if inv = . then inv = 0;
		if reqd = . then reqd = 0;
		if procs = . then procs = 0;
		if xfer_in = . then xfer_in = 0;
		if xfer_out = . then xfer_out = 0;


		total_quant = inv + reqd + procs + xfer_out + xfer_in;

		if total_quant > 0;



/*This if-then statement can be used to run a listing of LINs*/
		%if %eval(&lin_list="ALL") %then %do;
		%end;
		%else %do;
			if lins in &lin_list;
		%end;

	run;


/*This sql step joins the relevant lins onto the cluster data to get down to 
	the relevant LINs and components*/
	proc sql;
		create table clusters as
		select
			a.*
		from idm_i.clusters&cluster_tag as a inner join lins_inv as b on a.lins = b.lins where a.lins ne '';
	quit;


%mend;
/*This line of code envokes the macro defined above.*/
%get_relevant_clusters();
		

/*This macro will run through all of the relevant clusters that exist in the data.
Within this procedure many tempory datasets are created and referenced from the 
actual input data*/
%macro run_opt_clusters();


/*This macro variable is used to retain the value of the actual component
that the procedure is processing.*/
	%let working_comp =  0;

/*This macro variable will be the terminal condition for the outer do loop that processes
	all components*/
	%let num_comps = 0;

/*This SQL statement makes a data set that represents the distinct components that will be processed*/
	proc sql;
		create table distinct_components as
		select distinct
			component, count(lins) as lin_count
		from clusters group by component order by lin_count desc ;
	quit;

	data multi_lin_clusters;
	  set distinct_components;
	  IF lin_count GT 1;
	  drop lin_count;
	run;

	data single_lin_clusters;
	  set distinct_components;
	  IF lin_count = 1;
	  drop lin_count;
	run;

	proc sql;
	    create table lins_single_cluster as
		   select distinct
		      a.lins,
			  a.component
		   from clusters as a inner join
		   single_lin_clusters as b on a.component=b.component;
	quit;

	proc sql;
	    create table sacs_lins as
		   select distinct
		      lins
		   from idm_i.requirements;
	quit;

	proc sql;
	    create table good_lins_single_cluster as
		   select distinct
			  a.component
		   from lins_single_cluster as a inner join
		   sacs_lins as b on a.lins=b.lins;
	quit;
		      
	data good_clusters;
	   set multi_lin_clusters good_lins_single_cluster;
	run;



	/*This SQL statement counts the number of distinct components that will be processed and
	assigns this value into the macro variable "number of components"*/
	proc sql noprint;
		select
			count(component) into :num_comps
/*		from distinct_components;*/
		from good_clusters;   /* we removed all single lin clusters for lins with no requirements 8JUL2021 - LHB  */
	quit;



	/*Code added to handle running a single component*/
	%if (%eval(&single_component.) > 0) %then %do;
		data select_component;
/*			set distinct_components;*/
			set good_clusters;

			if component = &single_component.;
		run;

/*		data distinct_components;*/
		data good_clusters;
			set select_component;
		run;

		%let num_comps = 1;
	%end;


/*This line of code writes a line to the log that states the number of
	components that will iterate over*/
	%put There are &num_comps to process;

/*This data set initialized the output table that will contain all lin to lin assignments
	for all years, compos, units, lins and ercs.*/
	
			data idm_o.Assigned;
				length modeling_dates 8 compos $ 2 units $ 6 lins $ 6 ercs $ 1 assign 8;
			run;

/*This data set initialized the output table that will contain all additional inventory
			that the model had to add to accomodate for an infeasible transfer.*/
			
			data idm_o.Infe_Adds;
				length modeling_dates 8 compos $ 2 lins $ 6 add_inv 8 component 8;
			run;

/*This data set initialized the output table that will contain substitution assignments
			for all years, compos, units, lins, sublins, and to what erc.*/
			
			data idm_o.subbed;
				length modeling_dates 8 compos $ 2 units $ 6 lins $ 6 sublins $ 6 ercs $ 1 sub_assign 8;
			run;

/*This data set initialized the output table that will contain shortages exist
			for all years, compos, units, lins, and in what erc.*/
			
			data idm_o.shortage;
				length modeling_dates 8 compos $ 2 units $ 6 lins $ 6 ercs $ 1 shortage 8;
			run;


/*This data set initialized the output table that will contain transfers from one component to another
			for all years, compos, units, lins, sublins, and to what erc.*/
			

			data idm_o.sub_xferred;
				length modeling_dates 8 to_compos $ 2 from_compos $ 3 units $ 6 lins $ 6 sublins $ 6  ercs $ 1 compo_sub_transfer 8;
			run;

/*This data set initialized the output table that will contain transfers from one component to another
			for all years, compos, units, lins, and to what erc.*/

			data idm_o.xferred;
				length modeling_dates 8 to_compos $ 3 from_compos $ 3 units $ 6 lins $ 6 ercs $ 1 compo_transfer 8;
			run;

/*This data set initialized the output table that will contain pertinent inventory on hand values 
			for all years, compos, units, lins, and to what erc.*/

			data idm_o.inv_positions;
				length modeling_dates 8 compos $ 3 units $ 6 lins $ 6 ercs $ 1 reqd 8 onhand 8 shortages 8 total_excess 8;
			run;

			data idm_o.component_stats;
				length component 8 valid_xfer 8 compo $ 3;
			run;

			data idm_o.erc_p_assign;
				length modeling_dates 8 compos $ 3 units $ 6 lins $ 6 ercs $ 1 erc_p_assign 8;
			run;
			
			data idm_o.erc_A_assign;
				length modeling_dates 8 compos $ 3 units $ 6 lins $ 6 ercs $ 1 erc_a_assign 8;
			run;


/*This i counter is what is used to loop over the observations in the 
	relevant cluster data set*/
	%let i =  1;
	
/*This line of code is the outer loop that controls when we stop processing components.

*/
	%do %while (%eval(&i <= &num_comps));
/*	%do %while (%eval(&i <=3));*/

	/*These macro variables are used to house the inventory data associated to 
	the component we are processing*/
	%let reqd = 0;
	%let inv = 0;
	%let procs = 0;
	%let xfer_in = 0;
	%let xfer_out = 0;

	/* This null data set assigns a value to working_comp
	that is later used to tag temporary data sets and 
	also filter down to the LINs that are being
	processed.*/

	data _null_;
/*		set distinct_components(firstobs = &i. obs = &i.);*/
		set good_clusters(firstobs = &i. obs = &i.);

		call symputx('working_comp',component);
	run;



/*This line of code writes a line to the log that states the 
	components that is being processed*/	
	%put We will now process component &working_comp ;

		/*This data set will filter down to the LINs in the 
			component being processed*/
		data all_lins;
			set clusters;

			if component = &working_comp.;
		run;

		/*This SQL statement uses an inner join as a filtering techinque
		to isolate the inventory for the LINs in the component 
		we are processing*/

		proc sql;
			create table inventory_1 as
			select distinct
				a.compos as c_num, a.units, a.lins, /*a.ercs,*/sum(a.inv) as inv
			from idm_i.inventory as a inner join all_lins as b
			on a.lins = b.lins
			group by a.compos, a.units, a.lins/*, a.ercs*/;
		quit;
	
		/*This data step is used to convert the numeric component value
		to a text string*/

		data inventory;
			set inventory_1;

			compos = substrn(c_num,1,length(c_num));

			drop c_num;
		run;
		
		/*This SQL statement uses an inner join as a filtering techinque
		to isolate the procurements for the LINs in the component 
		we are processing*/

		proc sql;
			create table procurements as
			select
				a.*
			from idm_i.procurements as a inner join all_lins as b on a.lins = b.lins;
		quit;

		data procurements_&working_comp.;
		   set procurements;
		run;

		/*This SQL statement uses an inner join as a filtering techinque
		to isolate the requirement for the LINs in the component 
		we are processing*/
		proc sql;
			create table requirements_1 as
			select
				a.dates, a.compos as c_num, a.units, a.lins, a.ercs, a.reqd
			from idm_i.requirements as a inner join all_lins as b on a.lins = b.lins;
		quit;

		/*This SQL statement uses an inner join as a filtering techinque
		to isolate the transfers coming into the LINs in the component 
		we are processing*/
		proc sql;
			create table xfers_in as
			select distinct
				a.*
			from idm_i.LMI_XFER_ADD as a inner join all_lins as b on a.lins = b.lins;
		quit;

		
		/*This SQL statement uses an inner join as a filtering techinque
			to isolate the transfers going out of the LINs in the component 
			we are processing*/
		
		proc sql;
			create table xfers_out as
			select distinct
				a.*
			from idm_i.LMI_XFER_REMOVE as a inner join all_lins as b on a.lins = b.lins;
		quit;

		/*This SQL statement assigns the sum of transfers 
			coming into all of the LINs being processed to the
			proper macro variable*/

		proc sql noprint;
			select
				max(sum(qty),0) into :xfer_in
			from xfers_in;
		quit;

		/*This SQL statement assigns the sum of transfers 
			going out of all of the LINs being processed to the
			proper macro variable*/

		
		proc sql noprint;
			select
				max(sum(qty),0) into :xfer_out
			from xfers_out;
		quit;
	
	/*This SQL statement assigns the sum of requirements 
		across all years for the LINs being processed to the
			proper macro variable*/


		proc sql noprint;
			select
				max(sum(reqd),0) into :reqd
			from requirements_1;
		quit;
		
	
	/*This SQL statement assigns the sum of inventory 
		for the LINs being processed to the	proper macro variable*/

		proc sql noprint;
			select
				max(sum(inv),0) into :inv
			from inventory_1;
		quit;

	
	/*This SQL statement assigns the sum of procurements 
		across all years for the LINs being processed to the
			proper macro variable*/

		proc sql noprint;
			select
				max(sum(qty),0) into :procs
/*				max(sum(procs),0) into :procs*/
			from procurements;
		quit;
		
/*The logic behind these checks are as follows and is underpinned
		by the checking and cleaning of the data:

		1) if there are transfers of inventory then there will be inventory
		currently on hand so that case is covered.
		2) If there are LIN_IN recap amounts then there will
		be inventory on hand.
		3) If there are standard new procuremetns or new deliveries
		then we will need to place the quantities somewhere (either into
		an excess pile or into a requirement
		4) If there are requiremetns for a LIN then it must be considered regardless
		of the presence of inventory/procurements/transfers.*/

/*These lines of code write lines of statistics to the log for the
	components that is being processed*/		
	%put There number of items required in cluster &working_comp;
	%put is &reqd;
	%put There number items initially available in cluster &working_comp;
	%put is &inv;
	%put There number of procurements available in cluster &working_comp;
	%put is &procs;
	%put There number of transfers coming into cluster &working_comp;
	%put is &xfer_in;
	%put There number of transfers going out in cluster &working_comp;
	%put is &xfer_out;

	/*This if-then statement is false then the model processing is not
	necessary - given that we performed this when we identified the distinct
	components this should always be true but is here as a safe-guard to
	double check the inventory rather than dedicate a lot of time to
	components that may have snuck in.*/

	/* the use of an or clause to allow for further processing handles the logic stated above.*/
		
		%if (%eval(&inv. > 0) or %eval(&reqd.> 0) or %eval(&procs.> 0) or %eval(&xfer_in.> 0) or %eval(&xfer_out.> 0)) %then %do;
	
		
/*This sql step will summarize all of the inventory for a LIN and
add a label that will later be transposed on*/
		proc sql;
			create table inv_table as
			select distinct
				lins,
				sum(inv) as v1,
				"Inventory" as label
			from inventory_1
			group by lins;
		quit;

/*This sql step will summarize all of the procurements for a LIN in any year and
add a label that will later be transposed on*/

		proc sql;
			insert into inv_table
			select distinct
				lins,
				sum(qty) as v1,
/*				sum(procs) as v1,*/
				"procs" as label
			from procurements
			group by lins;
		quit;

/*This sql step will summarize all of the requirements for a LIN in any year and
add a label that will later be transposed on*/
	
		proc sql;
			insert into inv_table
			select distinct
				lins,
				sum(reqd) as v1,
				"reqd" as label
			from requirements_1
			group by lins;
		quit;


/*This sql step will summarize all of the transfers into a LIN in any year and
add a label that will later be transposed on*/

		proc sql;
			insert into inv_table
			select distinct
				lins,
				sum(qty) as v1,
				"xfer_in" as label
			from xfers_in
			group by lins;
		quit;

/*This sql step will summarize all of the transfers out of a LIN in any year and
add a label that will later be transposed on*/
		proc sql;
			insert into inv_table
			select distinct
				lins,
				sum(qty) as v1,
				"xfer_out" as label
			from xfers_out
			group by lins;
		quit;

		
/*This sort and transpose procedure produce the inventory table 
		which will contain the LINs and values relative to the
		label assigned in the previous SQL statements*/
		proc sort data = inv_table; by lins label;
		run;
		proc transpose data = inv_table out = inv_xtab_value;
			by lins;
			id label;
			var v1;
		run;
	
/*This data step filters out LINs without inventory (either required or not) data but may have associated
		to a component with inventory inside of it*/

	/*DJE 15NOV2017 - Not sure if this is needed along with the previous steps that
		contribute to it.*/
		data lins_w_inv;
			set inv_xtab_value;

			if reqd = . then reqd = 0;
			if procs = . then procs = 0;
			if inventory = . then inventory = 0;
			if xfer_out = . then xfer_out = 0;
			if xfer_in = . then xfer_in = 0;
			if reqd + procs + inventory + xfer_in + xfer_out > 0;
			
		run;
		


/*This sql step uses a inner join to filter down 
		to only the LINs with inventory data*/
		proc sql;
			create table lins as
			select
				a.*
			from all_lins as a inner join lins_w_inv as b
			on a.lins = b.lins;
		quit;

		
/*This data step produces a set of lins with 
	non-zero requirements. This set will be used 
	to array data and decision variables over 
	LINs that can have inventory assigned to it*/

		data reqd_lins_1;
			set lins_w_inv;

			if reqd > 0;
		run;


/*This data step produces a set of lins with 
	non-zero procurements plus inventory. This set will be used 
	to array data and decision variables over 
	LINs that can have inventory assigned from them.*/
	
		data inv_lins_1;
			set lins_w_inv;

			/*15NOV2017: DJE maybe add in xfer_in to 
					this equation and see what happens.*/

			if procs + inventory > 0;
		run;

		
/*This sql query produces a distinct list of lins with 
	non-zero procurements or inventory. This set will be used 
	to array data and decision variables over 
	LINs that can have inventory assigned from them*/
	

		proc sql;
			create table inv_lins as
			select
				a.*
			from all_lins as a inner join inv_lins_1 as b on a.lins = b.lins;
		quit;

		
		proc sql;
			create table reqd_lins as
			select
				a.*
			from all_lins as a inner join reqd_lins_1 as b on a.lins = b.lins;
		quit;


/*This sql query joins the sub-rules to LINs
		that can have inventory assigned to them*/
	
		
		proc sql;
			create table sub_filter_1 as
			select 
				a.*,b.lins as c_lin
/*			from idm_i.sub_rules as a left join lins_w_inv as b  on a.lins = b.lins;*/
			from idm_i.sub_rules as a left join reqd_lins_1 as b  on a.lins = b.lins;
		quit;

/*This sql query joins the sub-rules to LINs
		that can have inventory assigned from them*/
	
		
		proc sql;
			create table sub_filter_2 as
			select 
				a.*,b.lins as s_lin
			from sub_filter_1 as a left join lins_w_inv as b on a.sublins = b.lins;
		quit;

/*This data step will filter the sub-rules down to observations where
		a donor and reciever can be used to assign inventory*/

		data sub_rules;
			set sub_filter_2;

			if (c_lin ne "" and s_lin ne "") and source ne 7 and c_lin ne s_lin;
		run;

/*This data step is used to convert the numeric component value
		to a text string*/

		data requirements;
			set requirements_1;

			compos = substrn(c_num,1,length(c_num));

			drop c_num;
		run;
/*This sql step creates the distinct listing of erc codes for
		assignment decision variables to array over. */
		proc sql;
			create table reqd_ercs as
			select distinct
				ercs 
			from requirements;
		quit;

/*This sql step creates the distinct listing of erc codes for
		inventory data elements to array over. */
		
/*		proc sql;*/
/*			create table inv_ercs as*/
/*			select distinct*/
/*				ercs */
/*			from inventory;*/
/*		quit;*/

/*This sql step creates the distinct listing of units the inventory data set 
		for model decision variables to array over. */
		
		proc sql;
			create table units_1 as
			select distinct
				units
			from requirements
		quit;


/*This sql step creates the distinct listing of units the requirement data set 
		for model decision variables to array over. */
		
		proc sql;
			insert into units_1 
			select distinct
				units
			from inventory
		quit;

/*This sql step creates the final distinct listing of units 
		for model decision variables to array over. */

		proc sql;
			create table UNITS as
			select distinct
				UNITS
			from units_1;
		quit;

/*This sql step creates the distinct listing of units and their component
		for model decision variables to array over from the requirement data. */
		proc sql;
			create table unit_compo_number_1 as
			select distinct
				units, compos
			from requirements;
		quit;

/*This sql step adds the distinct listing of units and their component
		for model decision variables to array over from the inventory data. */
		
		proc sql;
			insert into unit_compo_number_1 
			select distinct
				units, compos
			from inventory
		quit;

/*This sql step adds the distinct listing of units and their component
		for model decision variables to array over from the tranfers out data. */
		proc sql;
			insert into unit_compo_number_1 
			select distinct
				units, compos
			from xfers_out
		quit;

/*This sql step adds the distinct listing of units and their component
		for model decision variables to array over from the tranfers in data. */
		proc sql;
			insert into unit_compo_number_1 
			select distinct
				units, compos
			from xfers_in
		quit;

/*This sql step takes the distinct listing of units from the previous data elements*/

		proc sql;
			create table unit_compo_number2 as
			select distinct
				units, compos
			from unit_compo_number_1;
		quit;

/*This sql step takes the distinct listing of compos from the previous unit
		compo number data set*/

		proc sql;
			create table compos_1 as
			select distinct
				compos as c_num
			from unit_compo_number2;
		quit;

/*This sql step adds compos from the procurement data to 
		the components data set*/

		proc sql;
			insert into compos_1
			select	
				compos as c_num
			from procurements;
		quit;

/*This procedure grabs the distinct components*/

		proc sort nodupkey data = compos_1; by c_num; run;

/*This data step ensures the compo value is text format*/

		data compos;
			set compos_1;
			compos = substrn(c_num,1,length(c_num));
			drop c_num;
		run;	

		/*Creation of the ERC P ASSIGN INDEX SET: DJE 07APR2017 1410 Start*/

 
/*This sql step uses an inner join to get the darpl data
		down ot the relevant units.*/
		proc sql;
			create table darpl_1 as
			select 
				a.dates, a.compos as c_num, a.units, a.PRIORITY as darpl
			from idm_i.darpl as a inner join units as b on a.units = b.units;
		quit;

/*This data step ensures the compo value is text format*/
		data darpl;
			set darpl_1;
			compos = substrn(c_num,1,length(c_num));
			drop c_num;
		run;

/*This line of coded initializes the number of valid transfer rules
		identified*/
		%let 	valid_tranfer = 0;

/*This sql step counts the number of intercompo transfers allowed
		and assigns it to the valid transfer variable*/
		proc sql noprint;
			select
				max(0,sum(valid)) into :valid_transfer
			from idm_i.compo_transfer where to_compos ne from_compos;
		quit;

/*This line of code prints the number of valid transfer rules to the log*/
		%put there are &valid_transfer compo transfer combinations;

/*This if-then statement determines if we can run each component individually
		or if they all need to be run together due to the allowability of intercompo transfers*/
			/*If this statement is true then we can run components individually*/
			%if (%eval(&valid_transfer = 0)) %then %do;

			
/*This macro variable controls an inner loop that processes the component individually*/
				%let p_compo = 1;

/*This macro variable is the terminal condition for when we have
				completed processing all components*/
				%let m_compo = 0 ;

/*This sql step counts the number of compos to process  
		and assigns it to the loop termination variable*/
				proc sql noprint;
					select
						count(compos) into :m_compo
					from compos;
				quit;
				
			/*This do-while loop processes each component*/
				
				/*Added this to enable the first two year constraints*/
				%let year_two = %eval(&min_year + 1);
				%let compo = ;

				/*The following loop will process over the compos in sequential order*/
				%do %while (%eval(&p_compo <=  &m_compo));				
			/*This data step creates a set that will be used
				to filter the unit set down to the relevant units*/
				data p_compos;
					set compos(firstobs = &p_compo. obs = &p_compo.);
						
					call symput('compo',compos);
				run;


				/*This grabs the listing of data elements
				that will be used to array over erc P decision variables*/
								
				proc sql;
					create table ERC_P_IND_SET as
					select distinct
						DATES,
						compos,
						units,
						lins,
						reqd
					from requirements where reqd>0 and ERCS = "P" and compos = "&COMPO";
				quit;
				
				/*This grabs the listing of data elements
				that will be used to array over erc A decision variables*/
				proc sql;
					create table ERC_A_IND_SET as
					select distinct
						DATES,
						compos,
						units,
						lins,
						reqd
					from requirements where reqd>0 and ERCS = "A" and compos = "&COMPO";
				quit;

				/*This creates the cartesian product of LIN to sublin storage slots
				for ERC P decisions variables.*/
				proc sql;
					create table ERC_P_SUBID_SET as
					select
						a.*, b.SUBLINS
					from ERC_P_IND_SET as a inner join sub_rules as b
					on a.lins =  b.lins;
				quit;

				proc sql;
					create table SUBLIN_ID_SET1 as
					select distinct
						a.lins, a.sublins
					from ERC_P_SUBID_SET as a;
				quit;

				/*This creates the cartesian product of LIN to sublin storage slots
				for ERC A decisions variables.*/
				proc sql;
					create table ERC_A_SUBID_SET as
					select
						a.*, b.SUBLINS
					from ERC_A_IND_SET as a inner join sub_rules as b
					on a.lins =  b.lins;
				quit;

				proc sql;
					create table SUBLIN_ID_SET2 as
					select distinct
						a.lins, a.sublins
					from ERC_A_SUBID_SET as a;
				quit;

				data SUBLIN_ID_SET_JOIN;
					set SUBLIN_ID_SET2;
				run;

				PROC append base=SUBLIN_ID_SET_JOIN data=SUBLIN_ID_SET1; run;

				proc sort data=SUBLIN_ID_SET_JOIN out=SUBLIN_ID_SET NODUPKEY;
				   by LINS SUBLINS;
				run;
				
	
			/*This sql step uses an inner join to filter down the unit
					set to the pertainant units*/
								
					proc sql;
						create table unit_compo_number as
						select distinct
							a.units, a.compos
						from unit_compo_number2 as a inner join p_compos as b on a.compos = b.compos;
					quit;

					
			/*This line of code envokes the optimization defined in the run_opt_model macro below.*/
					%run_opt_model;

				data comp_stat_append_set;
					
					length component 8 valid_xfer 8 compo $ 3;

					component = &working_comp.;
					valid_xfer = &valid_tranfer.;
					compo = "&compo";

				run;

				proc append base = idm_o.component_stats data = comp_stat_append_set; run;

			/*This line of code adds 1 to p-compo so we can move on to the next component*/
					%let p_compo = %eval(&p_compo + 1);
				%end;
			%end;

			/*if the previous if-then statement is false then we process all components 
			together*/
			%else %do;			
			
			/*This data step creates an unfiltered component set that will be used
				to filter the unit set down to the relevant units*/
				data p_compos;
					set compos;
				run;

			/*This sql step uses an inner join to filter down the unit
					set to the pertainant units*/
					
				proc sql;
					create table ERC_P_IND_SET as
					select distinct
						DATES,
						compos,
						units,
						lins,
						reqd
					from requirements where reqd>0 and ERCS = "P";
				quit;

				proc sql;
					create table ERC_A_IND_SET as
					select distinct
						DATES,
						compos,
						units,
						lins,
						reqd
					from requirements where reqd>0 and ERCS = "A";
				quit;

				/*This creates a transfer index set that permits
				erc P transfers.*/
				proc sql;
					create table ERC_P_XFER_IND_SET as
					select distinct
						a.DATES,
						a.compos as to_compos,
						b.from_compos as from_compos,
						a.units,
						a.lins,
						a.reqd
					from requirements as a inner join idm_i.compo_transfer as b on
					a.compos = b.to_compos where b.from_compos ne b.to_compos and a.reqd>0 and a.ERCS = "P";
				quit;
				
				/*This creates a transfer index set that permits
				erc A transfers.*/
				proc sql;
					create table ERC_A_XFER_IND_SET as
					select distinct
						a.DATES,
						a.compos as to_compos,
						b.from_compos as from_compos,
						a.units,
						a.lins,
						a.reqd
					from requirements as a inner join idm_i.compo_transfer as b on
					a.compos = b.to_compos where b.from_compos ne b.to_compos and a.reqd > 0 and a.ERCS = "A";
				quit;

				proc sql;
					create table ERC_P_SUBID_SET as
					select
						a.*, b.SUBLINS
					from ERC_P_IND_SET as a inner join sub_rules as b
					on a.lins =  b.lins;
				quit;

		   /* Trent and Rachel added from the code above  ***/

				proc sql;
					create table SUBLIN_ID_SET1 as
					select distinct
						a.lins, a.sublins
					from ERC_P_SUBID_SET as a;
				quit;
	 /* Above Trent and Rachel added from the code above  ***/
			
				proc sql;
					create table ERC_A_SUBID_SET as
					select
						a.*, b.SUBLINS
					from ERC_A_IND_SET as a inner join sub_rules as b
					on a.lins =  b.lins;
				quit;

   /* Trent and Rachel added from the code above  ***/
                 proc sql;
					create table SUBLIN_ID_SET2 as
					select distinct
						a.lins, a.sublins
					from ERC_A_SUBID_SET as a;
				quit;

				data SUBLIN_ID_SET_JOIN;
					set SUBLIN_ID_SET2;
				run;

				PROC append base=SUBLIN_ID_SET_JOIN data=SUBLIN_ID_SET1; run;

				proc sort data=SUBLIN_ID_SET_JOIN out=SUBLIN_ID_SET NODUPKEY;
				   by LINS SUBLINS;
				run;
 /* Above Trent and Rachel added from the code above  ***/
				proc sql;
					create table unit_compo_number as
					select distinct
						a.units, a.compos
					from unit_compo_number2 as a inner join p_compos as b on a.compos = b.compos;
				quit;

				
				/*This creates a transfer index set that permits
				erc P transfers across substitution rules.*/
				proc sql;
					create table ERC_P_SUBXFER_ID_SET as
					select
						a.*,b.sublins
					from ERC_P_XFER_IND_SET as a inner join sub_rules as b
					on a.lins =  b.lins;
				quit;

				/*This creates a transfer index set that permits
				erc A transfers across substitution rules.*/
				
				proc sql;
					create table ERC_A_SUBXFER_ID_SET as
					select
						a.*,b.sublins
					from ERC_A_XFER_IND_SET as a inner join sub_rules as b
					on a.lins =  b.lins;
				quit;


				proc sql;
					create table LINSUB_ID_SET as
					select distinct
						a.lins
					from SUBLIN_ID_SET as a;
				quit;

				proc sql;
					create table SUBSUB_ID_SET as
					select distinct
						a.sublins
					from SUBLIN_ID_SET as a;
				quit;
				
				/*Added this to enable the first two year constraints*/
				%let year_two = %eval(&min_year + 1);

/*This line of code envokes the optimization defined in the run_opt_model macro*/
				%run_opt_model;

			%end;

		%end;
	/*
		proc datasets noprint kill ;
			run;
			quit;
			*/
	/*this line of code moves us onto the next component to process*/
		%let i = %eval(&i  + 1);

	%end;
%mend;




file name: calc_slide 4_5.sas

proc sql;
		create table OSD.TA_EOH_MOD as
		select distinct
			year,
			compo,
			lin,
			max(current_puc) as current_puc,
			sum(req) as req,
			sum(roh) as roh,
			sum(shortage) as short,
			0 as below_mod
		from OSD.taedp_erc1
		where year=&Y2 and compo ne '6' and req>0
		group by compo, lin;
	quit; 

proc sql;
		create table GTW.TA_EOH_MOD as
		select distinct
			year,
			compo,
			lin,
			max(current_puc) as current_puc,
			sum(req) as req,
			sum(roh) as roh,
			sum(total_subbed) as sub,
			sum(shortage) as short,
			0 as below_mod
		from gtw.taedp_erc1
		where year=&Y2 and compo ne '6' and req>0
		group by compo, lin;
	quit;


	data OSD.TA_EOH_mod_cht(drop=current_puc req sub roh short below_mod);
		format curr_req_cost curr_oh_cost sub_OH_cost below_OH_cost DOLLAR21.2;
		set OSD.TA_EOH_MOD;

		curr_req_cost=current_puc*req;
		curr_oh_cost=current_puc*roh;
		sub_OH_cost=current_puc*sub;
		below_OH_cost=current_puc*below_mod;
		mod_short_cost=curr_req_cost - curr_oh_cost;
		short_cost = mod_short_cost;
	run;

data GTW.TA_EOH_mod_cht(drop=current_puc req sub roh short below_mod);
		format curr_req_cost curr_oh_cost sub_OH_cost below_OH_cost DOLLAR21.2;
		 set GTW.TA_EOH_MOD;

		curr_req_cost=current_puc*req;
		curr_oh_cost=current_puc*roh;
		sub_OH_cost=current_puc*sub;
		below_OH_cost=current_puc*below_mod;
		mod_short_cost=curr_req_cost-curr_oh_cost;
		short_cost=curr_req_cost-curr_oh_cost-sub_OH_cost;
	run;

/***************Slide 4/5 *********/
	proc sql;
		create table OSD.TA_EOH_mod_cht2 as
		select distinct
			compo,
			sum(curr_req_cost) as curr_req_cost,
			sum(curr_oh_cost) as curr_oh_cost,
			0 as sub_OH_cost,
			0 as below_OH_cost,
			(calculated curr_oh_cost + calculated sub_OH_cost) as tot_eoh_cost, 
			sum(mod_short_cost) as mod_short_cost,
			sum(short_cost) as short_cost
			
		from OSD.TA_EOH_mod_cht
		
		group by compo
		order by compo;
	quit; 

	proc sql;
		create table GTW.TA_EOH_mod_cht2 as
		select distinct
			compo,
			sum(curr_req_cost) as curr_req_cost,
			sum(curr_oh_cost) as curr_oh_cost,
			sum(sub_OH_cost) as sub_OH_cost,
			sum(below_OH_cost) as below_OH_cost,
			(calculated curr_oh_cost) as tot_eoh_cost, 
			sum(mod_short_cost) as mod_short_cost,
			sum(short_cost) as short_cost
			
		from GTW.TA_EOH_mod_cht
		
		group by compo
		order by compo;
	quit; 